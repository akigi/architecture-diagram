(function() {
    function r(e, n, t) {
        function o(i, f) {
            if (!n[i]) {
                if (!e[i]) {
                    var c = "function" == typeof require && require;
                    if (!f && c) return c(i, !0);
                    if (u) return u(i, !0);
                    var a = new Error("Cannot find module '" + i + "'");
                    throw a.code = "MODULE_NOT_FOUND", a
                }
                var p = n[i] = {
                    exports: {}
                };
                e[i][0].call(p.exports, function(r) {
                    var n = e[i][1][r];
                    return o(n || r)
                }, p, p.exports, r, e, n, t)
            }
            return n[i].exports
        }
        for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
        return o
    }
    return r
})()({
    1: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        ///<reference path="../extern/d3v3.d.ts"/>
        /*
        ///<reference path="../src/layout.ts"/>
        ///<reference path="../src/d3adaptor.ts"/>
        ///<reference path="../src/vpsc.ts"/>
        ///<reference path="../src/rectangle.ts"/>
        ///<reference path="../src/gridrouter.ts"/>
        ///<reference path="../src/geom.ts"/>
        ///<reference path="../src/batch.ts"/>
        */
        const cola = require("../index");
        const graphlibDot = require("graphlib-dot");
        var dotpowergraph;
        (function(dotpowergraph) {
            function makeSVG(addGridLines, mywidth, myheight) {
                var svg = d3.select("body").append("svg")
                    .attr("width", mywidth)
                    .attr("height", myheight);
                return svg;
            }

            function isIE() {
                return ((navigator.appName == 'Microsoft Internet Explorer') || ((navigator.appName == 'Netscape') && (new RegExp("Trident/.*rv:([0-9]{1,}[\.0-9]{0,})").exec(navigator.userAgent) != null)));
            }

            function gridify(svg, pgLayout, margin, groupMargin) {
                var routes = cola.gridify(pgLayout, 5, margin, groupMargin);
                svg.selectAll('path').remove();
                routes.forEach(route => {
                    var cornerradius = 5;
                    var arrowwidth = 3;
                    var arrowheight = 7;
                    var p = cola.GridRouter.getRoutePath(route, cornerradius, arrowwidth, arrowheight);
                    if (arrowheight > 0) {
                        svg.append('path')
                            .attr('class', 'linkarrowoutline')
                            .attr('d', p.arrowpath);
                        svg.append('path')
                            .attr('class', 'linkarrow')
                            .attr('d', p.arrowpath);
                    }
                    svg.append('path')
                        .attr('class', 'linkoutline')
                        .attr('d', p.routepath)
                        .attr('fill', 'none');
                    svg.append('path')
                        .attr('class', 'link')
                        .attr('d', p.routepath)
                        .attr('fill', 'none');
                });
                svg.selectAll(".label").transition().attr("x", d => d.routerNode.bounds.cx())
                    .attr("y", function(d) {
                        var h = this.getBBox().height;
                        return d.bounds.cy() + h / 3.5;
                    });
                svg.selectAll(".node").transition().attr("x", d => d.routerNode.bounds.x)
                    .attr("y", d => d.routerNode.bounds.y)
                    .attr("width", d => d.routerNode.bounds.width())
                    .attr("height", d => d.routerNode.bounds.height());
                let groupPadding = margin - groupMargin;
                svg.selectAll(".group").transition().attr('x', d => d.routerNode.bounds.x - groupPadding)
                    .attr('y', d => d.routerNode.bounds.y + 2 * groupPadding)
                    .attr('width', d => d.routerNode.bounds.width() - groupPadding)
                    .attr('height', d => d.routerNode.bounds.height() - groupPadding);
            }

            function createPowerGraph(inputjson) {
                var size = [700, 700];
                var svg = makeSVG(false, size[0], size[1]);
                var grouppadding = 0.01;
                inputjson.nodes.forEach(v => {
                    v.width = 70;
                    v.height = 70;
                });
                var margin = 20;
                var groupMargin = 15;
                var pgLayout = cola.powerGraphGridLayout(inputjson, size, grouppadding);
                // filter duplicate links:
                //var es = pgLayout.powerGraph.powerEdges;
                //var copy = [];
                //var n = pgLayout.cola.nodes().length;
                //for (var i = 0; i < es.length; i++) {
                //    var e = es[i];
                //    var dupFound = false;
                //    for (var j = i + 1; j < es.length; j++) {
                //        var f = es[j];
                //        dupFound = ((getId(e.source, n) == getId(f.source, n)) && (getId(e.target, n) == getId(f.target, n)))
                //        || ((getId(e.target, n) == getId(f.source, n)) && (getId(e.source, n) == getId(f.target, n)));
                //        if (dupFound) break;
                //    }
                //    if (!dupFound) copy.push(e);
                //}
                //pgLayout.powerGraph.powerEdges = copy;
                var group = svg.selectAll(".group")
                    .data(pgLayout.powerGraph.groups)
                    .enter().append("rect")
                    .attr("class", "group");
                var node = svg.selectAll(".node")
                    .data(inputjson.nodes)
                    .enter().append("rect")
                    .attr("class", "node");
                node.append("title").text(d => d.name);
                var label = svg.selectAll(".label")
                    .data(inputjson.nodes)
                    .enter().append("text")
                    .attr("class", "label")
                    .text(d => d.name.replace(/^u/, ''));
                gridify(svg, pgLayout, margin, groupMargin);
                let eventStart = {},
                    ghosts = null;

                function getEventPos() {
                    let ev = d3.event;
                    let e = typeof TouchEvent !== 'undefined' && ev.sourceEvent instanceof TouchEvent ? (ev.sourceEvent).changedTouches[0] : ev.sourceEvent;
                    return {
                        x: e.clientX,
                        y: e.clientY
                    };
                }

                function dragStart(d) {
                    ghosts = [1, 2].map(i => svg.append('rect')
                        .attr({
                            class: 'ghost',
                            x: d.routerNode.bounds.x,
                            y: d.routerNode.bounds.y,
                            width: d.routerNode.bounds.width(),
                            height: d.routerNode.bounds.height()
                        }));
                    eventStart[d.routerNode.id] = getEventPos();
                }

                function getDragPos(d) {
                    let p = getEventPos(),
                        startPos = eventStart[d.routerNode.id];
                    return {
                        x: d.routerNode.bounds.x + p.x - startPos.x,
                        y: d.routerNode.bounds.y + p.y - startPos.y
                    };
                }

                function drag(d) {
                    var p = getDragPos(d);
                    ghosts[1].attr(p);
                }

                function dragEnd(d) {
                    let dropPos = getDragPos(d);
                    delete eventStart[d.routerNode.id];
                    d.x = dropPos.x;
                    d.y = dropPos.y;
                    ghosts.forEach(g => g.remove());
                    if (Object.keys(eventStart).length === 0) {
                        gridify(svg, pgLayout, margin, groupMargin);
                    }
                }
                let dragListener = d3.behavior.drag()
                    .on("dragstart", dragStart)
                    .on("drag", drag)
                    .on("dragend", dragEnd);
                node.call(dragListener);
                label.call(dragListener);
            }
            d3.text("graphdata/n26e35.dot", function(f) {
                var digraph = graphlibDot.read(f);
                var nodeNames = digraph.nodes();
                var nodes = new Array(nodeNames.length);
                nodeNames.forEach(function(name, i) {
                    var v = nodes[i] = digraph._nodes[nodeNames[i]];
                    v.id = i;
                    v.name = name;
                });
                const dedges = (digraph.edges());
                let edges = [];
                for (let edge of dedges) {
                    edges.push({
                        source: digraph._nodes[edge.v].id,
                        target: digraph._nodes[edge.w].id
                    });
                }
                createPowerGraph({
                    nodes: nodes,
                    links: edges
                });
            });
        })(dotpowergraph || (dotpowergraph = {}));
    }, {
        "../index": 2,
        "graphlib-dot": 21
    }],
    2: [function(require, module, exports) {
        "use strict";

        function __export(m) {
            for (var p in m)
                if (!exports.hasOwnProperty(p)) exports[p] = m[p];
        }
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        __export(require("./src/adaptor"));
        __export(require("./src/d3adaptor"));
        __export(require("./src/descent"));
        __export(require("./src/geom"));
        __export(require("./src/gridrouter"));
        __export(require("./src/handledisconnected"));
        __export(require("./src/layout"));
        __export(require("./src/layout3d"));
        __export(require("./src/linklengths"));
        __export(require("./src/powergraph"));
        __export(require("./src/pqueue"));
        __export(require("./src/rbtree"));
        __export(require("./src/rectangle"));
        __export(require("./src/shortestpaths"));
        __export(require("./src/vpsc"));
        __export(require("./src/batch"));
    }, {
        "./src/adaptor": 3,
        "./src/batch": 4,
        "./src/d3adaptor": 5,
        "./src/descent": 8,
        "./src/geom": 9,
        "./src/gridrouter": 10,
        "./src/handledisconnected": 11,
        "./src/layout": 12,
        "./src/layout3d": 13,
        "./src/linklengths": 14,
        "./src/powergraph": 15,
        "./src/pqueue": 16,
        "./src/rbtree": 17,
        "./src/rectangle": 18,
        "./src/shortestpaths": 19,
        "./src/vpsc": 20
    }],
    3: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        const layout_1 = require("./layout");
        class LayoutAdaptor extends layout_1.Layout {
            // dummy functions in case not defined by client
            trigger(e) {};
            kick() {};
            drag() {};
            on(eventType, listener) {
                return this;
            };
            constructor(options) {
                super();
                // take in implementation as defined by client
                var self = this;
                var o = options;
                if (o.trigger) {
                    this.trigger = o.trigger;
                }
                if (o.kick) {
                    this.kick = o.kick;
                }
                if (o.drag) {
                    this.drag = o.drag;
                }
                if (o.on) {
                    this.on = o.on;
                }
                this.dragstart = this.dragStart = layout_1.Layout.dragStart;
                this.dragend = this.dragEnd = layout_1.Layout.dragEnd;
            }
        }
        exports.LayoutAdaptor = LayoutAdaptor;
        /**
         * provides an interface for use with any external graph system (e.g. Cytoscape.js):
         */
        function adaptor(options) {
            return new LayoutAdaptor(options);
        }
        exports.adaptor = adaptor;
    }, {
        "./layout": 12
    }],
    4: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        const layout_1 = require("./layout");
        const gridrouter_1 = require("./gridrouter");
        /**
         * @property nudgeGap spacing between parallel edge segments
         * @property margin space around nodes
         * @property groupMargin space around groups
         */
        function gridify(pgLayout, nudgeGap, margin, groupMargin) {
            pgLayout.cola.start(0, 0, 0, 10, false);
            let gridrouter = route(pgLayout.cola.nodes(), pgLayout.cola.groups(), margin, groupMargin);
            return gridrouter.routeEdges(pgLayout.powerGraph.powerEdges, nudgeGap, e => e.source.routerNode.id, e => e.target.routerNode.id);
        }
        exports.gridify = gridify;

        function route(nodes, groups, margin, groupMargin) {
            nodes.forEach(d => {
                d.routerNode = {
                    name: d.name,
                    bounds: d.bounds.inflate(-margin)
                };
            });
            groups.forEach(d => {
                d.routerNode = {
                    bounds: d.bounds.inflate(-groupMargin),
                    children: (typeof d.groups !== 'undefined' ? d.groups.map(c => nodes.length + c.id) : [])
                        .concat(typeof d.leaves !== 'undefined' ? d.leaves.map(c => c.index) : [])
                };
            });
            let gridRouterNodes = nodes.concat(groups).map((d, i) => {
                d.routerNode.id = i;
                return d.routerNode;
            });
            return new gridrouter_1.GridRouter(gridRouterNodes, {
                getChildren: (v) => v.children,
                getBounds: v => v.bounds
            }, margin - groupMargin);
        }

        function powerGraphGridLayout(graph, size, grouppadding) {
            // compute power graph
            var powerGraph;
            graph.nodes.forEach((v, i) => v.index = i);
            new layout_1.Layout()
                .avoidOverlaps(false)
                .nodes(graph.nodes)
                .links(graph.links)
                .powerGraphGroups(function(d) {
                    powerGraph = d;
                    powerGraph.groups.forEach(v => v.padding = grouppadding);
                });
            // construct a flat graph with dummy nodes for the groups and edges connecting group dummy nodes to their children
            // power edges attached to groups are replaced with edges connected to the corresponding group dummy node
            var n = graph.nodes.length;
            var edges = [];
            var vs = graph.nodes.slice(0);
            vs.forEach((v, i) => v.index = i);
            powerGraph.groups.forEach(g => {
                var sourceInd = g.index = g.id + n;
                vs.push(g);
                if (typeof g.leaves !== 'undefined')
                    g.leaves.forEach(v => edges.push({
                        source: sourceInd,
                        target: v.index
                    }));
                if (typeof g.groups !== 'undefined')
                    g.groups.forEach(gg => edges.push({
                        source: sourceInd,
                        target: gg.id + n
                    }));
            });
            powerGraph.powerEdges.forEach(e => {
                edges.push({
                    source: e.source.index,
                    target: e.target.index
                });
            });
            // layout the flat graph with dummy nodes and edges
            new layout_1.Layout()
                .size(size)
                .nodes(vs)
                .links(edges)
                .avoidOverlaps(false)
                .linkDistance(30)
                .symmetricDiffLinkLengths(5)
                .convergenceThreshold(1e-4)
                .start(100, 0, 0, 0, false);
            // final layout taking node positions from above as starting positions
            // subject to group containment constraints
            // and then gridifying the layout
            return {
                cola: new layout_1.Layout()
                    .convergenceThreshold(1e-3)
                    .size(size)
                    .avoidOverlaps(true)
                    .nodes(graph.nodes)
                    .links(graph.links)
                    //.flowLayout('y', 30)
                    .groupCompactness(1e-4)
                    .linkDistance(30)
                    .symmetricDiffLinkLengths(5)
                    .powerGraphGroups(function(d) {
                        powerGraph = d;
                        powerGraph.groups.forEach(function(v) {
                            v.padding = grouppadding;
                        });
                    }).start(50, 0, 100, 0, false),
                powerGraph: powerGraph
            };
        }
        exports.powerGraphGridLayout = powerGraphGridLayout;
    }, {
        "./gridrouter": 10,
        "./layout": 12
    }],
    5: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        const d3v3 = require("./d3v3adaptor");
        const d3v4 = require("./d3v4adaptor");;
        /**
         * provides an interface for use with d3:
         * Correct way to create way to construct the d3 cola object is to pass the d3 object into the adaptor function, like so:
         *
         *   `var d3cola = cola.d3adaptor(d3);`
         *
         * Internally, it will figure out if d3 is version 3 or 4 from the version tag and set up the right event forwarding. Defaults to version 3 if the d3 object is not passed.
         * - uses the d3 event system to dispatch layout events such as:
         *   o "start" (start layout process)
         *   o "tick" (after each layout iteration)
         *   o "end" (layout converged and complete).
         * - uses the d3 timer to queue layout iterations.
         * - sets up d3.behavior.drag to drag nodes
         *   o use `node.call(<the returned instance of Layout>.drag)` to make nodes draggable
         * returns an instance of the cola.Layout itself with which the user
         * can interact directly.
         */
        function d3adaptor(d3Context) {
            if (!d3Context || isD3V3(d3Context)) {
                return new d3v3.D3StyleLayoutAdaptor();
            }
            return new d3v4.D3StyleLayoutAdaptor(d3Context);
        }
        exports.d3adaptor = d3adaptor;

        function isD3V3(d3Context) {
            const v3exp = /^3\./;
            return d3Context.version && d3Context.version.match(v3exp) !== null;
        }
    }, {
        "./d3v3adaptor": 6,
        "./d3v4adaptor": 7
    }],
    6: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        const layout_1 = require("./layout");
        class D3StyleLayoutAdaptor extends layout_1.Layout {
            constructor() {
                super();
                this.event = d3.dispatch(layout_1.EventType[layout_1.EventType.start], layout_1.EventType[layout_1.EventType.tick], layout_1.EventType[layout_1.EventType.end]);
                // bit of trickyness remapping 'this' so we can reference it in the function body.
                var d3layout = this;
                var drag;
                this.drag = function() {
                    if (!drag) {
                        var drag = d3.behavior.drag()
                            .origin(layout_1.Layout.dragOrigin)
                            .on("dragstart.d3adaptor", layout_1.Layout.dragStart)
                            .on("drag.d3adaptor", d => {
                                layout_1.Layout.drag(d, d3.event);
                                d3layout.resume(); // restart annealing
                            })
                            .on("dragend.d3adaptor", layout_1.Layout.dragEnd);
                    }
                    if (!arguments.length)
                        return drag;
                    // this is the context of the function, i.e. the d3 selection
                    this //.on("mouseover.adaptor", colaMouseover)
                        //.on("mouseout.adaptor", colaMouseout)
                        .call(drag);
                };
            }
            trigger(e) {
                var d3event = {
                    type: layout_1.EventType[e.type],
                    alpha: e.alpha,
                    stress: e.stress
                };
                this.event[d3event.type](d3event); // via d3 dispatcher, e.g. event.start(e);
            }
            // iterate layout using a d3.timer, which queues calls to tick repeatedly until tick returns true
            kick() {
                d3.timer(() => super.tick());
            }
            // a function for binding to events on the adapter
            on(eventType, listener) {
                if (typeof eventType === 'string') {
                    this.event.on(eventType, listener);
                } else {
                    this.event.on(layout_1.EventType[eventType], listener);
                }
                return this;
            }
        }
        exports.D3StyleLayoutAdaptor = D3StyleLayoutAdaptor;
        /**
         * provides an interface for use with d3:
         * - uses the d3 event system to dispatch layout events such as:
         *   o "start" (start layout process)
         *   o "tick" (after each layout iteration)
         *   o "end" (layout converged and complete).
         * - uses the d3 timer to queue layout iterations.
         * - sets up d3.behavior.drag to drag nodes
         *   o use `node.call(<the returned instance of Layout>.drag)` to make nodes draggable
         * returns an instance of the cola.Layout itself with which the user
         * can interact directly.
         */
        function d3adaptor() {
            return new D3StyleLayoutAdaptor();
        }
        exports.d3adaptor = d3adaptor;
    }, {
        "./layout": 12
    }],
    7: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        const layout_1 = require("./layout");
        class D3StyleLayoutAdaptor extends layout_1.Layout {
            constructor(d3Context) {
                super();
                this.d3Context = d3Context;
                this.event = d3Context.dispatch(layout_1.EventType[layout_1.EventType.start], layout_1.EventType[layout_1.EventType.tick], layout_1.EventType[layout_1.EventType.end]);
                // bit of trickyness remapping 'this' so we can reference it in the function body.
                var d3layout = this;
                var drag;
                this.drag = function() {
                    if (!drag) {
                        var drag = d3Context.drag()
                            .subject(layout_1.Layout.dragOrigin)
                            .on("start.d3adaptor", layout_1.Layout.dragStart)
                            .on("drag.d3adaptor", d => {
                                layout_1.Layout.drag(d, d3Context.event);
                                d3layout.resume(); // restart annealing
                            })
                            .on("end.d3adaptor", layout_1.Layout.dragEnd);
                    }
                    if (!arguments.length)
                        return drag;
                    // this is the context of the function, i.e. the d3 selection
                    //this//.on("mouseover.adaptor", colaMouseover)
                    //.on("mouseout.adaptor", colaMouseout)
                    arguments[0].call(drag);
                };
            }
            trigger(e) {
                var d3event = {
                    type: layout_1.EventType[e.type],
                    alpha: e.alpha,
                    stress: e.stress
                };
                // the dispatcher is actually expecting something of type EventTarget as the second argument
                // so passing the thing above is totally abusing the pattern... not sure what to do about this yet
                this.event.call(d3event.type, d3event); // via d3 dispatcher, e.g. event.start(e);
            }
            // iterate layout using a d3.timer, which queues calls to tick repeatedly until tick returns true
            kick() {
                var t = this.d3Context.timer(() => super.tick() && t.stop());
            }
            // a function for binding to events on the adapter
            on(eventType, listener) {
                if (typeof eventType === 'string') {
                    this.event.on(eventType, listener);
                } else {
                    this.event.on(layout_1.EventType[eventType], listener);
                }
                return this;
            }
        }
        exports.D3StyleLayoutAdaptor = D3StyleLayoutAdaptor;
    }, {
        "./layout": 12
    }],
    8: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        /**
         * Descent respects a collection of locks over nodes that should not move
         * @class Locks
         */
        class Locks {
            constructor() {
                this.locks = {};
            }
            /**
             * add a lock on the node at index id
             * @method add
             * @param id index of node to be locked
             * @param x required position for node
             */
            add(id, x) {
                /* DEBUG
                            if (isNaN(x[0]) || isNaN(x[1])) debugger;
                DEBUG */
                this.locks[id] = x;
            }
            /**
             * @method clear clear all locks
             */
            clear() {
                this.locks = {};
            }
            /**
             * @isEmpty
             * @returns false if no locks exist
             */
            isEmpty() {
                for (var l in this.locks)
                    return false;
                return true;
            }
            /**
             * perform an operation on each lock
             * @apply
             */
            apply(f) {
                for (var l in this.locks) {
                    f(Number(l), this.locks[l]);
                }
            }
        }
        exports.Locks = Locks;
        /**
         * Uses a gradient descent approach to reduce a stress or p-stress goal function over a graph with specified ideal edge lengths or a square matrix of dissimilarities.
         * The standard stress function over a graph nodes with position vectors x,y,z is (mathematica input):
         *   stress[x_,y_,z_,D_,w_]:=Sum[w[[i,j]] (length[x[[i]],y[[i]],z[[i]],x[[j]],y[[j]],z[[j]]]-d[[i,j]])^2,{i,Length[x]-1},{j,i+1,Length[x]}]
         * where: D is a square matrix of ideal separations between nodes, w is matrix of weights for those separations
         *        length[x1_, y1_, z1_, x2_, y2_, z2_] = Sqrt[(x1 - x2)^2 + (y1 - y2)^2 + (z1 - z2)^2]
         * below, we use wij = 1/(Dij^2)
         *
         * @class Descent
         */
        class Descent {
            /**
             * @method constructor
             * @param x {number[][]} initial coordinates for nodes
             * @param D {number[][]} matrix of desired distances between pairs of nodes
             * @param G {number[][]} [default=null] if specified, G is a matrix of weights for goal terms between pairs of nodes.
             * If G[i][j] > 1 and the separation between nodes i and j is greater than their ideal distance, then there is no contribution for this pair to the goal
             * If G[i][j] <= 1 then it is used as a weighting on the contribution of the variance between ideal and actual separation between i and j to the goal function
             */
            constructor(x, D, G = null) {
                this.D = D;
                this.G = G;
                this.threshold = 0.0001;
                // Parameters for grid snap stress.
                // TODO: Make a pluggable "StressTerm" class instead of this
                // mess.
                this.numGridSnapNodes = 0;
                this.snapGridSize = 100;
                this.snapStrength = 1000;
                this.scaleSnapByMaxH = false;
                this.random = new PseudoRandom();
                this.project = null;
                this.x = x;
                this.k = x.length; // dimensionality
                var n = this.n = x[0].length; // number of nodes
                this.H = new Array(this.k);
                this.g = new Array(this.k);
                this.Hd = new Array(this.k);
                this.a = new Array(this.k);
                this.b = new Array(this.k);
                this.c = new Array(this.k);
                this.d = new Array(this.k);
                this.e = new Array(this.k);
                this.ia = new Array(this.k);
                this.ib = new Array(this.k);
                this.xtmp = new Array(this.k);
                this.locks = new Locks();
                this.minD = Number.MAX_VALUE;
                var i = n,
                    j;
                while (i--) {
                    j = n;
                    while (--j > i) {
                        var d = D[i][j];
                        if (d > 0 && d < this.minD) {
                            this.minD = d;
                        }
                    }
                }
                if (this.minD === Number.MAX_VALUE)
                    this.minD = 1;
                i = this.k;
                while (i--) {
                    this.g[i] = new Array(n);
                    this.H[i] = new Array(n);
                    j = n;
                    while (j--) {
                        this.H[i][j] = new Array(n);
                    }
                    this.Hd[i] = new Array(n);
                    this.a[i] = new Array(n);
                    this.b[i] = new Array(n);
                    this.c[i] = new Array(n);
                    this.d[i] = new Array(n);
                    this.e[i] = new Array(n);
                    this.ia[i] = new Array(n);
                    this.ib[i] = new Array(n);
                    this.xtmp[i] = new Array(n);
                }
            }
            static createSquareMatrix(n, f) {
                var M = new Array(n);
                for (var i = 0; i < n; ++i) {
                    M[i] = new Array(n);
                    for (var j = 0; j < n; ++j) {
                        M[i][j] = f(i, j);
                    }
                }
                return M;
            }
            offsetDir() {
                var u = new Array(this.k);
                var l = 0;
                for (var i = 0; i < this.k; ++i) {
                    var x = u[i] = this.random.getNextBetween(0.01, 1) - 0.5;
                    l += x * x;
                }
                l = Math.sqrt(l);
                return u.map(x => x *= this.minD / l);
            }
            // compute first and second derivative information storing results in this.g and this.H
            computeDerivatives(x) {
                const n = this.n;
                if (n < 1)
                    return;
                let i;
                /* DEBUG
                            for (var u: number = 0; u < n; ++u)
                                for (i = 0; i < this.k; ++i)
                                    if (isNaN(x[i][u])) debugger;
                DEBUG */
                let d = new Array(this.k); // distance vector
                let d2 = new Array(this.k); // distance vector squared
                let Huu = new Array(this.k); // Hessian diagonal
                let maxH = 0; // max Hessian matrix entry
                // across all nodes u
                for (let u = 0; u < n; ++u) {
                    // zero gradient and hessian diagonals
                    for (i = 0; i < this.k; ++i)
                        Huu[i] = this.g[i][u] = 0;
                    // across all nodes v
                    for (let v = 0; v < n; ++v) {
                        if (u === v)
                            continue;
                        // The following loop computes distance vector and
                        // randomly displaces nodes that are at identical positions
                        let maxDisplaces = n; // avoid infinite loop in the case of numerical issues, such as huge values
                        let distanceSquared = 0;
                        while (maxDisplaces--) {
                            distanceSquared = 0;
                            for (i = 0; i < this.k; ++i) {
                                const dx = d[i] = x[i][u] - x[i][v];
                                distanceSquared += d2[i] = dx * dx;
                            }
                            if (distanceSquared > 1e-9)
                                break;
                            const rd = this.offsetDir();
                            for (i = 0; i < this.k; ++i)
                                x[i][v] += rd[i];
                        }
                        const distance = Math.sqrt(distanceSquared);
                        const idealDistance = this.D[u][v];
                        // weights are passed via G matrix.
                        // weight > 1 means not immediately connected
                        // small weights (<<1) are used for group dummy nodes
                        let weight = this.G != null ? this.G[u][v] : 1;
                        // ignore long range attractions for nodes not immediately connected (P-stress)
                        if (weight > 1 && distance > idealDistance || !isFinite(idealDistance)) {
                            for (i = 0; i < this.k; ++i)
                                this.H[i][u][v] = 0;
                            continue;
                        }
                        // weight > 1 was just an indicator - this is an arcane interface,
                        // but we are trying to be economical storing and passing node pair info
                        if (weight > 1) {
                            weight = 1;
                        }
                        const idealDistSquared = idealDistance * idealDistance,
                            gs = 2 * weight * (distance - idealDistance) / (idealDistSquared * distance),
                            distanceCubed = distanceSquared * distance,
                            hs = 2 * -weight / (idealDistSquared * distanceCubed);
                        if (!isFinite(gs))
                            console.log(gs);
                        for (i = 0; i < this.k; ++i) {
                            this.g[i][u] += d[i] * gs;
                            Huu[i] -= this.H[i][u][v] = hs * (2 * distanceCubed + idealDistance * (d2[i] - distanceSquared));
                        }
                    }
                    for (i = 0; i < this.k; ++i)
                        maxH = Math.max(maxH, this.H[i][u][u] = Huu[i]);
                }
                // Grid snap forces
                var r = this.snapGridSize / 2;
                var g = this.snapGridSize;
                var w = this.snapStrength;
                var k = w / (r * r);
                var numNodes = this.numGridSnapNodes;
                //var numNodes = n;
                for (var u = 0; u < numNodes; ++u) {
                    for (i = 0; i < this.k; ++i) {
                        var xiu = this.x[i][u];
                        var m = xiu / g;
                        var f = m % 1;
                        var q = m - f;
                        var a = Math.abs(f);
                        var dx = (a <= 0.5) ? xiu - q * g :
                            (xiu > 0) ? xiu - (q + 1) * g : xiu - (q - 1) * g;
                        if (-r < dx && dx <= r) {
                            if (this.scaleSnapByMaxH) {
                                this.g[i][u] += maxH * k * dx;
                                this.H[i][u][u] += maxH * k;
                            } else {
                                this.g[i][u] += k * dx;
                                this.H[i][u][u] += k;
                            }
                        }
                    }
                }
                if (!this.locks.isEmpty()) {
                    this.locks.apply((u, p) => {
                        for (i = 0; i < this.k; ++i) {
                            this.H[i][u][u] += maxH;
                            this.g[i][u] -= maxH * (p[i] - x[i][u]);
                        }
                    });
                }
                /* DEBUG
                            for (var u: number = 0; u < n; ++u)
                                for (i = 0; i < this.k; ++i) {
                                    if (isNaN(this.g[i][u])) debugger;
                                    for (var v: number = 0; v < n; ++v)
                                        if (isNaN(this.H[i][u][v])) debugger;
                                }
                DEBUG */
            }
            static dotProd(a, b) {
                var x = 0,
                    i = a.length;
                while (i--)
                    x += a[i] * b[i];
                return x;
            }
            // result r = matrix m * vector v
            static rightMultiply(m, v, r) {
                var i = m.length;
                while (i--)
                    r[i] = Descent.dotProd(m[i], v);
            }
            // computes the optimal step size to take in direction d using the
            // derivative information in this.g and this.H
            // returns the scalar multiplier to apply to d to get the optimal step
            computeStepSize(d) {
                var numerator = 0,
                    denominator = 0;
                for (var i = 0; i < this.k; ++i) {
                    numerator += Descent.dotProd(this.g[i], d[i]);
                    Descent.rightMultiply(this.H[i], d[i], this.Hd[i]);
                    denominator += Descent.dotProd(d[i], this.Hd[i]);
                }
                if (denominator === 0 || !isFinite(denominator))
                    return 0;
                return 1 * numerator / denominator;
            }
            reduceStress() {
                this.computeDerivatives(this.x);
                var alpha = this.computeStepSize(this.g);
                for (var i = 0; i < this.k; ++i) {
                    this.takeDescentStep(this.x[i], this.g[i], alpha);
                }
                return this.computeStress();
            }
            static copy(a, b) {
                var m = a.length,
                    n = b[0].length;
                for (var i = 0; i < m; ++i) {
                    for (var j = 0; j < n; ++j) {
                        b[i][j] = a[i][j];
                    }
                }
            }
            // takes a step of stepSize * d from x0, and then project against any constraints.
            // result is returned in r.
            // x0: starting positions
            // r: result positions will be returned here
            // d: unconstrained descent vector
            // stepSize: amount to step along d
            stepAndProject(x0, r, d, stepSize) {
                Descent.copy(x0, r);
                this.takeDescentStep(r[0], d[0], stepSize);
                if (this.project)
                    this.project[0](x0[0], x0[1], r[0]);
                this.takeDescentStep(r[1], d[1], stepSize);
                if (this.project)
                    this.project[1](r[0], x0[1], r[1]);
                // todo: allow projection against constraints in higher dimensions
                for (var i = 2; i < this.k; i++)
                    this.takeDescentStep(r[i], d[i], stepSize);
                // the following makes locks extra sticky... but hides the result of the projection from the consumer
                //if (!this.locks.isEmpty()) {
                //    this.locks.apply((u, p) => {
                //        for (var i = 0; i < this.k; i++) {
                //            r[i][u] = p[i];
                //        }
                //    });
                //}
            }
            static mApply(m, n, f) {
                var i = m;
                while (i-- > 0) {
                    var j = n;
                    while (j-- > 0)
                        f(i, j);
                }
            }
            matrixApply(f) {
                Descent.mApply(this.k, this.n, f);
            }
            computeNextPosition(x0, r) {
                this.computeDerivatives(x0);
                var alpha = this.computeStepSize(this.g);
                this.stepAndProject(x0, r, this.g, alpha);
                /* DEBUG
                            for (var u: number = 0; u < this.n; ++u)
                                for (var i = 0; i < this.k; ++i)
                                    if (isNaN(r[i][u])) debugger;
                DEBUG */
                if (this.project) {
                    this.matrixApply((i, j) => this.e[i][j] = x0[i][j] - r[i][j]);
                    var beta = this.computeStepSize(this.e);
                    beta = Math.max(0.2, Math.min(beta, 1));
                    this.stepAndProject(x0, r, this.e, beta);
                }
            }
            run(iterations) {
                var stress = Number.MAX_VALUE,
                    converged = false;
                while (!converged && iterations-- > 0) {
                    var s = this.rungeKutta();
                    converged = Math.abs(stress / s - 1) < this.threshold;
                    stress = s;
                }
                return stress;
            }
            rungeKutta() {
                this.computeNextPosition(this.x, this.a);
                Descent.mid(this.x, this.a, this.ia);
                this.computeNextPosition(this.ia, this.b);
                Descent.mid(this.x, this.b, this.ib);
                this.computeNextPosition(this.ib, this.c);
                this.computeNextPosition(this.c, this.d);
                var disp = 0;
                this.matrixApply((i, j) => {
                    var x = (this.a[i][j] + 2.0 * this.b[i][j] + 2.0 * this.c[i][j] + this.d[i][j]) / 6.0,
                        d = this.x[i][j] - x;
                    disp += d * d;
                    this.x[i][j] = x;
                });
                return disp;
            }
            static mid(a, b, m) {
                Descent.mApply(a.length, a[0].length, (i, j) => m[i][j] = a[i][j] + (b[i][j] - a[i][j]) / 2.0);
            }
            takeDescentStep(x, d, stepSize) {
                for (var i = 0; i < this.n; ++i) {
                    x[i] = x[i] - stepSize * d[i];
                }
            }
            computeStress() {
                var stress = 0;
                for (var u = 0, nMinus1 = this.n - 1; u < nMinus1; ++u) {
                    for (var v = u + 1, n = this.n; v < n; ++v) {
                        var l = 0;
                        for (var i = 0; i < this.k; ++i) {
                            var dx = this.x[i][u] - this.x[i][v];
                            l += dx * dx;
                        }
                        l = Math.sqrt(l);
                        var d = this.D[u][v];
                        if (!isFinite(d))
                            continue;
                        var rl = d - l;
                        var d2 = d * d;
                        stress += rl * rl / d2;
                    }
                }
                return stress;
            }
        }
        Descent.zeroDistance = 1e-10;
        exports.Descent = Descent;
        // Linear congruential pseudo random number generator
        class PseudoRandom {
            constructor(seed = 1) {
                this.seed = seed;
                this.a = 214013;
                this.c = 2531011;
                this.m = 2147483648;
                this.range = 32767;
            }
            // random real between 0 and 1
            getNext() {
                this.seed = (this.seed * this.a + this.c) % this.m;
                return (this.seed >> 16) / this.range;
            }
            // random real between min and max
            getNextBetween(min, max) {
                return min + this.getNext() * (max - min);
            }
        }
        exports.PseudoRandom = PseudoRandom;
    }, {}],
    9: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        const rectangle_1 = require("./rectangle");
        class Point {}
        exports.Point = Point;
        class LineSegment {
            constructor(x1, y1, x2, y2) {
                this.x1 = x1;
                this.y1 = y1;
                this.x2 = x2;
                this.y2 = y2;
            }
        }
        exports.LineSegment = LineSegment;
        class PolyPoint extends Point {}
        exports.PolyPoint = PolyPoint;
        /** tests if a point is Left|On|Right of an infinite line.
         * @param points P0, P1, and P2
         * @return >0 for P2 left of the line through P0 and P1
         *            =0 for P2 on the line
         *            <0 for P2 right of the line
         */
        function isLeft(P0, P1, P2) {
            return (P1.x - P0.x) * (P2.y - P0.y) - (P2.x - P0.x) * (P1.y - P0.y);
        }
        exports.isLeft = isLeft;

        function above(p, vi, vj) {
            return isLeft(p, vi, vj) > 0;
        }

        function below(p, vi, vj) {
            return isLeft(p, vi, vj) < 0;
        }
        /**
         * returns the convex hull of a set of points using Andrew's monotone chain algorithm
         * see: http://geomalgorithms.com/a10-_hull-1.html#Monotone%20Chain
         * @param S array of points
         * @return the convex hull as an array of points
         */
        function ConvexHull(S) {
            var P = S.slice(0).sort((a, b) => a.x !== b.x ? b.x - a.x : b.y - a.y);
            var n = S.length,
                i;
            var minmin = 0;
            var xmin = P[0].x;
            for (i = 1; i < n; ++i) {
                if (P[i].x !== xmin)
                    break;
            }
            var minmax = i - 1;
            var H = [];
            H.push(P[minmin]); // push minmin point onto stack
            if (minmax === n - 1) { // degenerate case: all x-coords == xmin
                if (P[minmax].y !== P[minmin].y) // a  nontrivial segment
                    H.push(P[minmax]);
            } else {
                // Get the indices of points with max x-coord and min|max y-coord
                var maxmin, maxmax = n - 1;
                var xmax = P[n - 1].x;
                for (i = n - 2; i >= 0; i--)
                    if (P[i].x !== xmax)
                        break;
                maxmin = i + 1;
                // Compute the lower hull on the stack H
                i = minmax;
                while (++i <= maxmin) {
                    // the lower line joins P[minmin]  with P[maxmin]
                    if (isLeft(P[minmin], P[maxmin], P[i]) >= 0 && i < maxmin)
                        continue; // ignore P[i] above or on the lower line
                    while (H.length > 1) // there are at least 2 points on the stack
                    {
                        // test if  P[i] is left of the line at the stack top
                        if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)
                            break; // P[i] is a new hull  vertex
                        else
                            H.length -= 1; // pop top point off  stack
                    }
                    if (i != minmin)
                        H.push(P[i]);
                }
                // Next, compute the upper hull on the stack H above the bottom hull
                if (maxmax != maxmin) // if  distinct xmax points
                    H.push(P[maxmax]); // push maxmax point onto stack
                var bot = H.length; // the bottom point of the upper hull stack
                i = maxmin;
                while (--i >= minmax) {
                    // the upper line joins P[maxmax]  with P[minmax]
                    if (isLeft(P[maxmax], P[minmax], P[i]) >= 0 && i > minmax)
                        continue; // ignore P[i] below or on the upper line
                    while (H.length > bot) // at least 2 points on the upper stack
                    {
                        // test if  P[i] is left of the line at the stack top
                        if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)
                            break; // P[i] is a new hull  vertex
                        else
                            H.length -= 1; // pop top point off  stack
                    }
                    if (i != minmin)
                        H.push(P[i]); // push P[i] onto stack
                }
            }
            return H;
        }
        exports.ConvexHull = ConvexHull;
        // apply f to the points in P in clockwise order around the point p
        function clockwiseRadialSweep(p, P, f) {
            P.slice(0).sort((a, b) => Math.atan2(a.y - p.y, a.x - p.x) - Math.atan2(b.y - p.y, b.x - p.x)).forEach(f);
        }
        exports.clockwiseRadialSweep = clockwiseRadialSweep;

        function nextPolyPoint(p, ps) {
            if (p.polyIndex === ps.length - 1)
                return ps[0];
            return ps[p.polyIndex + 1];
        }

        function prevPolyPoint(p, ps) {
            if (p.polyIndex === 0)
                return ps[ps.length - 1];
            return ps[p.polyIndex - 1];
        }
        // tangent_PointPolyC(): fast binary search for tangents to a convex polygon
        //    Input:  P = a 2D point (exterior to the polygon)
        //            n = number of polygon vertices
        //            V = array of vertices for a 2D convex polygon
        //    Output: rtan = index of rightmost tangent point V[rtan]
        //            ltan = index of leftmost tangent point V[ltan]
        function tangent_PointPolyC(P, V) {
            // Rtangent_PointPolyC and Ltangent_PointPolyC require polygon to be
            // "closed" with the first vertex duplicated at end, so V[n-1] = V[0].
            let Vclosed = V.slice(0); // Copy V
            Vclosed.push(V[0]); // Add V[0] at end
            return {
                rtan: Rtangent_PointPolyC(P, Vclosed),
                ltan: Ltangent_PointPolyC(P, Vclosed)
            };
        }
        // Rtangent_PointPolyC(): binary search for convex polygon right tangent
        //    Input:  P = a 2D point (exterior to the polygon)
        //            n = number of polygon vertices
        //            V = array of vertices for a 2D convex polygon with first
        //                vertex duplicated as last, so V[n-1] = V[0]
        //    Return: index "i" of rightmost tangent point V[i]
        function Rtangent_PointPolyC(P, V) {
            var n = V.length - 1;
            // use binary search for large convex polygons
            var a, b, c; // indices for edge chain endpoints
            var upA, dnC; // test for up direction of edges a and c
            // rightmost tangent = maximum for the isLeft() ordering
            // test if V[0] is a local maximum
            if (below(P, V[1], V[0]) && !above(P, V[n - 1], V[0]))
                return 0; // V[0] is the maximum tangent point
            for (a = 0, b = n;;) { // start chain = [0,n] with V[n]=V[0]
                if (b - a === 1)
                    if (above(P, V[a], V[b]))
                        return a;
                    else
                        return b;
                c = Math.floor((a + b) / 2); // midpoint of [a,b], and 0<c<n
                dnC = below(P, V[c + 1], V[c]);
                if (dnC && !above(P, V[c - 1], V[c]))
                    return c; // V[c] is the maximum tangent point
                // no max yet, so continue with the binary search
                // pick one of the two subchains [a,c] or [c,b]
                upA = above(P, V[a + 1], V[a]);
                if (upA) { // edge a points up
                    if (dnC) // edge c points down
                        b = c; // select [a,c]
                    else { // edge c points up
                        if (above(P, V[a], V[c])) // V[a] above V[c]
                            b = c; // select [a,c]
                        else // V[a] below V[c]
                            a = c; // select [c,b]
                    }
                } else { // edge a points down
                    if (!dnC) // edge c points up
                        a = c; // select [c,b]
                    else { // edge c points down
                        if (below(P, V[a], V[c])) // V[a] below V[c]
                            b = c; // select [a,c]
                        else // V[a] above V[c]
                            a = c; // select [c,b]
                    }
                }
            }
        }
        // Ltangent_PointPolyC(): binary search for convex polygon left tangent
        //    Input:  P = a 2D point (exterior to the polygon)
        //            n = number of polygon vertices
        //            V = array of vertices for a 2D convex polygon with first
        //                vertex duplicated as last, so V[n-1] = V[0]
        //    Return: index "i" of leftmost tangent point V[i]
        function Ltangent_PointPolyC(P, V) {
            var n = V.length - 1;
            // use binary search for large convex polygons
            var a, b, c; // indices for edge chain endpoints
            var dnA, dnC; // test for down direction of edges a and c
            // leftmost tangent = minimum for the isLeft() ordering
            // test if V[0] is a local minimum
            if (above(P, V[n - 1], V[0]) && !below(P, V[1], V[0]))
                return 0; // V[0] is the minimum tangent point
            for (a = 0, b = n;;) { // start chain = [0,n] with V[n] = V[0]
                if (b - a === 1)
                    if (below(P, V[a], V[b]))
                        return a;
                    else
                        return b;
                c = Math.floor((a + b) / 2); // midpoint of [a,b], and 0<c<n
                dnC = below(P, V[c + 1], V[c]);
                if (above(P, V[c - 1], V[c]) && !dnC)
                    return c; // V[c] is the minimum tangent point
                // no min yet, so continue with the binary search
                // pick one of the two subchains [a,c] or [c,b]
                dnA = below(P, V[a + 1], V[a]);
                if (dnA) { // edge a points down
                    if (!dnC) // edge c points up
                        b = c; // select [a,c]
                    else { // edge c points down
                        if (below(P, V[a], V[c])) // V[a] below V[c]
                            b = c; // select [a,c]
                        else // V[a] above V[c]
                            a = c; // select [c,b]
                    }
                } else { // edge a points up
                    if (dnC) // edge c points down
                        a = c; // select [c,b]
                    else { // edge c points up
                        if (above(P, V[a], V[c])) // V[a] above V[c]
                            b = c; // select [a,c]
                        else // V[a] below V[c]
                            a = c; // select [c,b]
                    }
                }
            }
        }
        // RLtangent_PolyPolyC(): get the RL tangent between two convex polygons
        //    Input:  m = number of vertices in polygon 1
        //            V = array of vertices for convex polygon 1 with V[m]=V[0]
        //            n = number of vertices in polygon 2
        //            W = array of vertices for convex polygon 2 with W[n]=W[0]
        //    Output: *t1 = index of tangent point V[t1] for polygon 1
        //            *t2 = index of tangent point W[t2] for polygon 2
        function tangent_PolyPolyC(V, W, t1, t2, cmp1, cmp2) {
            var ix1, ix2; // search indices for polygons 1 and 2
            // first get the initial vertex on each polygon
            ix1 = t1(W[0], V); // right tangent from W[0] to V
            ix2 = t2(V[ix1], W); // left tangent from V[ix1] to W
            // ping-pong linear search until it stabilizes
            var done = false; // flag when done
            while (!done) {
                done = true; // assume done until...
                while (true) {
                    if (ix1 === V.length - 1)
                        ix1 = 0;
                    if (cmp1(W[ix2], V[ix1], V[ix1 + 1]))
                        break;
                    ++ix1; // get Rtangent from W[ix2] to V
                }
                while (true) {
                    if (ix2 === 0)
                        ix2 = W.length - 1;
                    if (cmp2(V[ix1], W[ix2], W[ix2 - 1]))
                        break;
                    --ix2; // get Ltangent from V[ix1] to W
                    done = false; // not done if had to adjust this
                }
            }
            return {
                t1: ix1,
                t2: ix2
            };
        }
        exports.tangent_PolyPolyC = tangent_PolyPolyC;

        function LRtangent_PolyPolyC(V, W) {
            var rl = RLtangent_PolyPolyC(W, V);
            return {
                t1: rl.t2,
                t2: rl.t1
            };
        }
        exports.LRtangent_PolyPolyC = LRtangent_PolyPolyC;

        function RLtangent_PolyPolyC(V, W) {
            return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Ltangent_PointPolyC, above, below);
        }
        exports.RLtangent_PolyPolyC = RLtangent_PolyPolyC;

        function LLtangent_PolyPolyC(V, W) {
            return tangent_PolyPolyC(V, W, Ltangent_PointPolyC, Ltangent_PointPolyC, below, below);
        }
        exports.LLtangent_PolyPolyC = LLtangent_PolyPolyC;

        function RRtangent_PolyPolyC(V, W) {
            return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Rtangent_PointPolyC, above, above);
        }
        exports.RRtangent_PolyPolyC = RRtangent_PolyPolyC;
        class BiTangent {
            constructor(t1, t2) {
                this.t1 = t1;
                this.t2 = t2;
            }
        }
        exports.BiTangent = BiTangent;
        class BiTangents {}
        exports.BiTangents = BiTangents;
        class TVGPoint extends Point {}
        exports.TVGPoint = TVGPoint;
        class VisibilityVertex {
            constructor(id, polyid, polyvertid, p) {
                this.id = id;
                this.polyid = polyid;
                this.polyvertid = polyvertid;
                this.p = p;
                p.vv = this;
            }
        }
        exports.VisibilityVertex = VisibilityVertex;
        class VisibilityEdge {
            constructor(source, target) {
                this.source = source;
                this.target = target;
            }
            length() {
                var dx = this.source.p.x - this.target.p.x;
                var dy = this.source.p.y - this.target.p.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
        }
        exports.VisibilityEdge = VisibilityEdge;
        class TangentVisibilityGraph {
            constructor(P, g0) {
                this.P = P;
                this.V = [];
                this.E = [];
                if (!g0) {
                    var n = P.length;
                    // For each node...
                    for (var i = 0; i < n; i++) {
                        var p = P[i];
                        // For each node vertex.
                        for (var j = 0; j < p.length; ++j) {
                            var pj = p[j],
                                vv = new VisibilityVertex(this.V.length, i, j, pj);
                            this.V.push(vv);
                            // For the every iteration but the first, generate an
                            // edge from the previous visibility vertex to the
                            // current one.
                            if (j > 0)
                                this.E.push(new VisibilityEdge(p[j - 1].vv, vv));
                        }
                        // Add a visibility edge from the first vertex to the last.
                        if (p.length > 1)
                            this.E.push(new VisibilityEdge(p[0].vv, p[p.length - 1].vv));
                    }
                    for (var i = 0; i < n - 1; i++) {
                        var Pi = P[i];
                        for (var j = i + 1; j < n; j++) {
                            var Pj = P[j],
                                t = tangents(Pi, Pj);
                            for (var q in t) {
                                var c = t[q],
                                    source = Pi[c.t1],
                                    target = Pj[c.t2];
                                this.addEdgeIfVisible(source, target, i, j);
                            }
                        }
                    }
                } else {
                    this.V = g0.V.slice(0);
                    this.E = g0.E.slice(0);
                }
            }
            addEdgeIfVisible(u, v, i1, i2) {
                if (!this.intersectsPolys(new LineSegment(u.x, u.y, v.x, v.y), i1, i2)) {
                    this.E.push(new VisibilityEdge(u.vv, v.vv));
                }
            }
            addPoint(p, i1) {
                var n = this.P.length;
                this.V.push(new VisibilityVertex(this.V.length, n, 0, p));
                for (var i = 0; i < n; ++i) {
                    if (i === i1)
                        continue;
                    var poly = this.P[i],
                        t = tangent_PointPolyC(p, poly);
                    this.addEdgeIfVisible(p, poly[t.ltan], i1, i);
                    this.addEdgeIfVisible(p, poly[t.rtan], i1, i);
                }
                return p.vv;
            }
            intersectsPolys(l, i1, i2) {
                for (var i = 0, n = this.P.length; i < n; ++i) {
                    if (i != i1 && i != i2 && intersects(l, this.P[i]).length > 0) {
                        return true;
                    }
                }
                return false;
            }
        }
        exports.TangentVisibilityGraph = TangentVisibilityGraph;

        function intersects(l, P) {
            var ints = [];
            for (var i = 1, n = P.length; i < n; ++i) {
                var int = rectangle_1.Rectangle.lineIntersection(l.x1, l.y1, l.x2, l.y2, P[i - 1].x, P[i - 1].y, P[i].x, P[i].y);
                if (int)
                    ints.push(int);
            }
            return ints;
        }

        function tangents(V, W) {
            var m = V.length - 1,
                n = W.length - 1;
            var bt = new BiTangents();
            for (var i = 0; i <= m; ++i) {
                for (var j = 0; j <= n; ++j) {
                    var v1 = V[i == 0 ? m : i - 1];
                    var v2 = V[i];
                    var v3 = V[i == m ? 0 : i + 1];
                    var w1 = W[j == 0 ? n : j - 1];
                    var w2 = W[j];
                    var w3 = W[j == n ? 0 : j + 1];
                    var v1v2w2 = isLeft(v1, v2, w2);
                    var v2w1w2 = isLeft(v2, w1, w2);
                    var v2w2w3 = isLeft(v2, w2, w3);
                    var w1w2v2 = isLeft(w1, w2, v2);
                    var w2v1v2 = isLeft(w2, v1, v2);
                    var w2v2v3 = isLeft(w2, v2, v3);
                    if (v1v2w2 >= 0 && v2w1w2 >= 0 && v2w2w3 < 0 &&
                        w1w2v2 >= 0 && w2v1v2 >= 0 && w2v2v3 < 0) {
                        bt.ll = new BiTangent(i, j);
                    } else if (v1v2w2 <= 0 && v2w1w2 <= 0 && v2w2w3 > 0 &&
                        w1w2v2 <= 0 && w2v1v2 <= 0 && w2v2v3 > 0) {
                        bt.rr = new BiTangent(i, j);
                    } else if (v1v2w2 <= 0 && v2w1w2 > 0 && v2w2w3 <= 0 &&
                        w1w2v2 >= 0 && w2v1v2 < 0 && w2v2v3 >= 0) {
                        bt.rl = new BiTangent(i, j);
                    } else if (v1v2w2 >= 0 && v2w1w2 < 0 && v2w2w3 >= 0 &&
                        w1w2v2 <= 0 && w2v1v2 > 0 && w2v2v3 <= 0) {
                        bt.lr = new BiTangent(i, j);
                    }
                }
            }
            return bt;
        }
        exports.tangents = tangents;

        function isPointInsidePoly(p, poly) {
            for (var i = 1, n = poly.length; i < n; ++i)
                if (below(poly[i - 1], poly[i], p))
                    return false;
            return true;
        }

        function isAnyPInQ(p, q) {
            return !p.every(v => !isPointInsidePoly(v, q));
        }

        function polysOverlap(p, q) {
            if (isAnyPInQ(p, q))
                return true;
            if (isAnyPInQ(q, p))
                return true;
            for (var i = 1, n = p.length; i < n; ++i) {
                var v = p[i],
                    u = p[i - 1];
                if (intersects(new LineSegment(u.x, u.y, v.x, v.y), q).length > 0)
                    return true;
            }
            return false;
        }
        exports.polysOverlap = polysOverlap;
    }, {
        "./rectangle": 18
    }],
    10: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        const rectangle_1 = require("./rectangle");
        const vpsc_1 = require("./vpsc");
        const shortestpaths_1 = require("./shortestpaths");
        class NodeWrapper {
            constructor(id, rect, children) {
                this.id = id;
                this.rect = rect;
                this.children = children;
                this.leaf = typeof children === 'undefined' || children.length === 0;
            }
        }
        exports.NodeWrapper = NodeWrapper;
        class Vert {
            constructor(id, x, y, node = null, line = null) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.node = node;
                this.line = line;
            }
        }
        exports.Vert = Vert;
        class LongestCommonSubsequence {
            constructor(s, t) {
                this.s = s;
                this.t = t;
                var mf = LongestCommonSubsequence.findMatch(s, t);
                var tr = t.slice(0).reverse();
                var mr = LongestCommonSubsequence.findMatch(s, tr);
                if (mf.length >= mr.length) {
                    this.length = mf.length;
                    this.si = mf.si;
                    this.ti = mf.ti;
                    this.reversed = false;
                } else {
                    this.length = mr.length;
                    this.si = mr.si;
                    this.ti = t.length - mr.ti - mr.length;
                    this.reversed = true;
                }
            }
            static findMatch(s, t) {
                var m = s.length;
                var n = t.length;
                var match = {
                    length: 0,
                    si: -1,
                    ti: -1
                };
                var l = new Array(m);
                for (var i = 0; i < m; i++) {
                    l[i] = new Array(n);
                    for (var j = 0; j < n; j++)
                        if (s[i] === t[j]) {
                            var v = l[i][j] = (i === 0 || j === 0) ? 1 : l[i - 1][j - 1] + 1;
                            if (v > match.length) {
                                match.length = v;
                                match.si = i - v + 1;
                                match.ti = j - v + 1;
                            };
                        }
                    else
                        l[i][j] = 0;
                }
                return match;
            }
            getSequence() {
                return this.length >= 0 ? this.s.slice(this.si, this.si + this.length) : [];
            }
        }
        exports.LongestCommonSubsequence = LongestCommonSubsequence;
        class GridRouter {
            constructor(originalnodes, accessor, groupPadding = 12) {
                this.originalnodes = originalnodes;
                this.groupPadding = groupPadding;
                this.leaves = null;
                this.nodes = originalnodes.map((v, i) => new NodeWrapper(i, accessor.getBounds(v), accessor.getChildren(v)));
                this.leaves = this.nodes.filter(v => v.leaf);
                this.groups = this.nodes.filter(g => !g.leaf);
                this.cols = this.getGridLines('x');
                this.rows = this.getGridLines('y');
                // create parents for each node or group that is a member of another's children
                this.groups.forEach(v => v.children.forEach(c => this.nodes[c].parent = v));
                // root claims the remaining orphans
                this.root = {
                    children: []
                };
                this.nodes.forEach(v => {
                    if (typeof v.parent === 'undefined') {
                        v.parent = this.root;
                        this.root.children.push(v.id);
                    }
                    // each node will have grid vertices associated with it,
                    // some inside the node and some on the boundary
                    // leaf nodes will have exactly one internal node at the center
                    // and four boundary nodes
                    // groups will have potentially many of each
                    v.ports = [];
                });
                // nodes ordered by their position in the group hierarchy
                this.backToFront = this.nodes.slice(0);
                this.backToFront.sort((x, y) => this.getDepth(x) - this.getDepth(y));
                // compute boundary rectangles for each group
                // has to be done from front to back, i.e. inside groups to outside groups
                // such that each can be made large enough to enclose its interior
                var frontToBackGroups = this.backToFront.slice(0).reverse().filter(g => !g.leaf);
                frontToBackGroups.forEach(v => {
                    var r = rectangle_1.Rectangle.empty();
                    v.children.forEach(c => r = r.union(this.nodes[c].rect));
                    v.rect = r.inflate(this.groupPadding);
                });
                var colMids = this.midPoints(this.cols.map(r => r.pos));
                var rowMids = this.midPoints(this.rows.map(r => r.pos));
                // setup extents of lines
                var rowx = colMids[0],
                    rowX = colMids[colMids.length - 1];
                var coly = rowMids[0],
                    colY = rowMids[rowMids.length - 1];
                // horizontal lines
                var hlines = this.rows.map(r => ({
                        x1: rowx,
                        x2: rowX,
                        y1: r.pos,
                        y2: r.pos
                    }))
                    .concat(rowMids.map(m => ({
                        x1: rowx,
                        x2: rowX,
                        y1: m,
                        y2: m
                    })));
                // vertical lines
                var vlines = this.cols.map(c => ({
                        x1: c.pos,
                        x2: c.pos,
                        y1: coly,
                        y2: colY
                    }))
                    .concat(colMids.map(m => ({
                        x1: m,
                        x2: m,
                        y1: coly,
                        y2: colY
                    })));
                // the full set of lines
                var lines = hlines.concat(vlines);
                // we record the vertices associated with each line
                lines.forEach(l => l.verts = []);
                // the routing graph
                this.verts = [];
                this.edges = [];
                // create vertices at the crossings of horizontal and vertical grid-lines
                hlines.forEach(h => vlines.forEach(v => {
                    var p = new Vert(this.verts.length, v.x1, h.y1);
                    h.verts.push(p);
                    v.verts.push(p);
                    this.verts.push(p);
                    // assign vertices to the nodes immediately under them
                    var i = this.backToFront.length;
                    while (i-- > 0) {
                        var node = this.backToFront[i],
                            r = node.rect;
                        var dx = Math.abs(p.x - r.cx()),
                            dy = Math.abs(p.y - r.cy());
                        if (dx < r.width() / 2 && dy < r.height() / 2) {
                            p.node = node;
                            break;
                        }
                    }
                }));
                lines.forEach((l, li) => {
                    // create vertices at the intersections of nodes and lines
                    this.nodes.forEach((v, i) => {
                        v.rect.lineIntersections(l.x1, l.y1, l.x2, l.y2).forEach((intersect, j) => {
                            //console.log(li+','+i+','+j+':'+intersect.x + ',' + intersect.y);
                            var p = new Vert(this.verts.length, intersect.x, intersect.y, v, l);
                            this.verts.push(p);
                            l.verts.push(p);
                            v.ports.push(p);
                        });
                    });
                    // split lines into edges joining vertices
                    var isHoriz = Math.abs(l.y1 - l.y2) < 0.1;
                    var delta = (a, b) => isHoriz ? b.x - a.x : b.y - a.y;
                    l.verts.sort(delta);
                    for (var i = 1; i < l.verts.length; i++) {
                        var u = l.verts[i - 1],
                            v = l.verts[i];
                        if (u.node && u.node === v.node && u.node.leaf)
                            continue;
                        this.edges.push({
                            source: u.id,
                            target: v.id,
                            length: Math.abs(delta(u, v))
                        });
                    }
                });
            }
            avg(a) {
                return a.reduce((x, y) => x + y) / a.length;
            }
            // in the given axis, find sets of leaves overlapping in that axis
            // center of each GridLine is average of all nodes in column
            getGridLines(axis) {
                var columns = [];
                var ls = this.leaves.slice(0, this.leaves.length);
                while (ls.length > 0) {
                    // find a column of all leaves overlapping in axis with the first leaf
                    let overlapping = ls.filter(v => v.rect['overlap' + axis.toUpperCase()](ls[0].rect));
                    let col = {
                        nodes: overlapping,
                        pos: this.avg(overlapping.map(v => v.rect['c' + axis]()))
                    };
                    columns.push(col);
                    col.nodes.forEach(v => ls.splice(ls.indexOf(v), 1));
                }
                columns.sort((a, b) => a.pos - b.pos);
                return columns;
            }
            // get the depth of the given node in the group hierarchy
            getDepth(v) {
                var depth = 0;
                while (v.parent !== this.root) {
                    depth++;
                    v = v.parent;
                }
                return depth;
            }
            // medial axes between node centres and also boundary lines for the grid
            midPoints(a) {
                var gap = a[1] - a[0];
                var mids = [a[0] - gap / 2];
                for (var i = 1; i < a.length; i++) {
                    mids.push((a[i] + a[i - 1]) / 2);
                }
                mids.push(a[a.length - 1] + gap / 2);
                return mids;
            }
            // find path from v to root including both v and root
            findLineage(v) {
                var lineage = [v];
                do {
                    v = v.parent;
                    lineage.push(v);
                } while (v !== this.root);
                return lineage.reverse();
            }
            // find path connecting a and b through their lowest common ancestor
            findAncestorPathBetween(a, b) {
                var aa = this.findLineage(a),
                    ba = this.findLineage(b),
                    i = 0;
                while (aa[i] === ba[i])
                    i++;
                // i-1 to include common ancestor only once (as first element)
                return {
                    commonAncestor: aa[i - 1],
                    lineages: aa.slice(i).concat(ba.slice(i))
                };
            }
            // when finding a path between two nodes a and b, siblings of a and b on the
            // paths from a and b to their least common ancestor are obstacles
            siblingObstacles(a, b) {
                var path = this.findAncestorPathBetween(a, b);
                var lineageLookup = {};
                path.lineages.forEach(v => lineageLookup[v.id] = {});
                var obstacles = path.commonAncestor.children.filter(v => !(v in lineageLookup));
                path.lineages
                    .filter(v => v.parent !== path.commonAncestor)
                    .forEach(v => obstacles = obstacles.concat(v.parent.children.filter(c => c !== v.id)));
                return obstacles.map(v => this.nodes[v]);
            }
            // for the given routes, extract all the segments orthogonal to the axis x
            // and return all them grouped by x position
            static getSegmentSets(routes, x, y) {
                // vsegments is a list of vertical segments sorted by x position
                var vsegments = [];
                for (var ei = 0; ei < routes.length; ei++) {
                    var route = routes[ei];
                    for (var si = 0; si < route.length; si++) {
                        var s = route[si];
                        s.edgeid = ei;
                        s.i = si;
                        var sdx = s[1][x] - s[0][x];
                        if (Math.abs(sdx) < 0.1) {
                            vsegments.push(s);
                        }
                    }
                }
                vsegments.sort((a, b) => a[0][x] - b[0][x]);
                // vsegmentsets is a set of sets of segments grouped by x position
                var vsegmentsets = [];
                var segmentset = null;
                for (var i = 0; i < vsegments.length; i++) {
                    var s = vsegments[i];
                    if (!segmentset || Math.abs(s[0][x] - segmentset.pos) > 0.1) {
                        segmentset = {
                            pos: s[0][x],
                            segments: []
                        };
                        vsegmentsets.push(segmentset);
                    }
                    segmentset.segments.push(s);
                }
                return vsegmentsets;
            }
            // for all segments in this bundle create a vpsc problem such that
            // each segment's x position is a variable and separation constraints
            // are given by the partial order over the edges to which the segments belong
            // for each pair s1,s2 of segments in the open set:
            //   e1 = edge of s1, e2 = edge of s2
            //   if leftOf(e1,e2) create constraint s1.x + gap <= s2.x
            //   else if leftOf(e2,e1) create cons. s2.x + gap <= s1.x
            static nudgeSegs(x, y, routes, segments, leftOf, gap) {
                var n = segments.length;
                if (n <= 1)
                    return;
                var vs = segments.map(s => new vpsc_1.Variable(s[0][x]));
                var cs = [];
                for (var i = 0; i < n; i++) {
                    for (var j = 0; j < n; j++) {
                        if (i === j)
                            continue;
                        var s1 = segments[i],
                            s2 = segments[j],
                            e1 = s1.edgeid,
                            e2 = s2.edgeid,
                            lind = -1,
                            rind = -1;
                        // in page coordinates (not cartesian) the notion of 'leftof' is flipped in the horizontal axis from the vertical axis
                        // that is, when nudging vertical segments, if they increase in the y(conj) direction the segment belonging to the
                        // 'left' edge actually needs to be nudged to the right
                        // when nudging horizontal segments, if the segments increase in the x direction
                        // then the 'left' segment needs to go higher, i.e. to have y pos less than that of the right
                        if (x == 'x') {
                            if (leftOf(e1, e2)) {
                                //console.log('s1: ' + s1[0][x] + ',' + s1[0][y] + '-' + s1[1][x] + ',' + s1[1][y]);
                                if (s1[0][y] < s1[1][y]) {
                                    lind = j, rind = i;
                                } else {
                                    lind = i, rind = j;
                                }
                            }
                        } else {
                            if (leftOf(e1, e2)) {
                                if (s1[0][y] < s1[1][y]) {
                                    lind = i, rind = j;
                                } else {
                                    lind = j, rind = i;
                                }
                            }
                        }
                        if (lind >= 0) {
                            //console.log(x+' constraint: ' + lind + '<' + rind);
                            cs.push(new vpsc_1.Constraint(vs[lind], vs[rind], gap));
                        }
                    }
                }
                var solver = new vpsc_1.Solver(vs, cs);
                solver.solve();
                vs.forEach((v, i) => {
                    var s = segments[i];
                    var pos = v.position();
                    s[0][x] = s[1][x] = pos;
                    var route = routes[s.edgeid];
                    if (s.i > 0)
                        route[s.i - 1][1][x] = pos;
                    if (s.i < route.length - 1)
                        route[s.i + 1][0][x] = pos;
                });
            }
            static nudgeSegments(routes, x, y, leftOf, gap) {
                var vsegmentsets = GridRouter.getSegmentSets(routes, x, y);
                // scan the grouped (by x) segment sets to find co-linear bundles
                for (var i = 0; i < vsegmentsets.length; i++) {
                    var ss = vsegmentsets[i];
                    var events = [];
                    for (var j = 0; j < ss.segments.length; j++) {
                        var s = ss.segments[j];
                        events.push({
                            type: 0,
                            s: s,
                            pos: Math.min(s[0][y], s[1][y])
                        });
                        events.push({
                            type: 1,
                            s: s,
                            pos: Math.max(s[0][y], s[1][y])
                        });
                    }
                    events.sort((a, b) => a.pos - b.pos + a.type - b.type);
                    var open = [];
                    var openCount = 0;
                    events.forEach(e => {
                        if (e.type === 0) {
                            open.push(e.s);
                            openCount++;
                        } else {
                            openCount--;
                        }
                        if (openCount == 0) {
                            GridRouter.nudgeSegs(x, y, routes, open, leftOf, gap);
                            open = [];
                        }
                    });
                }
            }
            // obtain routes for the specified edges, nicely nudged apart
            // warning: edge paths may be reversed such that common paths are ordered consistently within bundles!
            // @param edges list of edges
            // @param nudgeGap how much to space parallel edge segements
            // @param source function to retrieve the index of the source node for a given edge
            // @param target function to retrieve the index of the target node for a given edge
            // @returns an array giving, for each edge, an array of segments, each segment a pair of points in an array
            routeEdges(edges, nudgeGap, source, target) {
                var routePaths = edges.map(e => this.route(source(e), target(e)));
                var order = GridRouter.orderEdges(routePaths);
                var routes = routePaths.map(function(e) {
                    return GridRouter.makeSegments(e);
                });
                GridRouter.nudgeSegments(routes, 'x', 'y', order, nudgeGap);
                GridRouter.nudgeSegments(routes, 'y', 'x', order, nudgeGap);
                GridRouter.unreverseEdges(routes, routePaths);
                return routes;
            }
            // path may have been reversed by the subsequence processing in orderEdges
            // so now we need to restore the original order
            static unreverseEdges(routes, routePaths) {
                routes.forEach((segments, i) => {
                    var path = routePaths[i];
                    if (path.reversed) {
                        segments.reverse(); // reverse order of segments
                        segments.forEach(function(segment) {
                            segment.reverse(); // reverse each segment
                        });
                    }
                });
            }
            static angleBetween2Lines(line1, line2) {
                var angle1 = Math.atan2(line1[0].y - line1[1].y, line1[0].x - line1[1].x);
                var angle2 = Math.atan2(line2[0].y - line2[1].y, line2[0].x - line2[1].x);
                var diff = angle1 - angle2;
                if (diff > Math.PI || diff < -Math.PI) {
                    diff = angle2 - angle1;
                }
                return diff;
            }
            // does the path a-b-c describe a left turn?
            static isLeft(a, b, c) {
                return ((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) <= 0;
            }
            // for the given list of ordered pairs, returns a function that (efficiently) looks-up a specific pair to
            // see if it exists in the list
            static getOrder(pairs) {
                var outgoing = {};
                for (var i = 0; i < pairs.length; i++) {
                    var p = pairs[i];
                    if (typeof outgoing[p.l] === 'undefined')
                        outgoing[p.l] = {};
                    outgoing[p.l][p.r] = true;
                }
                return (l, r) => typeof outgoing[l] !== 'undefined' && outgoing[l][r];
            }
            // returns an ordering (a lookup function) that determines the correct order to nudge the
            // edge paths apart to minimize crossings
            static orderEdges(edges) {
                var edgeOrder = [];
                for (var i = 0; i < edges.length - 1; i++) {
                    for (var j = i + 1; j < edges.length; j++) {
                        var e = edges[i],
                            f = edges[j],
                            lcs = new LongestCommonSubsequence(e, f);
                        var u, vi, vj;
                        if (lcs.length === 0)
                            continue; // no common subpath
                        if (lcs.reversed) {
                            // if we found a common subpath but one of the edges runs the wrong way,
                            // then reverse f.
                            f.reverse();
                            f.reversed = true;
                            lcs = new LongestCommonSubsequence(e, f);
                        }
                        if ((lcs.si <= 0 || lcs.ti <= 0) &&
                            (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length)) {
                            // the paths do not diverge, so make an arbitrary ordering decision
                            edgeOrder.push({
                                l: i,
                                r: j
                            });
                            continue;
                        }
                        if (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length) {
                            // if the common subsequence of the
                            // two edges being considered goes all the way to the
                            // end of one (or both) of the lines then we have to
                            // base our ordering decision on the other end of the
                            // common subsequence
                            u = e[lcs.si + 1];
                            vj = e[lcs.si - 1];
                            vi = f[lcs.ti - 1];
                        } else {
                            u = e[lcs.si + lcs.length - 2];
                            vi = e[lcs.si + lcs.length];
                            vj = f[lcs.ti + lcs.length];
                        }
                        if (GridRouter.isLeft(u, vi, vj)) {
                            edgeOrder.push({
                                l: j,
                                r: i
                            });
                        } else {
                            edgeOrder.push({
                                l: i,
                                r: j
                            });
                        }
                    }
                }
                //edgeOrder.forEach(function (e) { console.log('l:' + e.l + ',r:' + e.r) });
                return GridRouter.getOrder(edgeOrder);
            }
            // for an orthogonal path described by a sequence of points, create a list of segments
            // if consecutive segments would make a straight line they are merged into a single segment
            // segments are over cloned points, not the original vertices
            static makeSegments(path) {
                function copyPoint(p) {
                    return {
                        x: p.x,
                        y: p.y
                    };
                }
                var isStraight = (a, b, c) => Math.abs((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) < 0.001;
                var segments = [];
                var a = copyPoint(path[0]);
                for (var i = 1; i < path.length; i++) {
                    var b = copyPoint(path[i]),
                        c = i < path.length - 1 ? path[i + 1] : null;
                    if (!c || !isStraight(a, b, c)) {
                        segments.push([a, b]);
                        a = b;
                    }
                }
                return segments;
            }
            // find a route between node s and node t
            // returns an array of indices to verts
            route(s, t) {
                var source = this.nodes[s],
                    target = this.nodes[t];
                this.obstacles = this.siblingObstacles(source, target);
                var obstacleLookup = {};
                this.obstacles.forEach(o => obstacleLookup[o.id] = o);
                this.passableEdges = this.edges.filter(e => {
                    var u = this.verts[e.source],
                        v = this.verts[e.target];
                    return !(u.node && u.node.id in obstacleLookup ||
                        v.node && v.node.id in obstacleLookup);
                });
                // add dummy segments linking ports inside source and target
                for (var i = 1; i < source.ports.length; i++) {
                    var u = source.ports[0].id;
                    var v = source.ports[i].id;
                    this.passableEdges.push({
                        source: u,
                        target: v,
                        length: 0
                    });
                }
                for (var i = 1; i < target.ports.length; i++) {
                    var u = target.ports[0].id;
                    var v = target.ports[i].id;
                    this.passableEdges.push({
                        source: u,
                        target: v,
                        length: 0
                    });
                }
                var getSource = e => e.source,
                    getTarget = e => e.target,
                    getLength = e => e.length;
                var shortestPathCalculator = new shortestpaths_1.Calculator(this.verts.length, this.passableEdges, getSource, getTarget, getLength);
                var bendPenalty = (u, v, w) => {
                    var a = this.verts[u],
                        b = this.verts[v],
                        c = this.verts[w];
                    var dx = Math.abs(c.x - a.x),
                        dy = Math.abs(c.y - a.y);
                    // don't count bends from internal node edges
                    if (a.node === source && a.node === b.node || b.node === target && b.node === c.node)
                        return 0;
                    return dx > 1 && dy > 1 ? 1000 : 0;
                };
                // get shortest path
                var shortestPath = shortestPathCalculator.PathFromNodeToNodeWithPrevCost(source.ports[0].id, target.ports[0].id, bendPenalty);
                // shortest path is reversed and does not include the target port
                var pathPoints = shortestPath.reverse().map(vi => this.verts[vi]);
                pathPoints.push(this.nodes[target.id].ports[0]);
                // filter out any extra end points that are inside the source or target (i.e. the dummy segments above)
                return pathPoints.filter((v, i) => !(i < pathPoints.length - 1 && pathPoints[i + 1].node === source && v.node === source ||
                    i > 0 && v.node === target && pathPoints[i - 1].node === target));
            }
            static getRoutePath(route, cornerradius, arrowwidth, arrowheight) {
                var result = {
                    routepath: 'M ' + route[0][0].x + ' ' + route[0][0].y + ' ',
                    arrowpath: ''
                };
                if (route.length > 1) {
                    for (var i = 0; i < route.length; i++) {
                        var li = route[i];
                        var x = li[1].x,
                            y = li[1].y;
                        var dx = x - li[0].x;
                        var dy = y - li[0].y;
                        if (i < route.length - 1) {
                            if (Math.abs(dx) > 0) {
                                x -= dx / Math.abs(dx) * cornerradius;
                            } else {
                                y -= dy / Math.abs(dy) * cornerradius;
                            }
                            result.routepath += 'L ' + x + ' ' + y + ' ';
                            var l = route[i + 1];
                            var x0 = l[0].x,
                                y0 = l[0].y;
                            var x1 = l[1].x;
                            var y1 = l[1].y;
                            dx = x1 - x0;
                            dy = y1 - y0;
                            var angle = GridRouter.angleBetween2Lines(li, l) < 0 ? 1 : 0;
                            //console.log(cola.GridRouter.angleBetween2Lines(li, l))
                            var x2, y2;
                            if (Math.abs(dx) > 0) {
                                x2 = x0 + dx / Math.abs(dx) * cornerradius;
                                y2 = y0;
                            } else {
                                x2 = x0;
                                y2 = y0 + dy / Math.abs(dy) * cornerradius;
                            }
                            var cx = Math.abs(x2 - x);
                            var cy = Math.abs(y2 - y);
                            result.routepath += 'A ' + cx + ' ' + cy + ' 0 0 ' + angle + ' ' + x2 + ' ' + y2 + ' ';
                        } else {
                            var arrowtip = [x, y];
                            var arrowcorner1, arrowcorner2;
                            if (Math.abs(dx) > 0) {
                                x -= dx / Math.abs(dx) * arrowheight;
                                arrowcorner1 = [x, y + arrowwidth];
                                arrowcorner2 = [x, y - arrowwidth];
                            } else {
                                y -= dy / Math.abs(dy) * arrowheight;
                                arrowcorner1 = [x + arrowwidth, y];
                                arrowcorner2 = [x - arrowwidth, y];
                            }
                            result.routepath += 'L ' + x + ' ' + y + ' ';
                            if (arrowheight > 0) {
                                result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1] +
                                    ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];
                            }
                        }
                    }
                } else {
                    var li = route[0];
                    var x = li[1].x,
                        y = li[1].y;
                    var dx = x - li[0].x;
                    var dy = y - li[0].y;
                    var arrowtip = [x, y];
                    var arrowcorner1, arrowcorner2;
                    if (Math.abs(dx) > 0) {
                        x -= dx / Math.abs(dx) * arrowheight;
                        arrowcorner1 = [x, y + arrowwidth];
                        arrowcorner2 = [x, y - arrowwidth];
                    } else {
                        y -= dy / Math.abs(dy) * arrowheight;
                        arrowcorner1 = [x + arrowwidth, y];
                        arrowcorner2 = [x - arrowwidth, y];
                    }
                    result.routepath += 'L ' + x + ' ' + y + ' ';
                    if (arrowheight > 0) {
                        result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1] +
                            ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];
                    }
                }
                return result;
            }
        }
        exports.GridRouter = GridRouter;
    }, {
        "./rectangle": 18,
        "./shortestpaths": 19,
        "./vpsc": 20
    }],
    11: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var packingOptions = {
            PADDING: 10,
            GOLDEN_SECTION: (1 + Math.sqrt(5)) / 2,
            FLOAT_EPSILON: 0.0001,
            MAX_INERATIONS: 100
        };
        // assign x, y to nodes while using box packing algorithm for disconnected graphs
        function applyPacking(graphs, w, h, node_size, desired_ratio = 1, centerGraph = true) {
            var init_x = 0,
                init_y = 0,
                svg_width = w,
                svg_height = h,
                desired_ratio = typeof desired_ratio !== 'undefined' ? desired_ratio : 1,
                node_size = typeof node_size !== 'undefined' ? node_size : 0,
                real_width = 0,
                real_height = 0,
                min_width = 0,
                global_bottom = 0,
                line = [];
            if (graphs.length == 0)
                return;
            /// that would take care of single nodes problem
            // graphs.forEach(function (g) {
            //     if (g.array.length == 1) {
            //         g.array[0].x = 0;
            //         g.array[0].y = 0;
            //     }
            // });
            calculate_bb(graphs);
            apply(graphs, desired_ratio);
            if (centerGraph) {
                put_nodes_to_right_positions(graphs);
            }
            // get bounding boxes for all separate graphs
            function calculate_bb(graphs) {
                graphs.forEach(function(g) {
                    calculate_single_bb(g);
                });

                function calculate_single_bb(graph) {
                    var min_x = Number.MAX_VALUE,
                        min_y = Number.MAX_VALUE,
                        max_x = 0,
                        max_y = 0;
                    graph.array.forEach(function(v) {
                        var w = typeof v.width !== 'undefined' ? v.width : node_size;
                        var h = typeof v.height !== 'undefined' ? v.height : node_size;
                        w /= 2;
                        h /= 2;
                        max_x = Math.max(v.x + w, max_x);
                        min_x = Math.min(v.x - w, min_x);
                        max_y = Math.max(v.y + h, max_y);
                        min_y = Math.min(v.y - h, min_y);
                    });
                    graph.width = max_x - min_x;
                    graph.height = max_y - min_y;
                }
            }
            //function plot(data, left, right, opt_x, opt_y) {
            //    // plot the cost function
            //    var plot_svg = d3.select("body").append("svg")
            //        .attr("width", function () { return 2 * (right - left); })
            //        .attr("height", 200);
            //    var x = d3.time.scale().range([0, 2 * (right - left)]);
            //    var xAxis = d3.svg.axis().scale(x).orient("bottom");
            //    plot_svg.append("g").attr("class", "x axis")
            //        .attr("transform", "translate(0, 199)")
            //        .call(xAxis);
            //    var lastX = 0;
            //    var lastY = 0;
            //    var value = 0;
            //    for (var r = left; r < right; r += 1) {
            //        value = step(data, r);
            //        // value = 1;
            //        plot_svg.append("line").attr("x1", 2 * (lastX - left))
            //            .attr("y1", 200 - 30 * lastY)
            //            .attr("x2", 2 * r - 2 * left)
            //            .attr("y2", 200 - 30 * value)
            //            .style("stroke", "rgb(6,120,155)");
            //        lastX = r;
            //        lastY = value;
            //    }
            //    plot_svg.append("circle").attr("cx", 2 * opt_x - 2 * left).attr("cy", 200 - 30 * opt_y)
            //        .attr("r", 5).style('fill', "rgba(0,0,0,0.5)");
            //}
            // actual assigning of position to nodes
            function put_nodes_to_right_positions(graphs) {
                graphs.forEach(function(g) {
                    // calculate current graph center:
                    var center = {
                        x: 0,
                        y: 0
                    };
                    g.array.forEach(function(node) {
                        center.x += node.x;
                        center.y += node.y;
                    });
                    center.x /= g.array.length;
                    center.y /= g.array.length;
                    // calculate current top left corner:
                    var corner = {
                        x: center.x - g.width / 2,
                        y: center.y - g.height / 2
                    };
                    var offset = {
                        x: g.x - corner.x + svg_width / 2 - real_width / 2,
                        y: g.y - corner.y + svg_height / 2 - real_height / 2
                    };
                    // put nodes:
                    g.array.forEach(function(node) {
                        node.x += offset.x;
                        node.y += offset.y;
                    });
                });
            }
            // starts box packing algorithm
            // desired ratio is 1 by default
            function apply(data, desired_ratio) {
                var curr_best_f = Number.POSITIVE_INFINITY;
                var curr_best = 0;
                data.sort(function(a, b) {
                    return b.height - a.height;
                });
                min_width = data.reduce(function(a, b) {
                    return a.width < b.width ? a.width : b.width;
                });
                var left = x1 = min_width;
                var right = x2 = get_entire_width(data);
                var iterationCounter = 0;
                var f_x1 = Number.MAX_VALUE;
                var f_x2 = Number.MAX_VALUE;
                var flag = -1; // determines which among f_x1 and f_x2 to recompute
                var dx = Number.MAX_VALUE;
                var df = Number.MAX_VALUE;
                while ((dx > min_width) || df > packingOptions.FLOAT_EPSILON) {
                    if (flag != 1) {
                        var x1 = right - (right - left) / packingOptions.GOLDEN_SECTION;
                        var f_x1 = step(data, x1);
                    }
                    if (flag != 0) {
                        var x2 = left + (right - left) / packingOptions.GOLDEN_SECTION;
                        var f_x2 = step(data, x2);
                    }
                    dx = Math.abs(x1 - x2);
                    df = Math.abs(f_x1 - f_x2);
                    if (f_x1 < curr_best_f) {
                        curr_best_f = f_x1;
                        curr_best = x1;
                    }
                    if (f_x2 < curr_best_f) {
                        curr_best_f = f_x2;
                        curr_best = x2;
                    }
                    if (f_x1 > f_x2) {
                        left = x1;
                        x1 = x2;
                        f_x1 = f_x2;
                        flag = 1;
                    } else {
                        right = x2;
                        x2 = x1;
                        f_x2 = f_x1;
                        flag = 0;
                    }
                    if (iterationCounter++ > 100) {
                        break;
                    }
                }
                // plot(data, min_width, get_entire_width(data), curr_best, curr_best_f);
                step(data, curr_best);
            }
            // one iteration of the optimization method
            // (gives a proper, but not necessarily optimal packing)
            function step(data, max_width) {
                line = [];
                real_width = 0;
                real_height = 0;
                global_bottom = init_y;
                for (var i = 0; i < data.length; i++) {
                    var o = data[i];
                    put_rect(o, max_width);
                }
                return Math.abs(get_real_ratio() - desired_ratio);
            }
            // looking for a position to one box
            function put_rect(rect, max_width) {
                var parent = undefined;
                for (var i = 0; i < line.length; i++) {
                    if ((line[i].space_left >= rect.height) && (line[i].x + line[i].width + rect.width + packingOptions.PADDING - max_width) <= packingOptions.FLOAT_EPSILON) {
                        parent = line[i];
                        break;
                    }
                }
                line.push(rect);
                if (parent !== undefined) {
                    rect.x = parent.x + parent.width + packingOptions.PADDING;
                    rect.y = parent.bottom;
                    rect.space_left = rect.height;
                    rect.bottom = rect.y;
                    parent.space_left -= rect.height + packingOptions.PADDING;
                    parent.bottom += rect.height + packingOptions.PADDING;
                } else {
                    rect.y = global_bottom;
                    global_bottom += rect.height + packingOptions.PADDING;
                    rect.x = init_x;
                    rect.bottom = rect.y;
                    rect.space_left = rect.height;
                }
                if (rect.y + rect.height - real_height > -packingOptions.FLOAT_EPSILON)
                    real_height = rect.y + rect.height - init_y;
                if (rect.x + rect.width - real_width > -packingOptions.FLOAT_EPSILON)
                    real_width = rect.x + rect.width - init_x;
            };

            function get_entire_width(data) {
                var width = 0;
                data.forEach(function(d) {
                    return width += d.width + packingOptions.PADDING;
                });
                return width;
            }

            function get_real_ratio() {
                return (real_width / real_height);
            }
        }
        exports.applyPacking = applyPacking;
        /**
         * connected components of graph
         * returns an array of {}
         */
        function separateGraphs(nodes, links) {
            var marks = {};
            var ways = {};
            var graphs = [];
            var clusters = 0;
            for (var i = 0; i < links.length; i++) {
                var link = links[i];
                var n1 = link.source;
                var n2 = link.target;
                if (ways[n1.index])
                    ways[n1.index].push(n2);
                else
                    ways[n1.index] = [n2];
                if (ways[n2.index])
                    ways[n2.index].push(n1);
                else
                    ways[n2.index] = [n1];
            }
            for (var i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                if (marks[node.index])
                    continue;
                explore_node(node, true);
            }

            function explore_node(n, is_new) {
                if (marks[n.index] !== undefined)
                    return;
                if (is_new) {
                    clusters++;
                    graphs.push({
                        array: []
                    });
                }
                marks[n.index] = clusters;
                graphs[clusters - 1].array.push(n);
                var adjacent = ways[n.index];
                if (!adjacent)
                    return;
                for (var j = 0; j < adjacent.length; j++) {
                    explore_node(adjacent[j], false);
                }
            }
            return graphs;
        }
        exports.separateGraphs = separateGraphs;
    }, {}],
    12: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        const powergraph = require("./powergraph");
        const linklengths_1 = require("./linklengths");
        const descent_1 = require("./descent");
        const rectangle_1 = require("./rectangle");
        const shortestpaths_1 = require("./shortestpaths");
        const geom_1 = require("./geom");
        const handledisconnected_1 = require("./handledisconnected");
        /**
         * The layout process fires three events:
         *  - start: layout iterations started
         *  - tick: fired once per iteration, listen to this to animate
         *  - end: layout converged, you might like to zoom-to-fit or something at notification of this event
         */
        var EventType;
        (function(EventType) {
            EventType[EventType["start"] = 0] = "start";
            EventType[EventType["tick"] = 1] = "tick";
            EventType[EventType["end"] = 2] = "end";
        })(EventType = exports.EventType || (exports.EventType = {}));;

        function isGroup(g) {
            return typeof g.leaves !== 'undefined' || typeof g.groups !== 'undefined';
        }
        /**
         * Main interface to cola layout.
         * @class Layout
         */
        class Layout {
            constructor() {
                this._canvasSize = [1, 1];
                this._linkDistance = 20;
                this._defaultNodeSize = 10;
                this._linkLengthCalculator = null;
                this._linkType = null;
                this._avoidOverlaps = false;
                this._handleDisconnected = true;
                this._running = false;
                this._nodes = [];
                this._groups = [];
                this._rootGroup = null;
                this._links = [];
                this._constraints = [];
                this._distanceMatrix = null;
                this._descent = null;
                this._directedLinkConstraints = null;
                this._threshold = 0.01;
                this._visibilityGraph = null;
                this._groupCompactness = 1e-6;
                // sub-class and override this property to replace with a more sophisticated eventing mechanism
                this.event = null;
                this.linkAccessor = {
                    getSourceIndex: Layout.getSourceIndex,
                    getTargetIndex: Layout.getTargetIndex,
                    setLength: Layout.setLinkLength,
                    getType: l => typeof this._linkType === "function" ? this._linkType(l) : 0
                };
            }
            // subscribe a listener to an event
            // sub-class and override this method to replace with a more sophisticated eventing mechanism
            on(e, listener) {
                // override me!
                if (!this.event)
                    this.event = {};
                if (typeof e === 'string') {
                    this.event[EventType[e]] = listener;
                } else {
                    this.event[e] = listener;
                }
                return this;
            }
            // a function that is notified of events like "tick"
            // sub-classes can override this method to replace with a more sophisticated eventing mechanism
            trigger(e) {
                if (this.event && typeof this.event[e.type] !== 'undefined') {
                    this.event[e.type](e);
                }
            }
            // a function that kicks off the iteration tick loop
            // it calls tick() repeatedly until tick returns true (is converged)
            // subclass and override it with something fancier (e.g. dispatch tick on a timer)
            kick() {
                while (!this.tick())
                ;
            }
            /**
             * iterate the layout.  Returns true when layout converged.
             */
            tick() {
                if (this._alpha < this._threshold) {
                    this._running = false;
                    this.trigger({
                        type: EventType.end,
                        alpha: this._alpha = 0,
                        stress: this._lastStress
                    });
                    return true;
                }
                const n = this._nodes.length,
                    m = this._links.length;
                let o, i;
                this._descent.locks.clear();
                for (i = 0; i < n; ++i) {
                    o = this._nodes[i];
                    if (o.fixed) {
                        if (typeof o.px === 'undefined' || typeof o.py === 'undefined') {
                            o.px = o.x;
                            o.py = o.y;
                        }
                        var p = [o.px, o.py];
                        this._descent.locks.add(i, p);
                    }
                }
                let s1 = this._descent.rungeKutta();
                //var s1 = descent.reduceStress();
                if (s1 === 0) {
                    this._alpha = 0;
                } else if (typeof this._lastStress !== 'undefined') {
                    this._alpha = s1; //Math.abs(Math.abs(this._lastStress / s1) - 1);
                }
                this._lastStress = s1;
                this.updateNodePositions();
                this.trigger({
                    type: EventType.tick,
                    alpha: this._alpha,
                    stress: this._lastStress
                });
                return false;
            }
            // copy positions out of descent instance into each of the nodes' center coords
            updateNodePositions() {
                const x = this._descent.x[0],
                    y = this._descent.x[1];
                let o, i = this._nodes.length;
                while (i--) {
                    o = this._nodes[i];
                    o.x = x[i];
                    o.y = y[i];
                }
            }
            nodes(v) {
                if (!v) {
                    if (this._nodes.length === 0 && this._links.length > 0) {
                        // if we have links but no nodes, create the nodes array now with empty objects for the links to point at.
                        // in this case the links are expected to be numeric indices for nodes in the range 0..n-1 where n is the number of nodes
                        var n = 0;
                        this._links.forEach(function(l) {
                            n = Math.max(n, l.source, l.target);
                        });
                        this._nodes = new Array(++n);
                        for (var i = 0; i < n; ++i) {
                            this._nodes[i] = {};
                        }
                    }
                    return this._nodes;
                }
                this._nodes = v;
                return this;
            }
            groups(x) {
                if (!x)
                    return this._groups;
                this._groups = x;
                this._rootGroup = {};
                this._groups.forEach(g => {
                    if (typeof g.padding === "undefined")
                        g.padding = 1;
                    if (typeof g.leaves !== "undefined") {
                        g.leaves.forEach((v, i) => {
                            if (typeof v === 'number')
                                (g.leaves[i] = this._nodes[v]).parent = g;
                        });
                    }
                    if (typeof g.groups !== "undefined") {
                        g.groups.forEach((gi, i) => {
                            if (typeof gi === 'number')
                                (g.groups[i] = this._groups[gi]).parent = g;
                        });
                    }
                });
                this._rootGroup.leaves = this._nodes.filter(v => typeof v.parent === 'undefined');
                this._rootGroup.groups = this._groups.filter(g => typeof g.parent === 'undefined');
                return this;
            }
            powerGraphGroups(f) {
                var g = powergraph.getGroups(this._nodes, this._links, this.linkAccessor, this._rootGroup);
                this.groups(g.groups);
                f(g);
                return this;
            }
            avoidOverlaps(v) {
                if (!arguments.length)
                    return this._avoidOverlaps;
                this._avoidOverlaps = v;
                return this;
            }
            handleDisconnected(v) {
                if (!arguments.length)
                    return this._handleDisconnected;
                this._handleDisconnected = v;
                return this;
            }
            /**
             * causes constraints to be generated such that directed graphs are laid out either from left-to-right or top-to-bottom.
             * a separation constraint is generated in the selected axis for each edge that is not involved in a cycle (part of a strongly connected component)
             * @param axis {string} 'x' for left-to-right, 'y' for top-to-bottom
             * @param minSeparation {number|link=>number} either a number specifying a minimum spacing required across all links or a function to return the minimum spacing for each link
             */
            flowLayout(axis, minSeparation) {
                if (!arguments.length)
                    axis = 'y';
                this._directedLinkConstraints = {
                    axis: axis,
                    getMinSeparation: typeof minSeparation === 'number' ? function() {
                        return minSeparation;
                    } : minSeparation
                };
                return this;
            }
            links(x) {
                if (!arguments.length)
                    return this._links;
                this._links = x;
                return this;
            }
            constraints(c) {
                if (!arguments.length)
                    return this._constraints;
                this._constraints = c;
                return this;
            }
            distanceMatrix(d) {
                if (!arguments.length)
                    return this._distanceMatrix;
                this._distanceMatrix = d;
                return this;
            }
            size(x) {
                if (!x)
                    return this._canvasSize;
                this._canvasSize = x;
                return this;
            }
            defaultNodeSize(x) {
                if (!x)
                    return this._defaultNodeSize;
                this._defaultNodeSize = x;
                return this;
            }
            groupCompactness(x) {
                if (!x)
                    return this._groupCompactness;
                this._groupCompactness = x;
                return this;
            }
            linkDistance(x) {
                if (!x) {
                    return this._linkDistance;
                }
                this._linkDistance = typeof x === "function" ? x : +x;
                this._linkLengthCalculator = null;
                return this;
            }
            linkType(f) {
                this._linkType = f;
                return this;
            }
            convergenceThreshold(x) {
                if (!x)
                    return this._threshold;
                this._threshold = typeof x === "function" ? x : +x;
                return this;
            }
            alpha(x) {
                if (!arguments.length)
                    return this._alpha;
                else {
                    x = +x;
                    if (this._alpha) { // if we're already running
                        if (x > 0)
                            this._alpha = x; // we might keep it hot
                        else
                            this._alpha = 0; // or, next tick will dispatch "end"
                    } else if (x > 0) { // otherwise, fire it up!
                        if (!this._running) {
                            this._running = true;
                            this.trigger({
                                type: EventType.start,
                                alpha: this._alpha = x
                            });
                            this.kick();
                        }
                    }
                    return this;
                }
            }
            getLinkLength(link) {
                return typeof this._linkDistance === "function" ? +(this._linkDistance(link)) : this._linkDistance;
            }
            static setLinkLength(link, length) {
                link.length = length;
            }
            getLinkType(link) {
                return typeof this._linkType === "function" ? this._linkType(link) : 0;
            }
            /**
             * compute an ideal length for each link based on the graph structure around that link.
             * you can use this (for example) to create extra space around hub-nodes in dense graphs.
             * In particular this calculation is based on the "symmetric difference" in the neighbour sets of the source and target:
             * i.e. if neighbours of source is a and neighbours of target are b then calculation is: sqrt(|a union b| - |a intersection b|)
             * Actual computation based on inspection of link structure occurs in start(), so links themselves
             * don't have to have been assigned before invoking this function.
             * @param {number} [idealLength] the base length for an edge when its source and start have no other common neighbours (e.g. 40)
             * @param {number} [w] a multiplier for the effect of the length adjustment (e.g. 0.7)
             */
            symmetricDiffLinkLengths(idealLength, w = 1) {
                this.linkDistance(l => idealLength * l.length);
                this._linkLengthCalculator = () => linklengths_1.symmetricDiffLinkLengths(this._links, this.linkAccessor, w);
                return this;
            }
            /**
             * compute an ideal length for each link based on the graph structure around that link.
             * you can use this (for example) to create extra space around hub-nodes in dense graphs.
             * In particular this calculation is based on the "symmetric difference" in the neighbour sets of the source and target:
             * i.e. if neighbours of source is a and neighbours of target are b then calculation is: |a intersection b|/|a union b|
             * Actual computation based on inspection of link structure occurs in start(), so links themselves
             * don't have to have been assigned before invoking this function.
             * @param {number} [idealLength] the base length for an edge when its source and start have no other common neighbours (e.g. 40)
             * @param {number} [w] a multiplier for the effect of the length adjustment (e.g. 0.7)
             */
            jaccardLinkLengths(idealLength, w = 1) {
                this.linkDistance(l => idealLength * l.length);
                this._linkLengthCalculator = () => linklengths_1.jaccardLinkLengths(this._links, this.linkAccessor, w);
                return this;
            }
            /**
             * start the layout process
             * @method start
             * @param {number} [initialUnconstrainedIterations=0] unconstrained initial layout iterations
             * @param {number} [initialUserConstraintIterations=0] initial layout iterations with user-specified constraints
             * @param {number} [initialAllConstraintsIterations=0] initial layout iterations with all constraints including non-overlap
             * @param {number} [gridSnapIterations=0] iterations of "grid snap", which pulls nodes towards grid cell centers - grid of size node[0].width - only really makes sense if all nodes have the same width and height
             * @param [keepRunning=true] keep iterating asynchronously via the tick method
             * @param [centerGraph=true] Center graph on restart
             */
            start(initialUnconstrainedIterations = 0, initialUserConstraintIterations = 0, initialAllConstraintsIterations = 0, gridSnapIterations = 0, keepRunning = true, centerGraph = true) {
                var i, j, n = this.nodes().length,
                    N = n + 2 * this._groups.length,
                    m = this._links.length,
                    w = this._canvasSize[0],
                    h = this._canvasSize[1];
                var x = new Array(N),
                    y = new Array(N);
                var G = null;
                var ao = this._avoidOverlaps;
                this._nodes.forEach((v, i) => {
                    v.index = i;
                    if (typeof v.x === 'undefined') {
                        v.x = w / 2, v.y = h / 2;
                    }
                    x[i] = v.x, y[i] = v.y;
                });
                if (this._linkLengthCalculator)
                    this._linkLengthCalculator();
                //should we do this to clearly label groups?
                //this._groups.forEach((g, i) => g.groupIndex = i);
                var distances;
                if (this._distanceMatrix) {
                    // use the user specified distanceMatrix
                    distances = this._distanceMatrix;
                } else {
                    // construct an n X n distance matrix based on shortest paths through graph (with respect to edge.length).
                    distances = (new shortestpaths_1.Calculator(N, this._links, Layout.getSourceIndex, Layout.getTargetIndex, l => this.getLinkLength(l))).DistanceMatrix();
                    // G is a square matrix with G[i][j] = 1 iff there exists an edge between node i and node j
                    // otherwise 2. (
                    G = descent_1.Descent.createSquareMatrix(N, () => 2);
                    this._links.forEach(l => {
                        if (typeof l.source == "number")
                            l.source = this._nodes[l.source];
                        if (typeof l.target == "number")
                            l.target = this._nodes[l.target];
                    });
                    this._links.forEach(e => {
                        const u = Layout.getSourceIndex(e),
                            v = Layout.getTargetIndex(e);
                        G[u][v] = G[v][u] = e.weight || 1;
                    });
                }
                var D = descent_1.Descent.createSquareMatrix(N, function(i, j) {
                    return distances[i][j];
                });
                if (this._rootGroup && typeof this._rootGroup.groups !== 'undefined') {
                    var i = n;
                    var addAttraction = (i, j, strength, idealDistance) => {
                        G[i][j] = G[j][i] = strength;
                        D[i][j] = D[j][i] = idealDistance;
                    };
                    this._groups.forEach(g => {
                        addAttraction(i, i + 1, this._groupCompactness, 0.1);
                        // todo: add terms here attracting children of the group to the group dummy nodes
                        //if (typeof g.leaves !== 'undefined')
                        //    g.leaves.forEach(l => {
                        //        addAttraction(l.index, i, 1e-4, 0.1);
                        //        addAttraction(l.index, i + 1, 1e-4, 0.1);
                        //    });
                        //if (typeof g.groups !== 'undefined')
                        //    g.groups.forEach(g => {
                        //        var gid = n + g.groupIndex * 2;
                        //        addAttraction(gid, i, 0.1, 0.1);
                        //        addAttraction(gid + 1, i, 0.1, 0.1);
                        //        addAttraction(gid, i + 1, 0.1, 0.1);
                        //        addAttraction(gid + 1, i + 1, 0.1, 0.1);
                        //    });
                        if (typeof g.bounds === 'undefined') {
                            x[i] = w / 2, y[i++] = h / 2;
                            x[i] = w / 2, y[i++] = h / 2;
                        } else {
                            x[i] = g.bounds.x, y[i++] = g.bounds.y;
                            x[i] = g.bounds.X, y[i++] = g.bounds.Y;
                        }
                    });
                } else
                    this._rootGroup = {
                        leaves: this._nodes,
                        groups: []
                    };
                var curConstraints = this._constraints || [];
                if (this._directedLinkConstraints) {
                    this.linkAccessor.getMinSeparation = this._directedLinkConstraints.getMinSeparation;
                    curConstraints = curConstraints.concat(linklengths_1.generateDirectedEdgeConstraints(n, this._links, this._directedLinkConstraints.axis, (this.linkAccessor)));
                    // todo: add containment constraints between group dummy nodes and their children
                }
                this.avoidOverlaps(false);
                this._descent = new descent_1.Descent([x, y], D);
                this._descent.locks.clear();
                for (var i = 0; i < n; ++i) {
                    var o = this._nodes[i];
                    if (o.fixed) {
                        o.px = o.x;
                        o.py = o.y;
                        var p = [o.x, o.y];
                        this._descent.locks.add(i, p);
                    }
                }
                this._descent.threshold = this._threshold;
                // apply initialIterations without user constraints or nonoverlap constraints
                // if groups are specified, dummy nodes and edges will be added to untangle
                // with respect to group connectivity
                this.initialLayout(initialUnconstrainedIterations, x, y);
                // apply initialIterations with user constraints but no nonoverlap constraints
                if (curConstraints.length > 0)
                    this._descent.project = new rectangle_1.Projection(this._nodes, this._groups, this._rootGroup, curConstraints).projectFunctions();
                this._descent.run(initialUserConstraintIterations);
                this.separateOverlappingComponents(w, h, centerGraph);
                // subsequent iterations will apply all constraints
                this.avoidOverlaps(ao);
                if (ao) {
                    this._nodes.forEach(function(v, i) {
                        v.x = x[i], v.y = y[i];
                    });
                    this._descent.project = new rectangle_1.Projection(this._nodes, this._groups, this._rootGroup, curConstraints, true).projectFunctions();
                    this._nodes.forEach(function(v, i) {
                        x[i] = v.x, y[i] = v.y;
                    });
                }
                // allow not immediately connected nodes to relax apart (p-stress)
                this._descent.G = G;
                this._descent.run(initialAllConstraintsIterations);
                if (gridSnapIterations) {
                    this._descent.snapStrength = 1000;
                    this._descent.snapGridSize = this._nodes[0].width;
                    this._descent.numGridSnapNodes = n;
                    this._descent.scaleSnapByMaxH = n != N; // if we have groups then need to scale hessian so grid forces still apply
                    var G0 = descent_1.Descent.createSquareMatrix(N, (i, j) => {
                        if (i >= n || j >= n)
                            return G[i][j];
                        return 0;
                    });
                    this._descent.G = G0;
                    this._descent.run(gridSnapIterations);
                }
                this.updateNodePositions();
                this.separateOverlappingComponents(w, h, centerGraph);
                return keepRunning ? this.resume() : this;
            }
            initialLayout(iterations, x, y) {
                if (this._groups.length > 0 && iterations > 0) {
                    // construct a flat graph with dummy nodes for the groups and edges connecting group dummy nodes to their children
                    // todo: edges attached to groups are replaced with edges connected to the corresponding group dummy node
                    var n = this._nodes.length;
                    var edges = this._links.map(e => ({
                        source: e.source.index,
                        target: e.target.index
                    }));
                    var vs = this._nodes.map(v => ({
                        index: v.index
                    }));
                    this._groups.forEach((g, i) => {
                        vs.push({
                            index: g.index = n + i
                        });
                    });
                    this._groups.forEach((g, i) => {
                        if (typeof g.leaves !== 'undefined')
                            g.leaves.forEach(v => edges.push({
                                source: g.index,
                                target: v.index
                            }));
                        if (typeof g.groups !== 'undefined')
                            g.groups.forEach(gg => edges.push({
                                source: g.index,
                                target: gg.index
                            }));
                    });
                    // layout the flat graph with dummy nodes and edges
                    new Layout()
                        .size(this.size())
                        .nodes(vs)
                        .links(edges)
                        .avoidOverlaps(false)
                        .linkDistance(this.linkDistance())
                        .symmetricDiffLinkLengths(5)
                        .convergenceThreshold(1e-4)
                        .start(iterations, 0, 0, 0, false);
                    this._nodes.forEach(v => {
                        x[v.index] = vs[v.index].x;
                        y[v.index] = vs[v.index].y;
                    });
                } else {
                    this._descent.run(iterations);
                }
            }
            // recalculate nodes position for disconnected graphs
            separateOverlappingComponents(width, height, centerGraph = true) {
                // recalculate nodes position for disconnected graphs
                if (!this._distanceMatrix && this._handleDisconnected) {
                    let x = this._descent.x[0],
                        y = this._descent.x[1];
                    this._nodes.forEach(function(v, i) {
                        v.x = x[i], v.y = y[i];
                    });
                    var graphs = handledisconnected_1.separateGraphs(this._nodes, this._links);
                    handledisconnected_1.applyPacking(graphs, width, height, this._defaultNodeSize, 1, centerGraph);
                    this._nodes.forEach((v, i) => {
                        this._descent.x[0][i] = v.x, this._descent.x[1][i] = v.y;
                        if (v.bounds) {
                            v.bounds.setXCentre(v.x);
                            v.bounds.setYCentre(v.y);
                        }
                    });
                }
            }
            resume() {
                return this.alpha(0.1);
            }
            stop() {
                return this.alpha(0);
            }
            /// find a visibility graph over the set of nodes.  assumes all nodes have a
            /// bounds property (a rectangle) and that no pair of bounds overlaps.
            prepareEdgeRouting(nodeMargin = 0) {
                this._visibilityGraph = new geom_1.TangentVisibilityGraph(this._nodes.map(function(v) {
                    return v.bounds.inflate(-nodeMargin).vertices();
                }));
            }
            /**
             * find a route avoiding node bounds for the given edge.
             * assumes the visibility graph has been created (by prepareEdgeRouting method)
             * and also assumes that nodes have an index property giving their position in the
             * node array.  This index property is created by the start() method.
             * @param [edge] The edge to generate a route for.
             * @param {number} [ah] The size of the arrow head, a distance to shorten the end
             *                      of the edge by.  Defaults to 5.
             */
            routeEdge(edge, ah = 5, draw) {
                var lineData = [];
                //if (d.source.id === 10 && d.target.id === 11) {
                //    debugger;
                //}
                var vg2 = new geom_1.TangentVisibilityGraph(this._visibilityGraph.P, {
                        V: this._visibilityGraph.V,
                        E: this._visibilityGraph.E
                    }),
                    port1 = {
                        x: edge.source.x,
                        y: edge.source.y
                    },
                    port2 = {
                        x: edge.target.x,
                        y: edge.target.y
                    },
                    start = vg2.addPoint(port1, edge.source.index),
                    end = vg2.addPoint(port2, edge.target.index);
                vg2.addEdgeIfVisible(port1, port2, edge.source.index, edge.target.index);
                if (typeof draw !== 'undefined') {
                    draw(vg2);
                }
                var sourceInd = e => e.source.id,
                    targetInd = e => e.target.id,
                    length = e => e.length(),
                    spCalc = new shortestpaths_1.Calculator(vg2.V.length, vg2.E, sourceInd, targetInd, length),
                    shortestPath = spCalc.PathFromNodeToNode(start.id, end.id);
                if (shortestPath.length === 1 || shortestPath.length === vg2.V.length) {
                    let route = rectangle_1.makeEdgeBetween(edge.source.innerBounds, edge.target.innerBounds, ah);
                    lineData = [route.sourceIntersection, route.arrowStart];
                } else {
                    var n = shortestPath.length - 2,
                        p = vg2.V[shortestPath[n]].p,
                        q = vg2.V[shortestPath[0]].p,
                        lineData = [edge.source.innerBounds.rayIntersection(p.x, p.y)];
                    for (var i = n; i >= 0; --i)
                        lineData.push(vg2.V[shortestPath[i]].p);
                    lineData.push(rectangle_1.makeEdgeTo(q, edge.target.innerBounds, ah));
                }
                //lineData.forEach((v, i) => {
                //    if (i > 0) {
                //        var u = lineData[i - 1];
                //        this._nodes.forEach(function (node) {
                //            if (node.id === getSourceIndex(d) || node.id === getTargetIndex(d)) return;
                //            var ints = node.innerBounds.lineIntersections(u.x, u.y, v.x, v.y);
                //            if (ints.length > 0) {
                //                debugger;
                //            }
                //        })
                //    }
                //})
                return lineData;
            }
            //The link source and target may be just a node index, or they may be references to nodes themselves.
            static getSourceIndex(e) {
                return typeof e.source === 'number' ? e.source : e.source.index;
            }
            //The link source and target may be just a node index, or they may be references to nodes themselves.
            static getTargetIndex(e) {
                return typeof e.target === 'number' ? e.target : e.target.index;
            }
            // Get a string ID for a given link.
            static linkId(e) {
                return Layout.getSourceIndex(e) + "-" + Layout.getTargetIndex(e);
            }
            // The fixed property has three bits:
            // Bit 1 can be set externally (e.g., d.fixed = true) and show persist.
            // Bit 2 stores the dragging state, from mousedown to mouseup.
            // Bit 3 stores the hover state, from mouseover to mouseout.
            static dragStart(d) {
                if (isGroup(d)) {
                    Layout.storeOffset(d, Layout.dragOrigin(d));
                } else {
                    Layout.stopNode(d);
                    d.fixed |= 2; // set bit 2
                }
            }
            // we clobber any existing desired positions for nodes
            // in case another tick event occurs before the drag
            static stopNode(v) {
                v.px = v.x;
                v.py = v.y;
            }
            // we store offsets for each node relative to the centre of the ancestor group
            // being dragged in a pair of properties on the node
            static storeOffset(d, origin) {
                if (typeof d.leaves !== 'undefined') {
                    d.leaves.forEach(v => {
                        v.fixed |= 2;
                        Layout.stopNode(v);
                        v._dragGroupOffsetX = v.x - origin.x;
                        v._dragGroupOffsetY = v.y - origin.y;
                    });
                }
                if (typeof d.groups !== 'undefined') {
                    d.groups.forEach(g => Layout.storeOffset(g, origin));
                }
            }
            // the drag origin is taken as the centre of the node or group
            static dragOrigin(d) {
                if (isGroup(d)) {
                    return {
                        x: d.bounds.cx(),
                        y: d.bounds.cy()
                    };
                } else {
                    return d;
                }
            }
            // for groups, the drag translation is propagated down to all of the children of
            // the group.
            static drag(d, position) {
                if (isGroup(d)) {
                    if (typeof d.leaves !== 'undefined') {
                        d.leaves.forEach(v => {
                            d.bounds.setXCentre(position.x);
                            d.bounds.setYCentre(position.y);
                            v.px = v._dragGroupOffsetX + position.x;
                            v.py = v._dragGroupOffsetY + position.y;
                        });
                    }
                    if (typeof d.groups !== 'undefined') {
                        d.groups.forEach(g => Layout.drag(g, position));
                    }
                } else {
                    d.px = position.x;
                    d.py = position.y;
                }
            }
            // we unset only bits 2 and 3 so that the user can fix nodes with another a different
            // bit such that the lock persists between drags
            static dragEnd(d) {
                if (isGroup(d)) {
                    if (typeof d.leaves !== 'undefined') {
                        d.leaves.forEach(v => {
                            Layout.dragEnd(v);
                            delete v._dragGroupOffsetX;
                            delete v._dragGroupOffsetY;
                        });
                    }
                    if (typeof d.groups !== 'undefined') {
                        d.groups.forEach(Layout.dragEnd);
                    }
                } else {
                    d.fixed &= ~6; // unset bits 2 and 3
                    //d.fixed = 0;
                }
            }
            // in d3 hover temporarily locks nodes, currently not used in cola
            static mouseOver(d) {
                d.fixed |= 4; // set bit 3
                d.px = d.x, d.py = d.y; // set velocity to zero
            }
            // in d3 hover temporarily locks nodes, currently not used in cola
            static mouseOut(d) {
                d.fixed &= ~4; // unset bit 3
            }
        }
        exports.Layout = Layout;
    }, {
        "./descent": 8,
        "./geom": 9,
        "./handledisconnected": 11,
        "./linklengths": 14,
        "./powergraph": 15,
        "./rectangle": 18,
        "./shortestpaths": 19
    }],
    13: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        const shortestpaths_1 = require("./shortestpaths");
        const descent_1 = require("./descent");
        const rectangle_1 = require("./rectangle");
        const linklengths_1 = require("./linklengths");
        class Link3D {
            constructor(source, target) {
                this.source = source;
                this.target = target;
            }
            actualLength(x) {
                return Math.sqrt(x.reduce((c, v) => {
                    const dx = v[this.target] - v[this.source];
                    return c + dx * dx;
                }, 0));
            }
        }
        exports.Link3D = Link3D;
        class Node3D {
            constructor(x = 0, y = 0, z = 0) {
                this.x = x;
                this.y = y;
                this.z = z;
            }
        }
        exports.Node3D = Node3D;
        class Layout3D {
            constructor(nodes, links, idealLinkLength = 1) {
                this.nodes = nodes;
                this.links = links;
                this.idealLinkLength = idealLinkLength;
                this.constraints = null;
                this.useJaccardLinkLengths = true;
                this.result = new Array(Layout3D.k);
                for (var i = 0; i < Layout3D.k; ++i) {
                    this.result[i] = new Array(nodes.length);
                }
                nodes.forEach((v, i) => {
                    for (var dim of Layout3D.dims) {
                        if (typeof v[dim] == 'undefined')
                            v[dim] = Math.random();
                    }
                    this.result[0][i] = v.x;
                    this.result[1][i] = v.y;
                    this.result[2][i] = v.z;
                });
            };
            linkLength(l) {
                return l.actualLength(this.result);
            }
            start(iterations = 100) {
                const n = this.nodes.length;
                var linkAccessor = new LinkAccessor();
                if (this.useJaccardLinkLengths)
                    linklengths_1.jaccardLinkLengths(this.links, linkAccessor, 1.5);
                this.links.forEach(e => e.length *= this.idealLinkLength);
                // Create the distance matrix that Cola needs
                const distanceMatrix = (new shortestpaths_1.Calculator(n, this.links, e => e.source, e => e.target, e => e.length)).DistanceMatrix();
                const D = descent_1.Descent.createSquareMatrix(n, (i, j) => distanceMatrix[i][j]);
                // G is a square matrix with G[i][j] = 1 iff there exists an edge between node i and node j
                // otherwise 2.
                var G = descent_1.Descent.createSquareMatrix(n, function() {
                    return 2;
                });
                this.links.forEach(({
                    source,
                    target
                }) => G[source][target] = G[target][source] = 1);
                this.descent = new descent_1.Descent(this.result, D);
                this.descent.threshold = 1e-3;
                this.descent.G = G;
                //let constraints = this.links.map(e=> <any>{
                //    axis: 'y', left: e.source, right: e.target, gap: e.length*1.5
                //});
                if (this.constraints)
                    this.descent.project = new rectangle_1.Projection(this.nodes, null, null, this.constraints).projectFunctions();
                for (var i = 0; i < this.nodes.length; i++) {
                    var v = this.nodes[i];
                    if (v.fixed) {
                        this.descent.locks.add(i, [v.x, v.y, v.z]);
                    }
                }
                this.descent.run(iterations);
                return this;
            }
            tick() {
                this.descent.locks.clear();
                for (var i = 0; i < this.nodes.length; i++) {
                    var v = this.nodes[i];
                    if (v.fixed) {
                        this.descent.locks.add(i, [v.x, v.y, v.z]);
                    }
                }
                return this.descent.rungeKutta();
            }
        }
        Layout3D.dims = ['x', 'y', 'z'];
        Layout3D.k = Layout3D.dims.length;
        exports.Layout3D = Layout3D;
        class LinkAccessor {
            getSourceIndex(e) {
                return e.source;
            }
            getTargetIndex(e) {
                return e.target;
            }
            getLength(e) {
                return e.length;
            }
            setLength(e, l) {
                e.length = l;
            }
        }
    }, {
        "./descent": 8,
        "./linklengths": 14,
        "./rectangle": 18,
        "./shortestpaths": 19
    }],
    14: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        // compute the size of the union of two sets a and b
        function unionCount(a, b) {
            var u = {};
            for (var i in a)
                u[i] = {};
            for (var i in b)
                u[i] = {};
            return Object.keys(u).length;
        }
        // compute the size of the intersection of two sets a and b
        function intersectionCount(a, b) {
            var n = 0;
            for (var i in a)
                if (typeof b[i] !== 'undefined')
                    ++n;
            return n;
        }

        function getNeighbours(links, la) {
            var neighbours = {};
            var addNeighbours = (u, v) => {
                if (typeof neighbours[u] === 'undefined')
                    neighbours[u] = {};
                neighbours[u][v] = {};
            };
            links.forEach(e => {
                var u = la.getSourceIndex(e),
                    v = la.getTargetIndex(e);
                addNeighbours(u, v);
                addNeighbours(v, u);
            });
            return neighbours;
        }
        // modify the lengths of the specified links by the result of function f weighted by w
        function computeLinkLengths(links, w, f, la) {
            var neighbours = getNeighbours(links, la);
            links.forEach(l => {
                var a = neighbours[la.getSourceIndex(l)];
                var b = neighbours[la.getTargetIndex(l)];
                la.setLength(l, 1 + w * f(a, b));
            });
        }
        /** modify the specified link lengths based on the symmetric difference of their neighbours
         * @class symmetricDiffLinkLengths
         */
        function symmetricDiffLinkLengths(links, la, w = 1) {
            computeLinkLengths(links, w, (a, b) => Math.sqrt(unionCount(a, b) - intersectionCount(a, b)), la);
        }
        exports.symmetricDiffLinkLengths = symmetricDiffLinkLengths;
        /** modify the specified links lengths based on the jaccard difference between their neighbours
         * @class jaccardLinkLengths
         */
        function jaccardLinkLengths(links, la, w = 1) {
            computeLinkLengths(links, w, (a, b) => Math.min(Object.keys(a).length, Object.keys(b).length) < 1.1 ? 0 : intersectionCount(a, b) / unionCount(a, b), la);
        }
        exports.jaccardLinkLengths = jaccardLinkLengths;
        /** generate separation constraints for all edges unless both their source and sink are in the same strongly connected component
         * @class generateDirectedEdgeConstraints
         */
        function generateDirectedEdgeConstraints(n, links, axis, la) {
            var components = stronglyConnectedComponents(n, links, la);
            var nodes = {};
            components.forEach((c, i) => c.forEach(v => nodes[v] = i));
            var constraints = [];
            links.forEach(l => {
                var ui = la.getSourceIndex(l),
                    vi = la.getTargetIndex(l),
                    u = nodes[ui],
                    v = nodes[vi];
                if (u !== v) {
                    constraints.push({
                        axis: axis,
                        left: ui,
                        right: vi,
                        gap: la.getMinSeparation(l)
                    });
                }
            });
            return constraints;
        }
        exports.generateDirectedEdgeConstraints = generateDirectedEdgeConstraints;
        /**
         * Tarjan's strongly connected components algorithm for directed graphs
         * returns an array of arrays of node indicies in each of the strongly connected components.
         * a vertex not in a SCC of two or more nodes is it's own SCC.
         * adaptation of https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm
         */
        function stronglyConnectedComponents(numVertices, edges, la) {
            var nodes = [];
            var index = 0;
            var stack = [];
            var components = [];

            function strongConnect(v) {
                // Set the depth index for v to the smallest unused index
                v.index = v.lowlink = index++;
                stack.push(v);
                v.onStack = true;
                // Consider successors of v
                for (var w of v.out) {
                    if (typeof w.index === 'undefined') {
                        // Successor w has not yet been visited; recurse on it
                        strongConnect(w);
                        v.lowlink = Math.min(v.lowlink, w.lowlink);
                    } else if (w.onStack) {
                        // Successor w is in stack S and hence in the current SCC
                        v.lowlink = Math.min(v.lowlink, w.index);
                    }
                }
                // If v is a root node, pop the stack and generate an SCC
                if (v.lowlink === v.index) {
                    // start a new strongly connected component
                    var component = [];
                    while (stack.length) {
                        w = stack.pop();
                        w.onStack = false;
                        //add w to current strongly connected component
                        component.push(w);
                        if (w === v)
                            break;
                    }
                    // output the current strongly connected component
                    components.push(component.map(v => v.id));
                }
            }
            for (var i = 0; i < numVertices; i++) {
                nodes.push({
                    id: i,
                    out: []
                });
            }
            for (var e of edges) {
                let v = nodes[la.getSourceIndex(e)],
                    w = nodes[la.getTargetIndex(e)];
                v.out.push(w);
            }
            for (var v of nodes)
                if (typeof v.index === 'undefined')
                    strongConnect(v);
            return components;
        }
        exports.stronglyConnectedComponents = stronglyConnectedComponents;
    }, {}],
    15: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        class PowerEdge {
            constructor(source, target, type) {
                this.source = source;
                this.target = target;
                this.type = type;
            }
        }
        exports.PowerEdge = PowerEdge;
        class Configuration {
            constructor(n, edges, linkAccessor, rootGroup) {
                this.linkAccessor = linkAccessor;
                this.modules = new Array(n);
                this.roots = [];
                if (rootGroup) {
                    this.initModulesFromGroup(rootGroup);
                } else {
                    this.roots.push(new ModuleSet());
                    for (var i = 0; i < n; ++i)
                        this.roots[0].add(this.modules[i] = new Module(i));
                }
                this.R = edges.length;
                edges.forEach(e => {
                    var s = this.modules[linkAccessor.getSourceIndex(e)],
                        t = this.modules[linkAccessor.getTargetIndex(e)],
                        type = linkAccessor.getType(e);
                    s.outgoing.add(type, t);
                    t.incoming.add(type, s);
                });
            }
            initModulesFromGroup(group) {
                var moduleSet = new ModuleSet();
                this.roots.push(moduleSet);
                for (var i = 0; i < group.leaves.length; ++i) {
                    var node = group.leaves[i];
                    var module = new Module(node.id);
                    this.modules[node.id] = module;
                    moduleSet.add(module);
                }
                if (group.groups) {
                    for (var j = 0; j < group.groups.length; ++j) {
                        var child = group.groups[j];
                        // Propagate group properties (like padding, stiffness, ...) as module definition so that the generated power graph group will inherit it
                        var definition = {};
                        for (var prop in child)
                            if (prop !== "leaves" && prop !== "groups" && child.hasOwnProperty(prop))
                                definition[prop] = child[prop];
                        // Use negative module id to avoid clashes between predefined and generated modules
                        moduleSet.add(new Module(-1 - j, new LinkSets(), new LinkSets(), this.initModulesFromGroup(child), definition));
                    }
                }
                return moduleSet;
            }
            // merge modules a and b keeping track of their power edges and removing the from roots
            merge(a, b, k = 0) {
                var inInt = a.incoming.intersection(b.incoming),
                    outInt = a.outgoing.intersection(b.outgoing);
                var children = new ModuleSet();
                children.add(a);
                children.add(b);
                var m = new Module(this.modules.length, outInt, inInt, children);
                this.modules.push(m);
                var update = (s, i, o) => {
                    s.forAll((ms, linktype) => {
                        ms.forAll(n => {
                            var nls = n[i];
                            nls.add(linktype, m);
                            nls.remove(linktype, a);
                            nls.remove(linktype, b);
                            a[o].remove(linktype, n);
                            b[o].remove(linktype, n);
                        });
                    });
                };
                update(outInt, "incoming", "outgoing");
                update(inInt, "outgoing", "incoming");
                this.R -= inInt.count() + outInt.count();
                this.roots[k].remove(a);
                this.roots[k].remove(b);
                this.roots[k].add(m);
                return m;
            }
            rootMerges(k = 0) {
                var rs = this.roots[k].modules();
                var n = rs.length;
                var merges = new Array(n * (n - 1));
                var ctr = 0;
                for (var i = 0, i_ = n - 1; i < i_; ++i) {
                    for (var j = i + 1; j < n; ++j) {
                        var a = rs[i],
                            b = rs[j];
                        merges[ctr] = {
                            id: ctr,
                            nEdges: this.nEdges(a, b),
                            a: a,
                            b: b
                        };
                        ctr++;
                    }
                }
                return merges;
            }
            greedyMerge() {
                for (var i = 0; i < this.roots.length; ++i) {
                    // Handle single nested module case
                    if (this.roots[i].modules().length < 2)
                        continue;
                    // find the merge that allows for the most edges to be removed.  secondary ordering based on arbitrary id (for predictability)
                    var ms = this.rootMerges(i).sort((a, b) => a.nEdges == b.nEdges ? a.id - b.id : a.nEdges - b.nEdges);
                    var m = ms[0];
                    if (m.nEdges >= this.R)
                        continue;
                    this.merge(m.a, m.b, i);
                    return true;
                }
            }
            nEdges(a, b) {
                var inInt = a.incoming.intersection(b.incoming),
                    outInt = a.outgoing.intersection(b.outgoing);
                return this.R - inInt.count() - outInt.count();
            }
            getGroupHierarchy(retargetedEdges) {
                var groups = [];
                var root = {};
                toGroups(this.roots[0], root, groups);
                var es = this.allEdges();
                es.forEach(e => {
                    var a = this.modules[e.source];
                    var b = this.modules[e.target];
                    retargetedEdges.push(new PowerEdge(typeof a.gid === "undefined" ? e.source : groups[a.gid], typeof b.gid === "undefined" ? e.target : groups[b.gid], e.type));
                });
                return groups;
            }
            allEdges() {
                var es = [];
                Configuration.getEdges(this.roots[0], es);
                return es;
            }
            static getEdges(modules, es) {
                modules.forAll(m => {
                    m.getEdges(es);
                    Configuration.getEdges(m.children, es);
                });
            }
        }
        exports.Configuration = Configuration;

        function toGroups(modules, group, groups) {
            modules.forAll(m => {
                if (m.isLeaf()) {
                    if (!group.leaves)
                        group.leaves = [];
                    group.leaves.push(m.id);
                } else {
                    var g = group;
                    m.gid = groups.length;
                    if (!m.isIsland() || m.isPredefined()) {
                        g = {
                            id: m.gid
                        };
                        if (m.isPredefined())
                            // Apply original group properties
                            for (var prop in m.definition)
                                g[prop] = m.definition[prop];
                        if (!group.groups)
                            group.groups = [];
                        group.groups.push(m.gid);
                        groups.push(g);
                    }
                    toGroups(m.children, g, groups);
                }
            });
        }
        class Module {
            constructor(id, outgoing = new LinkSets(), incoming = new LinkSets(), children = new ModuleSet(), definition) {
                this.id = id;
                this.outgoing = outgoing;
                this.incoming = incoming;
                this.children = children;
                this.definition = definition;
            }
            getEdges(es) {
                this.outgoing.forAll((ms, edgetype) => {
                    ms.forAll(target => {
                        es.push(new PowerEdge(this.id, target.id, edgetype));
                    });
                });
            }
            isLeaf() {
                return this.children.count() === 0;
            }
            isIsland() {
                return this.outgoing.count() === 0 && this.incoming.count() === 0;
            }
            isPredefined() {
                return typeof this.definition !== "undefined";
            }
        }
        exports.Module = Module;

        function intersection(m, n) {
            var i = {};
            for (var v in m)
                if (v in n)
                    i[v] = m[v];
            return i;
        }
        class ModuleSet {
            constructor() {
                this.table = {};
            }
            count() {
                return Object.keys(this.table).length;
            }
            intersection(other) {
                var result = new ModuleSet();
                result.table = intersection(this.table, other.table);
                return result;
            }
            intersectionCount(other) {
                return this.intersection(other).count();
            }
            contains(id) {
                return id in this.table;
            }
            add(m) {
                this.table[m.id] = m;
            }
            remove(m) {
                delete this.table[m.id];
            }
            forAll(f) {
                for (var mid in this.table) {
                    f(this.table[mid]);
                }
            }
            modules() {
                var vs = [];
                this.forAll(m => {
                    if (!m.isPredefined())
                        vs.push(m);
                });
                return vs;
            }
        }
        exports.ModuleSet = ModuleSet;
        class LinkSets {
            constructor() {
                this.sets = {};
                this.n = 0;
            }
            count() {
                return this.n;
            }
            contains(id) {
                var result = false;
                this.forAllModules(m => {
                    if (!result && m.id == id) {
                        result = true;
                    }
                });
                return result;
            }
            add(linktype, m) {
                var s = linktype in this.sets ? this.sets[linktype] : this.sets[linktype] = new ModuleSet();
                s.add(m);
                ++this.n;
            }
            remove(linktype, m) {
                var ms = this.sets[linktype];
                ms.remove(m);
                if (ms.count() === 0) {
                    delete this.sets[linktype];
                }
                --this.n;
            }
            forAll(f) {
                for (var linktype in this.sets) {
                    f(this.sets[linktype], Number(linktype));
                }
            }
            forAllModules(f) {
                this.forAll((ms, lt) => ms.forAll(f));
            }
            intersection(other) {
                var result = new LinkSets();
                this.forAll((ms, lt) => {
                    if (lt in other.sets) {
                        var i = ms.intersection(other.sets[lt]),
                            n = i.count();
                        if (n > 0) {
                            result.sets[lt] = i;
                            result.n += n;
                        }
                    }
                });
                return result;
            }
        }
        exports.LinkSets = LinkSets;

        function intersectionCount(m, n) {
            return Object.keys(intersection(m, n)).length;
        }

        function getGroups(nodes, links, la, rootGroup) {
            var n = nodes.length,
                c = new Configuration(n, links, la, rootGroup);
            while (c.greedyMerge())
            ;
            var powerEdges = [];
            var g = c.getGroupHierarchy(powerEdges);
            powerEdges.forEach(function(e) {
                var f = (end) => {
                    var g = e[end];
                    if (typeof g == "number")
                        e[end] = nodes[g];
                };
                f("source");
                f("target");
            });
            return {
                groups: g,
                powerEdges: powerEdges
            };
        }
        exports.getGroups = getGroups;
    }, {}],
    16: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        class PairingHeap {
            // from: https://gist.github.com/nervoussystem
            //{elem:object, subheaps:[array of heaps]}
            constructor(elem) {
                this.elem = elem;
                this.subheaps = [];
            }
            toString(selector) {
                var str = "",
                    needComma = false;
                for (var i = 0; i < this.subheaps.length; ++i) {
                    var subheap = this.subheaps[i];
                    if (!subheap.elem) {
                        needComma = false;
                        continue;
                    }
                    if (needComma) {
                        str = str + ",";
                    }
                    str = str + subheap.toString(selector);
                    needComma = true;
                }
                if (str !== "") {
                    str = "(" + str + ")";
                }
                return (this.elem ? selector(this.elem) : "") + str;
            }
            forEach(f) {
                if (!this.empty()) {
                    f(this.elem, this);
                    this.subheaps.forEach(s => s.forEach(f));
                }
            }
            count() {
                return this.empty() ? 0 : 1 + this.subheaps.reduce((n, h) => {
                    return n + h.count();
                }, 0);
            }
            min() {
                return this.elem;
            }
            empty() {
                return this.elem == null;
            }
            contains(h) {
                if (this === h)
                    return true;
                for (var i = 0; i < this.subheaps.length; i++) {
                    if (this.subheaps[i].contains(h))
                        return true;
                }
                return false;
            }
            isHeap(lessThan) {
                return this.subheaps.every(h => lessThan(this.elem, h.elem) && h.isHeap(lessThan));
            }
            insert(obj, lessThan) {
                return this.merge(new PairingHeap(obj), lessThan);
            }
            merge(heap2, lessThan) {
                if (this.empty())
                    return heap2;
                else if (heap2.empty())
                    return this;
                else if (lessThan(this.elem, heap2.elem)) {
                    this.subheaps.push(heap2);
                    return this;
                } else {
                    heap2.subheaps.push(this);
                    return heap2;
                }
            }
            removeMin(lessThan) {
                if (this.empty())
                    return null;
                else
                    return this.mergePairs(lessThan);
            }
            mergePairs(lessThan) {
                if (this.subheaps.length == 0)
                    return new PairingHeap(null);
                else if (this.subheaps.length == 1) {
                    return this.subheaps[0];
                } else {
                    var firstPair = this.subheaps.pop().merge(this.subheaps.pop(), lessThan);
                    var remaining = this.mergePairs(lessThan);
                    return firstPair.merge(remaining, lessThan);
                }
            }
            decreaseKey(subheap, newValue, setHeapNode, lessThan) {
                var newHeap = subheap.removeMin(lessThan);
                //reassign subheap values to preserve tree
                subheap.elem = newHeap.elem;
                subheap.subheaps = newHeap.subheaps;
                if (setHeapNode !== null && newHeap.elem !== null) {
                    setHeapNode(subheap.elem, subheap);
                }
                var pairingNode = new PairingHeap(newValue);
                if (setHeapNode !== null) {
                    setHeapNode(newValue, pairingNode);
                }
                return this.merge(pairingNode, lessThan);
            }
        }
        exports.PairingHeap = PairingHeap;
        /**
         * @class PriorityQueue a min priority queue backed by a pairing heap
         */
        class PriorityQueue {
            constructor(lessThan) {
                this.lessThan = lessThan;
            }
            /**
             * @method top
             * @return the top element (the min element as defined by lessThan)
             */
            top() {
                if (this.empty()) {
                    return null;
                }
                return this.root.elem;
            }
            /**
             * @method push
             * put things on the heap
             */
            push(...args) {
                var pairingNode;
                for (var i = 0, arg; arg = args[i]; ++i) {
                    pairingNode = new PairingHeap(arg);
                    this.root = this.empty() ?
                        pairingNode : this.root.merge(pairingNode, this.lessThan);
                }
                return pairingNode;
            }
            /**
             * @method empty
             * @return true if no more elements in queue
             */
            empty() {
                return !this.root || !this.root.elem;
            }
            /**
             * @method isHeap check heap condition (for testing)
             * @return true if queue is in valid state
             */
            isHeap() {
                return this.root.isHeap(this.lessThan);
            }
            /**
             * @method forEach apply f to each element of the queue
             * @param f function to apply
             */
            forEach(f) {
                this.root.forEach(f);
            }
            /**
             * @method pop remove and return the min element from the queue
             */
            pop() {
                if (this.empty()) {
                    return null;
                }
                var obj = this.root.min();
                this.root = this.root.removeMin(this.lessThan);
                return obj;
            }
            /**
             * @method reduceKey reduce the key value of the specified heap node
             */
            reduceKey(heapNode, newKey, setHeapNode = null) {
                this.root = this.root.decreaseKey(heapNode, newKey, setHeapNode, this.lessThan);
            }
            toString(selector) {
                return this.root.toString(selector);
            }
            /**
             * @method count
             * @return number of elements in queue
             */
            count() {
                return this.root.count();
            }
        }
        exports.PriorityQueue = PriorityQueue;
    }, {}],
    17: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        //Based on js_es:
        //
        //https://github.com/vadimg/js_bintrees
        //
        //Copyright (C) 2011 by Vadim Graboys
        //
        //Permission is hereby granted, free of charge, to any person obtaining a copy
        //of this software and associated documentation files (the "Software"), to deal
        //in the Software without restriction, including without limitation the rights
        //to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        //copies of the Software, and to permit persons to whom the Software is
        //furnished to do so, subject to the following conditions:
        //
        //The above copyright notice and this permission notice shall be included in
        //all copies or substantial portions of the Software.
        //
        //THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        //IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        //FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        //AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        //LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        //OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
        //THE SOFTWARE.
        class TreeBase {
            constructor() {
                // returns iterator to node if found, null otherwise
                this.findIter = function(data) {
                    var res = this._root;
                    var iter = this.iterator();
                    while (res !== null) {
                        var c = this._comparator(data, res.data);
                        if (c === 0) {
                            iter._cursor = res;
                            return iter;
                        } else {
                            iter._ancestors.push(res);
                            res = res.get_child(c > 0);
                        }
                    }
                    return null;
                };
            }
            // removes all nodes from the tree
            clear() {
                this._root = null;
                this.size = 0;
            };
            // returns node data if found, null otherwise
            find(data) {
                var res = this._root;
                while (res !== null) {
                    var c = this._comparator(data, res.data);
                    if (c === 0) {
                        return res.data;
                    } else {
                        res = res.get_child(c > 0);
                    }
                }
                return null;
            };
            // Returns an interator to the tree node immediately before (or at) the element
            lowerBound(data) {
                return this._bound(data, this._comparator);
            };
            // Returns an interator to the tree node immediately after (or at) the element
            upperBound(data) {
                var cmp = this._comparator;

                function reverse_cmp(a, b) {
                    return cmp(b, a);
                }
                return this._bound(data, reverse_cmp);
            };
            // returns null if tree is empty
            min() {
                var res = this._root;
                if (res === null) {
                    return null;
                }
                while (res.left !== null) {
                    res = res.left;
                }
                return res.data;
            };
            // returns null if tree is empty
            max() {
                var res = this._root;
                if (res === null) {
                    return null;
                }
                while (res.right !== null) {
                    res = res.right;
                }
                return res.data;
            };
            // returns a null iterator
            // call next() or prev() to point to an element
            iterator() {
                return new Iterator(this);
            };
            // calls cb on each node's data, in order
            each(cb) {
                var it = this.iterator(),
                    data;
                while ((data = it.next()) !== null) {
                    cb(data);
                }
            };
            // calls cb on each node's data, in reverse order
            reach(cb) {
                var it = this.iterator(),
                    data;
                while ((data = it.prev()) !== null) {
                    cb(data);
                }
            };
            // used for lowerBound and upperBound
            _bound(data, cmp) {
                var cur = this._root;
                var iter = this.iterator();
                while (cur !== null) {
                    var c = this._comparator(data, cur.data);
                    if (c === 0) {
                        iter._cursor = cur;
                        return iter;
                    }
                    iter._ancestors.push(cur);
                    cur = cur.get_child(c > 0);
                }
                for (var i = iter._ancestors.length - 1; i >= 0; --i) {
                    cur = iter._ancestors[i];
                    if (cmp(data, cur.data) > 0) {
                        iter._cursor = cur;
                        iter._ancestors.length = i;
                        return iter;
                    }
                }
                iter._ancestors.length = 0;
                return iter;
            };
        }
        exports.TreeBase = TreeBase;
        class Iterator {
            constructor(tree) {
                this._tree = tree;
                this._ancestors = [];
                this._cursor = null;
            }
            data() {
                return this._cursor !== null ? this._cursor.data : null;
            };
            // if null-iterator, returns first node
            // otherwise, returns next node
            next() {
                if (this._cursor === null) {
                    var root = this._tree._root;
                    if (root !== null) {
                        this._minNode(root);
                    }
                } else {
                    if (this._cursor.right === null) {
                        // no greater node in subtree, go up to parent
                        // if coming from a right child, continue up the stack
                        var save;
                        do {
                            save = this._cursor;
                            if (this._ancestors.length) {
                                this._cursor = this._ancestors.pop();
                            } else {
                                this._cursor = null;
                                break;
                            }
                        } while (this._cursor.right === save);
                    } else {
                        // get the next node from the subtree
                        this._ancestors.push(this._cursor);
                        this._minNode(this._cursor.right);
                    }
                }
                return this._cursor !== null ? this._cursor.data : null;
            };
            // if null-iterator, returns last node
            // otherwise, returns previous node
            prev() {
                if (this._cursor === null) {
                    var root = this._tree._root;
                    if (root !== null) {
                        this._maxNode(root);
                    }
                } else {
                    if (this._cursor.left === null) {
                        var save;
                        do {
                            save = this._cursor;
                            if (this._ancestors.length) {
                                this._cursor = this._ancestors.pop();
                            } else {
                                this._cursor = null;
                                break;
                            }
                        } while (this._cursor.left === save);
                    } else {
                        this._ancestors.push(this._cursor);
                        this._maxNode(this._cursor.left);
                    }
                }
                return this._cursor !== null ? this._cursor.data : null;
            };
            _minNode(start) {
                while (start.left !== null) {
                    this._ancestors.push(start);
                    start = start.left;
                }
                this._cursor = start;
            };
            _maxNode(start) {
                while (start.right !== null) {
                    this._ancestors.push(start);
                    start = start.right;
                }
                this._cursor = start;
            };
        }
        exports.Iterator = Iterator;
        class Node {
            constructor(data) {
                this.data = data;
                this.left = null;
                this.right = null;
                this.red = true;
            }
            get_child(dir) {
                return dir ? this.right : this.left;
            };
            set_child(dir, val) {
                if (dir) {
                    this.right = val;
                } else {
                    this.left = val;
                }
            };
        }
        class RBTree extends TreeBase {
            constructor(comparator) {
                super();
                this._root = null;
                this._comparator = comparator;
                this.size = 0;
            }
            // returns true if inserted, false if duplicate
            insert(data) {
                var ret = false;
                if (this._root === null) {
                    // empty tree
                    this._root = new Node(data);
                    ret = true;
                    this.size++;
                } else {
                    var head = new Node(undefined); // fake tree root
                    var dir = false;
                    var last = false;
                    // setup
                    var gp = null; // grandparent
                    var ggp = head; // grand-grand-parent
                    var p = null; // parent
                    var node = this._root;
                    ggp.right = this._root;
                    // search down
                    while (true) {
                        if (node === null) {
                            // insert new node at the bottom
                            node = new Node(data);
                            p.set_child(dir, node);
                            ret = true;
                            this.size++;
                        } else if (RBTree.is_red(node.left) && RBTree.is_red(node.right)) {
                            // color flip
                            node.red = true;
                            node.left.red = false;
                            node.right.red = false;
                        }
                        // fix red violation
                        if (RBTree.is_red(node) && RBTree.is_red(p)) {
                            var dir2 = ggp.right === gp;
                            if (node === p.get_child(last)) {
                                ggp.set_child(dir2, RBTree.single_rotate(gp, !last));
                            } else {
                                ggp.set_child(dir2, RBTree.double_rotate(gp, !last));
                            }
                        }
                        var cmp = this._comparator(node.data, data);
                        // stop if found
                        if (cmp === 0) {
                            break;
                        }
                        last = dir;
                        dir = cmp < 0;
                        // update helpers
                        if (gp !== null) {
                            ggp = gp;
                        }
                        gp = p;
                        p = node;
                        node = node.get_child(dir);
                    }
                    // update root
                    this._root = head.right;
                }
                // make root black
                this._root.red = false;
                return ret;
            };
            // returns true if removed, false if not found
            remove(data) {
                if (this._root === null) {
                    return false;
                }
                var head = new Node(undefined); // fake tree root
                var node = head;
                node.right = this._root;
                var p = null; // parent
                var gp = null; // grand parent
                var found = null; // found item
                var dir = true;
                while (node.get_child(dir) !== null) {
                    var last = dir;
                    // update helpers
                    gp = p;
                    p = node;
                    node = node.get_child(dir);
                    var cmp = this._comparator(data, node.data);
                    dir = cmp > 0;
                    // save found node
                    if (cmp === 0) {
                        found = node;
                    }
                    // push the red node down
                    if (!RBTree.is_red(node) && !RBTree.is_red(node.get_child(dir))) {
                        if (RBTree.is_red(node.get_child(!dir))) {
                            var sr = RBTree.single_rotate(node, dir);
                            p.set_child(last, sr);
                            p = sr;
                        } else if (!RBTree.is_red(node.get_child(!dir))) {
                            var sibling = p.get_child(!last);
                            if (sibling !== null) {
                                if (!RBTree.is_red(sibling.get_child(!last)) && !RBTree.is_red(sibling.get_child(last))) {
                                    // color flip
                                    p.red = false;
                                    sibling.red = true;
                                    node.red = true;
                                } else {
                                    var dir2 = gp.right === p;
                                    if (RBTree.is_red(sibling.get_child(last))) {
                                        gp.set_child(dir2, RBTree.double_rotate(p, last));
                                    } else if (RBTree.is_red(sibling.get_child(!last))) {
                                        gp.set_child(dir2, RBTree.single_rotate(p, last));
                                    }
                                    // ensure correct coloring
                                    var gpc = gp.get_child(dir2);
                                    gpc.red = true;
                                    node.red = true;
                                    gpc.left.red = false;
                                    gpc.right.red = false;
                                }
                            }
                        }
                    }
                }
                // replace and remove if found
                if (found !== null) {
                    found.data = node.data;
                    p.set_child(p.right === node, node.get_child(node.left === null));
                    this.size--;
                }
                // update root and make it black
                this._root = head.right;
                if (this._root !== null) {
                    this._root.red = false;
                }
                return found !== null;
            };
            static is_red(node) {
                return node !== null && node.red;
            }
            static single_rotate(root, dir) {
                var save = root.get_child(!dir);
                root.set_child(!dir, save.get_child(dir));
                save.set_child(dir, root);
                root.red = true;
                save.red = false;
                return save;
            }
            static double_rotate(root, dir) {
                root.set_child(!dir, RBTree.single_rotate(root.get_child(!dir), !dir));
                return RBTree.single_rotate(root, dir);
            }
        }
        exports.RBTree = RBTree;
    }, {}],
    18: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        const vpsc_1 = require("./vpsc");
        const rbtree_1 = require("./rbtree");

        function computeGroupBounds(g) {
            g.bounds = typeof g.leaves !== "undefined" ?
                g.leaves.reduce((r, c) => c.bounds.union(r), Rectangle.empty()) :
                Rectangle.empty();
            if (typeof g.groups !== "undefined")
                g.bounds = g.groups.reduce((r, c) => computeGroupBounds(c).union(r), g.bounds);
            g.bounds = g.bounds.inflate(g.padding);
            return g.bounds;
        }
        exports.computeGroupBounds = computeGroupBounds;
        class Rectangle {
            constructor(x, X, y, Y) {
                this.x = x;
                this.X = X;
                this.y = y;
                this.Y = Y;
            }
            static empty() {
                return new Rectangle(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY);
            }
            cx() {
                return (this.x + this.X) / 2;
            }
            cy() {
                return (this.y + this.Y) / 2;
            }
            overlapX(r) {
                var ux = this.cx(),
                    vx = r.cx();
                if (ux <= vx && r.x < this.X)
                    return this.X - r.x;
                if (vx <= ux && this.x < r.X)
                    return r.X - this.x;
                return 0;
            }
            overlapY(r) {
                var uy = this.cy(),
                    vy = r.cy();
                if (uy <= vy && r.y < this.Y)
                    return this.Y - r.y;
                if (vy <= uy && this.y < r.Y)
                    return r.Y - this.y;
                return 0;
            }
            setXCentre(cx) {
                var dx = cx - this.cx();
                this.x += dx;
                this.X += dx;
            }
            setYCentre(cy) {
                var dy = cy - this.cy();
                this.y += dy;
                this.Y += dy;
            }
            width() {
                return this.X - this.x;
            }
            height() {
                return this.Y - this.y;
            }
            union(r) {
                return new Rectangle(Math.min(this.x, r.x), Math.max(this.X, r.X), Math.min(this.y, r.y), Math.max(this.Y, r.Y));
            }
            /**
             * return any intersection points between the given line and the sides of this rectangle
             * @method lineIntersection
             * @param x1 number first x coord of line
             * @param y1 number first y coord of line
             * @param x2 number second x coord of line
             * @param y2 number second y coord of line
             * @return any intersection points found
             */
            lineIntersections(x1, y1, x2, y2) {
                var sides = [
                    [this.x, this.y, this.X, this.y],
                    [this.X, this.y, this.X, this.Y],
                    [this.X, this.Y, this.x, this.Y],
                    [this.x, this.Y, this.x, this.y]
                ];
                var intersections = [];
                for (var i = 0; i < 4; ++i) {
                    var r = Rectangle.lineIntersection(x1, y1, x2, y2, sides[i][0], sides[i][1], sides[i][2], sides[i][3]);
                    if (r !== null)
                        intersections.push({
                            x: r.x,
                            y: r.y
                        });
                }
                return intersections;
            }
            /**
             * return any intersection points between a line extending from the centre of this rectangle to the given point,
             *  and the sides of this rectangle
             * @method lineIntersection
             * @param x2 number second x coord of line
             * @param y2 number second y coord of line
             * @return any intersection points found
             */
            rayIntersection(x2, y2) {
                var ints = this.lineIntersections(this.cx(), this.cy(), x2, y2);
                return ints.length > 0 ? ints[0] : null;
            }
            vertices() {
                return [{
                        x: this.x,
                        y: this.y
                    },
                    {
                        x: this.X,
                        y: this.y
                    },
                    {
                        x: this.X,
                        y: this.Y
                    },
                    {
                        x: this.x,
                        y: this.Y
                    }
                ];
            }
            static lineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
                var dx12 = x2 - x1,
                    dx34 = x4 - x3,
                    dy12 = y2 - y1,
                    dy34 = y4 - y3,
                    denominator = dy34 * dx12 - dx34 * dy12;
                if (denominator == 0)
                    return null;
                var dx31 = x1 - x3,
                    dy31 = y1 - y3,
                    numa = dx34 * dy31 - dy34 * dx31,
                    a = numa / denominator,
                    numb = dx12 * dy31 - dy12 * dx31,
                    b = numb / denominator;
                if (a >= 0 && a <= 1 && b >= 0 && b <= 1) {
                    return {
                        x: x1 + a * dx12,
                        y: y1 + a * dy12
                    };
                }
                return null;
            }
            inflate(pad) {
                return new Rectangle(this.x - pad, this.X + pad, this.y - pad, this.Y + pad);
            }
        }
        exports.Rectangle = Rectangle;
        /**
         * Returns the endpoints of a line that connects the centre of two rectangles.
         * @param {Rectangle} [source] The source Rectangle.
         * @param {Rectangle} [target] The target Rectangle.
         * @param {number} [ah] The size of the arrow head, a distance to shorten the
         *                      line by.
         * @return An object with three point properties, the intersection with the
         *         source rectangle (sourceIntersection), the intersection with then
         *         target rectangle (targetIntersection), and the point an arrow
         *         head of the specified size would need to start (arrowStart).
         */
        function makeEdgeBetween(source, target, ah) {
            const si = source.rayIntersection(target.cx(), target.cy()) || {
                    x: source.cx(),
                    y: source.cy()
                },
                ti = target.rayIntersection(source.cx(), source.cy()) || {
                    x: target.cx(),
                    y: target.cy()
                },
                dx = ti.x - si.x,
                dy = ti.y - si.y,
                l = Math.sqrt(dx * dx + dy * dy),
                al = l - ah;
            return {
                sourceIntersection: si,
                targetIntersection: ti,
                arrowStart: {
                    x: si.x + al * dx / l,
                    y: si.y + al * dy / l
                }
            };
        }
        exports.makeEdgeBetween = makeEdgeBetween;
        /**
         * Returns the intersection of a line from the given point to the centre
         * of the target rectangle where it intersects the rectanngle.
         * @param [source] The source point.
         * @param {Rectangle} [target] The target Rectangle.
         * @param {number} [ah] The size of the arrow head, a distance to shorten the
         *                      line by.
         * @return The point an arrow head of the specified size would need to start.
         */
        function makeEdgeTo(s, target, ah) {
            var ti = target.rayIntersection(s.x, s.y);
            if (!ti)
                ti = {
                    x: target.cx(),
                    y: target.cy()
                };
            var dx = ti.x - s.x,
                dy = ti.y - s.y,
                l = Math.sqrt(dx * dx + dy * dy);
            return {
                x: ti.x - ah * dx / l,
                y: ti.y - ah * dy / l
            };
        }
        exports.makeEdgeTo = makeEdgeTo;
        class Node {
            constructor(v, r, pos) {
                this.v = v;
                this.r = r;
                this.pos = pos;
                this.prev = makeRBTree();
                this.next = makeRBTree();
            }
        }
        class Event {
            constructor(isOpen, v, pos) {
                this.isOpen = isOpen;
                this.v = v;
                this.pos = pos;
            }
        }

        function compareEvents(a, b) {
            if (a.pos > b.pos) {
                return 1;
            }
            if (a.pos < b.pos) {
                return -1;
            }
            if (a.isOpen) {
                // open must come before close
                return -1;
            }
            if (b.isOpen) {
                // open must come before close
                return 1;
            }
            return 0;
        }

        function makeRBTree() {
            return new rbtree_1.RBTree((a, b) => a.pos - b.pos);
        }
        var xRect = {
            getCentre: r => r.cx(),
            getOpen: r => r.y,
            getClose: r => r.Y,
            getSize: r => r.width(),
            makeRect: (open, close, center, size) => new Rectangle(center - size / 2, center + size / 2, open, close),
            findNeighbours: findXNeighbours
        };
        var yRect = {
            getCentre: r => r.cy(),
            getOpen: r => r.x,
            getClose: r => r.X,
            getSize: r => r.height(),
            makeRect: (open, close, center, size) => new Rectangle(open, close, center - size / 2, center + size / 2),
            findNeighbours: findYNeighbours
        };

        function generateGroupConstraints(root, f, minSep, isContained = false) {
            var padding = root.padding,
                gn = typeof root.groups !== 'undefined' ? root.groups.length : 0,
                ln = typeof root.leaves !== 'undefined' ? root.leaves.length : 0,
                childConstraints = !gn ? [] :
                root.groups.reduce((ccs, g) => ccs.concat(generateGroupConstraints(g, f, minSep, true)), []),
                n = (isContained ? 2 : 0) + ln + gn,
                vs = new Array(n),
                rs = new Array(n),
                i = 0,
                add = (r, v) => {
                    rs[i] = r;
                    vs[i++] = v;
                };
            if (isContained) {
                // if this group is contained by another, then we add two dummy vars and rectangles for the borders
                var b = root.bounds,
                    c = f.getCentre(b),
                    s = f.getSize(b) / 2,
                    open = f.getOpen(b),
                    close = f.getClose(b),
                    min = c - s + padding / 2,
                    max = c + s - padding / 2;
                root.minVar.desiredPosition = min;
                add(f.makeRect(open, close, min, padding), root.minVar);
                root.maxVar.desiredPosition = max;
                add(f.makeRect(open, close, max, padding), root.maxVar);
            }
            if (ln)
                root.leaves.forEach(l => add(l.bounds, l.variable));
            if (gn)
                root.groups.forEach(g => {
                    var b = g.bounds;
                    add(f.makeRect(f.getOpen(b), f.getClose(b), f.getCentre(b), f.getSize(b)), g.minVar);
                });
            var cs = generateConstraints(rs, vs, f, minSep);
            if (gn) {
                vs.forEach(v => {
                    v.cOut = [], v.cIn = [];
                });
                cs.forEach(c => {
                    c.left.cOut.push(c), c.right.cIn.push(c);
                });
                root.groups.forEach(g => {
                    var gapAdjustment = (g.padding - f.getSize(g.bounds)) / 2;
                    g.minVar.cIn.forEach(c => c.gap += gapAdjustment);
                    g.minVar.cOut.forEach(c => {
                        c.left = g.maxVar;
                        c.gap += gapAdjustment;
                    });
                });
            }
            return childConstraints.concat(cs);
        }

        function generateConstraints(rs, vars, rect, minSep) {
            var i, n = rs.length;
            var N = 2 * n;
            console.assert(vars.length >= n);
            var events = new Array(N);
            for (i = 0; i < n; ++i) {
                var r = rs[i];
                var v = new Node(vars[i], r, rect.getCentre(r));
                events[i] = new Event(true, v, rect.getOpen(r));
                events[i + n] = new Event(false, v, rect.getClose(r));
            }
            events.sort(compareEvents);
            var cs = new Array();
            var scanline = makeRBTree();
            for (i = 0; i < N; ++i) {
                var e = events[i];
                var v = e.v;
                if (e.isOpen) {
                    scanline.insert(v);
                    rect.findNeighbours(v, scanline);
                } else {
                    // close event
                    scanline.remove(v);
                    var makeConstraint = (l, r) => {
                        var sep = (rect.getSize(l.r) + rect.getSize(r.r)) / 2 + minSep;
                        cs.push(new vpsc_1.Constraint(l.v, r.v, sep));
                    };
                    var visitNeighbours = (forward, reverse, mkcon) => {
                        var u, it = v[forward].iterator();
                        while ((u = it[forward]()) !== null) {
                            mkcon(u, v);
                            u[reverse].remove(v);
                        }
                    };
                    visitNeighbours("prev", "next", (u, v) => makeConstraint(u, v));
                    visitNeighbours("next", "prev", (u, v) => makeConstraint(v, u));
                }
            }
            console.assert(scanline.size === 0);
            return cs;
        }

        function findXNeighbours(v, scanline) {
            var f = (forward, reverse) => {
                var it = scanline.findIter(v);
                var u;
                while ((u = it[forward]()) !== null) {
                    var uovervX = u.r.overlapX(v.r);
                    if (uovervX <= 0 || uovervX <= u.r.overlapY(v.r)) {
                        v[forward].insert(u);
                        u[reverse].insert(v);
                    }
                    if (uovervX <= 0) {
                        break;
                    }
                }
            };
            f("next", "prev");
            f("prev", "next");
        }

        function findYNeighbours(v, scanline) {
            var f = (forward, reverse) => {
                var u = scanline.findIter(v)[forward]();
                if (u !== null && u.r.overlapX(v.r) > 0) {
                    v[forward].insert(u);
                    u[reverse].insert(v);
                }
            };
            f("next", "prev");
            f("prev", "next");
        }

        function generateXConstraints(rs, vars) {
            return generateConstraints(rs, vars, xRect, 1e-6);
        }
        exports.generateXConstraints = generateXConstraints;

        function generateYConstraints(rs, vars) {
            return generateConstraints(rs, vars, yRect, 1e-6);
        }
        exports.generateYConstraints = generateYConstraints;

        function generateXGroupConstraints(root) {
            return generateGroupConstraints(root, xRect, 1e-6);
        }
        exports.generateXGroupConstraints = generateXGroupConstraints;

        function generateYGroupConstraints(root) {
            return generateGroupConstraints(root, yRect, 1e-6);
        }
        exports.generateYGroupConstraints = generateYGroupConstraints;

        function removeOverlaps(rs) {
            var vs = rs.map(r => new vpsc_1.Variable(r.cx()));
            var cs = generateXConstraints(rs, vs);
            var solver = new vpsc_1.Solver(vs, cs);
            solver.solve();
            vs.forEach((v, i) => rs[i].setXCentre(v.position()));
            vs = rs.map(r => new vpsc_1.Variable(r.cy()));
            cs = generateYConstraints(rs, vs);
            solver = new vpsc_1.Solver(vs, cs);
            solver.solve();
            vs.forEach((v, i) => rs[i].setYCentre(v.position()));
        }
        exports.removeOverlaps = removeOverlaps;
        class IndexedVariable extends vpsc_1.Variable {
            constructor(index, w) {
                super(0, w);
                this.index = index;
            }
        }
        exports.IndexedVariable = IndexedVariable;
        class Projection {
            constructor(nodes, groups, rootGroup = null, constraints = null, avoidOverlaps = false) {
                this.nodes = nodes;
                this.groups = groups;
                this.rootGroup = rootGroup;
                this.avoidOverlaps = avoidOverlaps;
                this.variables = nodes.map((v, i) => {
                    return v.variable = new IndexedVariable(i, 1);
                });
                if (constraints)
                    this.createConstraints(constraints);
                if (avoidOverlaps && rootGroup && typeof rootGroup.groups !== 'undefined') {
                    nodes.forEach(v => {
                        if (!v.width || !v.height) {
                            //If undefined, default to nothing
                            v.bounds = new Rectangle(v.x, v.x, v.y, v.y);
                            return;
                        }
                        var w2 = v.width / 2,
                            h2 = v.height / 2;
                        v.bounds = new Rectangle(v.x - w2, v.x + w2, v.y - h2, v.y + h2);
                    });
                    computeGroupBounds(rootGroup);
                    var i = nodes.length;
                    groups.forEach(g => {
                        this.variables[i] = g.minVar = new IndexedVariable(i++, typeof g.stiffness !== "undefined" ? g.stiffness : 0.01);
                        this.variables[i] = g.maxVar = new IndexedVariable(i++, typeof g.stiffness !== "undefined" ? g.stiffness : 0.01);
                    });
                }
            }
            createSeparation(c) {
                return new vpsc_1.Constraint(this.nodes[c.left].variable, this.nodes[c.right].variable, c.gap, typeof c.equality !== "undefined" ? c.equality : false);
            }
            // simple satisfaction of alignment constraints to ensure initial feasibility
            makeFeasible(c) {
                if (!this.avoidOverlaps)
                    return;
                // sort nodes in constraint by position (along "guideline")
                var axis = 'x',
                    dim = 'width';
                if (c.axis === 'x')
                    axis = 'y', dim = 'height';
                var vs = c.offsets.map(o => this.nodes[o.node]).sort((a, b) => a[axis] - b[axis]);
                var p = null;
                vs.forEach(v => {
                    // if two nodes overlap then shove the second one along
                    if (p) {
                        let nextPos = p[axis] + p[dim];
                        if (nextPos > v[axis]) {
                            v[axis] = nextPos;
                        }
                    }
                    p = v;
                });
            }
            createAlignment(c) {
                var u = this.nodes[c.offsets[0].node].variable;
                this.makeFeasible(c);
                var cs = c.axis === 'x' ? this.xConstraints : this.yConstraints;
                c.offsets.slice(1).forEach(o => {
                    var v = this.nodes[o.node].variable;
                    cs.push(new vpsc_1.Constraint(u, v, o.offset, true));
                });
            }
            createConstraints(constraints) {
                var isSep = c => typeof c.type === 'undefined' || c.type === 'separation';
                this.xConstraints = constraints
                    .filter(c => c.axis === "x" && isSep(c))
                    .map(c => this.createSeparation(c));
                this.yConstraints = constraints
                    .filter(c => c.axis === "y" && isSep(c))
                    .map(c => this.createSeparation(c));
                constraints
                    .filter(c => c.type === 'alignment')
                    .forEach(c => this.createAlignment(c));
            }
            setupVariablesAndBounds(x0, y0, desired, getDesired) {
                this.nodes.forEach((v, i) => {
                    if (v.fixed) {
                        v.variable.weight = v.fixedWeight ? v.fixedWeight : 1000;
                        desired[i] = getDesired(v);
                    } else {
                        v.variable.weight = 1;
                    }
                    var w = (v.width || 0) / 2,
                        h = (v.height || 0) / 2;
                    var ix = x0[i],
                        iy = y0[i];
                    v.bounds = new Rectangle(ix - w, ix + w, iy - h, iy + h);
                });
            }
            xProject(x0, y0, x) {
                if (!this.rootGroup && !(this.avoidOverlaps || this.xConstraints))
                    return;
                this.project(x0, y0, x0, x, v => v.px, this.xConstraints, generateXGroupConstraints, v => v.bounds.setXCentre(x[v.variable.index] = v.variable.position()), g => {
                    var xmin = x[g.minVar.index] = g.minVar.position();
                    var xmax = x[g.maxVar.index] = g.maxVar.position();
                    var p2 = g.padding / 2;
                    g.bounds.x = xmin - p2;
                    g.bounds.X = xmax + p2;
                });
            }
            yProject(x0, y0, y) {
                if (!this.rootGroup && !this.yConstraints)
                    return;
                this.project(x0, y0, y0, y, v => v.py, this.yConstraints, generateYGroupConstraints, v => v.bounds.setYCentre(y[v.variable.index] = v.variable.position()), g => {
                    var ymin = y[g.minVar.index] = g.minVar.position();
                    var ymax = y[g.maxVar.index] = g.maxVar.position();
                    var p2 = g.padding / 2;
                    g.bounds.y = ymin - p2;;
                    g.bounds.Y = ymax + p2;
                });
            }
            projectFunctions() {
                return [
                    (x0, y0, x) => this.xProject(x0, y0, x),
                    (x0, y0, y) => this.yProject(x0, y0, y)
                ];
            }
            project(x0, y0, start, desired, getDesired, cs, generateConstraints, updateNodeBounds, updateGroupBounds) {
                this.setupVariablesAndBounds(x0, y0, desired, getDesired);
                if (this.rootGroup && this.avoidOverlaps) {
                    computeGroupBounds(this.rootGroup);
                    cs = cs.concat(generateConstraints(this.rootGroup));
                }
                this.solve(this.variables, cs, start, desired);
                this.nodes.forEach(updateNodeBounds);
                if (this.rootGroup && this.avoidOverlaps) {
                    this.groups.forEach(updateGroupBounds);
                    computeGroupBounds(this.rootGroup);
                }
            }
            solve(vs, cs, starting, desired) {
                var solver = new vpsc_1.Solver(vs, cs);
                solver.setStartingPositions(starting);
                solver.setDesiredPositions(desired);
                solver.solve();
            }
        }
        exports.Projection = Projection;
    }, {
        "./rbtree": 17,
        "./vpsc": 20
    }],
    19: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        const pqueue_1 = require("./pqueue");
        class Neighbour {
            constructor(id, distance) {
                this.id = id;
                this.distance = distance;
            }
        }
        class Node {
            constructor(id) {
                this.id = id;
                this.neighbours = [];
            }
        }
        class QueueEntry {
            constructor(node, prev, d) {
                this.node = node;
                this.prev = prev;
                this.d = d;
            }
        }
        /**
         * calculates all-pairs shortest paths or shortest paths from a single node
         * @class Calculator
         * @constructor
         * @param n {number} number of nodes
         * @param es {Edge[]} array of edges
         */
        class Calculator {
            constructor(n, es, getSourceIndex, getTargetIndex, getLength) {
                this.n = n;
                this.es = es;
                this.neighbours = new Array(this.n);
                var i = this.n;
                while (i--)
                    this.neighbours[i] = new Node(i);
                i = this.es.length;
                while (i--) {
                    var e = this.es[i];
                    var u = getSourceIndex(e),
                        v = getTargetIndex(e);
                    var d = getLength(e);
                    this.neighbours[u].neighbours.push(new Neighbour(v, d));
                    this.neighbours[v].neighbours.push(new Neighbour(u, d));
                }
            }
            /**
             * compute shortest paths for graph over n nodes with edges an array of source/target pairs
             * edges may optionally have a length attribute.  1 is the default.
             * Uses Johnson's algorithm.
             *
             * @method DistanceMatrix
             * @return the distance matrix
             */
            DistanceMatrix() {
                var D = new Array(this.n);
                for (var i = 0; i < this.n; ++i) {
                    D[i] = this.dijkstraNeighbours(i);
                }
                return D;
            }
            /**
             * get shortest paths from a specified start node
             * @method DistancesFromNode
             * @param start node index
             * @return array of path lengths
             */
            DistancesFromNode(start) {
                return this.dijkstraNeighbours(start);
            }
            PathFromNodeToNode(start, end) {
                return this.dijkstraNeighbours(start, end);
            }
            // find shortest path from start to end, with the opportunity at
            // each edge traversal to compute a custom cost based on the
            // previous edge.  For example, to penalise bends.
            PathFromNodeToNodeWithPrevCost(start, end, prevCost) {
                var q = new pqueue_1.PriorityQueue((a, b) => a.d <= b.d),
                    u = this.neighbours[start],
                    qu = new QueueEntry(u, null, 0),
                    visitedFrom = {};
                q.push(qu);
                while (!q.empty()) {
                    qu = q.pop();
                    u = qu.node;
                    if (u.id === end) {
                        break;
                    }
                    var i = u.neighbours.length;
                    while (i--) {
                        var neighbour = u.neighbours[i],
                            v = this.neighbours[neighbour.id];
                        // don't double back
                        if (qu.prev && v.id === qu.prev.node.id)
                            continue;
                        // don't retraverse an edge if it has already been explored
                        // from a lower cost route
                        var viduid = v.id + ',' + u.id;
                        if (viduid in visitedFrom && visitedFrom[viduid] <= qu.d)
                            continue;
                        var cc = qu.prev ? prevCost(qu.prev.node.id, u.id, v.id) : 0,
                            t = qu.d + neighbour.distance + cc;
                        // store cost of this traversal
                        visitedFrom[viduid] = t;
                        q.push(new QueueEntry(v, qu, t));
                    }
                }
                var path = [];
                while (qu.prev) {
                    qu = qu.prev;
                    path.push(qu.node.id);
                }
                return path;
            }
            dijkstraNeighbours(start, dest = -1) {
                var q = new pqueue_1.PriorityQueue((a, b) => a.d <= b.d),
                    i = this.neighbours.length,
                    d = new Array(i);
                while (i--) {
                    var node = this.neighbours[i];
                    node.d = i === start ? 0 : Number.POSITIVE_INFINITY;
                    node.q = q.push(node);
                }
                while (!q.empty()) {
                    // console.log(q.toString(function (u) { return u.id + "=" + (u.d === Number.POSITIVE_INFINITY ? "\u221E" : u.d.toFixed(2) )}));
                    var u = q.pop();
                    d[u.id] = u.d;
                    if (u.id === dest) {
                        var path = [];
                        var v = u;
                        while (typeof v.prev !== 'undefined') {
                            path.push(v.prev.id);
                            v = v.prev;
                        }
                        return path;
                    }
                    i = u.neighbours.length;
                    while (i--) {
                        var neighbour = u.neighbours[i];
                        var v = this.neighbours[neighbour.id];
                        var t = u.d + neighbour.distance;
                        if (u.d !== Number.MAX_VALUE && v.d > t) {
                            v.d = t;
                            v.prev = u;
                            q.reduceKey(v.q, v, (e, q) => e.q = q);
                        }
                    }
                }
                return d;
            }
        }
        exports.Calculator = Calculator;
    }, {
        "./pqueue": 16
    }],
    20: [function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        class PositionStats {
            constructor(scale) {
                this.scale = scale;
                this.AB = 0;
                this.AD = 0;
                this.A2 = 0;
            }
            addVariable(v) {
                var ai = this.scale / v.scale;
                var bi = v.offset / v.scale;
                var wi = v.weight;
                this.AB += wi * ai * bi;
                this.AD += wi * ai * v.desiredPosition;
                this.A2 += wi * ai * ai;
            }
            getPosn() {
                return (this.AD - this.AB) / this.A2;
            }
        }
        exports.PositionStats = PositionStats;
        class Constraint {
            constructor(left, right, gap, equality = false) {
                this.left = left;
                this.right = right;
                this.gap = gap;
                this.equality = equality;
                this.active = false;
                this.unsatisfiable = false;
                this.left = left;
                this.right = right;
                this.gap = gap;
                this.equality = equality;
            }
            slack() {
                return this.unsatisfiable ? Number.MAX_VALUE :
                    this.right.scale * this.right.position() - this.gap -
                    this.left.scale * this.left.position();
            }
        }
        exports.Constraint = Constraint;
        class Variable {
            constructor(desiredPosition, weight = 1, scale = 1) {
                this.desiredPosition = desiredPosition;
                this.weight = weight;
                this.scale = scale;
                this.offset = 0;
            }
            dfdv() {
                return 2.0 * this.weight * (this.position() - this.desiredPosition);
            }
            position() {
                return (this.block.ps.scale * this.block.posn + this.offset) / this.scale;
            }
            // visit neighbours by active constraints within the same block
            visitNeighbours(prev, f) {
                var ff = (c, next) => c.active && prev !== next && f(c, next);
                this.cOut.forEach(c => ff(c, c.right));
                this.cIn.forEach(c => ff(c, c.left));
            }
        }
        exports.Variable = Variable;
        class Block {
            constructor(v) {
                this.vars = [];
                v.offset = 0;
                this.ps = new PositionStats(v.scale);
                this.addVariable(v);
            }
            addVariable(v) {
                v.block = this;
                this.vars.push(v);
                this.ps.addVariable(v);
                this.posn = this.ps.getPosn();
            }
            // move the block where it needs to be to minimize cost
            updateWeightedPosition() {
                this.ps.AB = this.ps.AD = this.ps.A2 = 0;
                for (var i = 0, n = this.vars.length; i < n; ++i)
                    this.ps.addVariable(this.vars[i]);
                this.posn = this.ps.getPosn();
            }
            compute_lm(v, u, postAction) {
                var dfdv = v.dfdv();
                v.visitNeighbours(u, (c, next) => {
                    var _dfdv = this.compute_lm(next, v, postAction);
                    if (next === c.right) {
                        dfdv += _dfdv * c.left.scale;
                        c.lm = _dfdv;
                    } else {
                        dfdv += _dfdv * c.right.scale;
                        c.lm = -_dfdv;
                    }
                    postAction(c);
                });
                return dfdv / v.scale;
            }
            populateSplitBlock(v, prev) {
                v.visitNeighbours(prev, (c, next) => {
                    next.offset = v.offset + (next === c.right ? c.gap : -c.gap);
                    this.addVariable(next);
                    this.populateSplitBlock(next, v);
                });
            }
            // traverse the active constraint tree applying visit to each active constraint
            traverse(visit, acc, v = this.vars[0], prev = null) {
                v.visitNeighbours(prev, (c, next) => {
                    acc.push(visit(c));
                    this.traverse(visit, acc, next, v);
                });
            }
            // calculate lagrangian multipliers on constraints and
            // find the active constraint in this block with the smallest lagrangian.
            // if the lagrangian is negative, then the constraint is a split candidate.
            findMinLM() {
                var m = null;
                this.compute_lm(this.vars[0], null, c => {
                    if (!c.equality && (m === null || c.lm < m.lm))
                        m = c;
                });
                return m;
            }
            findMinLMBetween(lv, rv) {
                this.compute_lm(lv, null, () => {});
                var m = null;
                this.findPath(lv, null, rv, (c, next) => {
                    if (!c.equality && c.right === next && (m === null || c.lm < m.lm))
                        m = c;
                });
                return m;
            }
            findPath(v, prev, to, visit) {
                var endFound = false;
                v.visitNeighbours(prev, (c, next) => {
                    if (!endFound && (next === to || this.findPath(next, v, to, visit))) {
                        endFound = true;
                        visit(c, next);
                    }
                });
                return endFound;
            }
            // Search active constraint tree from u to see if there is a directed path to v.
            // Returns true if path is found.
            isActiveDirectedPathBetween(u, v) {
                if (u === v)
                    return true;
                var i = u.cOut.length;
                while (i--) {
                    var c = u.cOut[i];
                    if (c.active && this.isActiveDirectedPathBetween(c.right, v))
                        return true;
                }
                return false;
            }
            // split the block into two by deactivating the specified constraint
            static split(c) {
                /* DEBUG
                            console.log("split on " + c);
                            console.assert(c.active, "attempt to split on inactive constraint");
                DEBUG */
                c.active = false;
                return [Block.createSplitBlock(c.left), Block.createSplitBlock(c.right)];
            }
            static createSplitBlock(startVar) {
                var b = new Block(startVar);
                b.populateSplitBlock(startVar, null);
                return b;
            }
            // find a split point somewhere between the specified variables
            splitBetween(vl, vr) {
                /* DEBUG
                            console.assert(vl.block === this);
                            console.assert(vr.block === this);
                DEBUG */
                var c = this.findMinLMBetween(vl, vr);
                if (c !== null) {
                    var bs = Block.split(c);
                    return {
                        constraint: c,
                        lb: bs[0],
                        rb: bs[1]
                    };
                }
                // couldn't find a split point - for example the active path is all equality constraints
                return null;
            }
            mergeAcross(b, c, dist) {
                c.active = true;
                for (var i = 0, n = b.vars.length; i < n; ++i) {
                    var v = b.vars[i];
                    v.offset += dist;
                    this.addVariable(v);
                }
                this.posn = this.ps.getPosn();
            }
            cost() {
                var sum = 0,
                    i = this.vars.length;
                while (i--) {
                    var v = this.vars[i],
                        d = v.position() - v.desiredPosition;
                    sum += d * d * v.weight;
                }
                return sum;
            }
        }
        exports.Block = Block;
        class Blocks {
            constructor(vs) {
                this.vs = vs;
                var n = vs.length;
                this.list = new Array(n);
                while (n--) {
                    var b = new Block(vs[n]);
                    this.list[n] = b;
                    b.blockInd = n;
                }
            }
            cost() {
                var sum = 0,
                    i = this.list.length;
                while (i--)
                    sum += this.list[i].cost();
                return sum;
            }
            insert(b) {
                /* DEBUG
                            console.assert(!this.contains(b), "blocks error: tried to reinsert block " + b.blockInd)
                DEBUG */
                b.blockInd = this.list.length;
                this.list.push(b);
                /* DEBUG
                            console.log("insert block: " + b.blockInd);
                            this.contains(b);
                DEBUG */
            }
            remove(b) {
                /* DEBUG
                            console.log("remove block: " + b.blockInd);
                            console.assert(this.contains(b));
                DEBUG */
                var last = this.list.length - 1;
                var swapBlock = this.list[last];
                this.list.length = last;
                if (b !== swapBlock) {
                    this.list[b.blockInd] = swapBlock;
                    swapBlock.blockInd = b.blockInd;
                    /* DEBUG
                                    console.assert(this.contains(swapBlock));
                    DEBUG */
                }
            }
            // merge the blocks on either side of the specified constraint, by copying the smaller block into the larger
            // and deleting the smaller.
            merge(c) {
                var l = c.left.block,
                    r = c.right.block;
                /* DEBUG
                            console.assert(l!==r, "attempt to merge within the same block");
                DEBUG */
                var dist = c.right.offset - c.left.offset - c.gap;
                if (l.vars.length < r.vars.length) {
                    r.mergeAcross(l, c, dist);
                    this.remove(l);
                } else {
                    l.mergeAcross(r, c, -dist);
                    this.remove(r);
                }
                /* DEBUG
                            console.assert(Math.abs(c.slack()) < 1e-6, "Error: Constraint should be at equality after merge!");
                            console.log("merged on " + c);
                DEBUG */
            }
            forEach(f) {
                this.list.forEach(f);
            }
            // useful, for example, after variable desired positions change.
            updateBlockPositions() {
                this.list.forEach(b => b.updateWeightedPosition());
            }
            // split each block across its constraint with the minimum lagrangian
            split(inactive) {
                this.updateBlockPositions();
                this.list.forEach(b => {
                    var v = b.findMinLM();
                    if (v !== null && v.lm < Solver.LAGRANGIAN_TOLERANCE) {
                        b = v.left.block;
                        Block.split(v).forEach(nb => this.insert(nb));
                        this.remove(b);
                        inactive.push(v);
                        /* DEBUG
                                            console.assert(this.contains(v.left.block));
                                            console.assert(this.contains(v.right.block));
                        DEBUG */
                    }
                });
            }
        }
        exports.Blocks = Blocks;
        class Solver {
            constructor(vs, cs) {
                this.vs = vs;
                this.cs = cs;
                this.vs = vs;
                vs.forEach(v => {
                    v.cIn = [], v.cOut = [];
                    /* DEBUG
                                    v.toString = () => "v" + vs.indexOf(v);
                    DEBUG */
                });
                this.cs = cs;
                cs.forEach(c => {
                    c.left.cOut.push(c);
                    c.right.cIn.push(c);
                    /* DEBUG
                                    c.toString = () => c.left + "+" + c.gap + "<=" + c.right + " slack=" + c.slack() + " active=" + c.active;
                    DEBUG */
                });
                this.inactive = cs.map(c => {
                    c.active = false;
                    return c;
                });
                this.bs = null;
            }
            cost() {
                return this.bs.cost();
            }
            // set starting positions without changing desired positions.
            // Note: it throws away any previous block structure.
            setStartingPositions(ps) {
                this.inactive = this.cs.map(c => {
                    c.active = false;
                    return c;
                });
                this.bs = new Blocks(this.vs);
                this.bs.forEach((b, i) => b.posn = ps[i]);
            }
            setDesiredPositions(ps) {
                this.vs.forEach((v, i) => v.desiredPosition = ps[i]);
            }
            /* DEBUG
                    private getId(v: Variable): number {
                        return this.vs.indexOf(v);
                    }
            
                    // sanity check of the index integrity of the inactive list
                    checkInactive(): void {
                        var inactiveCount = 0;
                        this.cs.forEach(c=> {
                            var i = this.inactive.indexOf(c);
                            console.assert(!c.active && i >= 0 || c.active && i < 0, "constraint should be in the inactive list if it is not active: " + c);
                            if (i >= 0) {
                                inactiveCount++;
                            } else {
                                console.assert(c.active, "inactive constraint not found in inactive list: " + c);
                            }
                        });
                        console.assert(inactiveCount === this.inactive.length, inactiveCount + " inactive constraints found, " + this.inactive.length + "in inactive list");
                    }
                    // after every call to satisfy the following should check should pass
                    checkSatisfied(): void {
                        this.cs.forEach(c=>console.assert(c.slack() >= vpsc.Solver.ZERO_UPPERBOUND, "Error: Unsatisfied constraint! "+c));
                    }
            DEBUG */
            mostViolated() {
                var minSlack = Number.MAX_VALUE,
                    v = null,
                    l = this.inactive,
                    n = l.length,
                    deletePoint = n;
                for (var i = 0; i < n; ++i) {
                    var c = l[i];
                    if (c.unsatisfiable)
                        continue;
                    var slack = c.slack();
                    if (c.equality || slack < minSlack) {
                        minSlack = slack;
                        v = c;
                        deletePoint = i;
                        if (c.equality)
                            break;
                    }
                }
                if (deletePoint !== n &&
                    (minSlack < Solver.ZERO_UPPERBOUND && !v.active || v.equality)) {
                    l[deletePoint] = l[n - 1];
                    l.length = n - 1;
                }
                return v;
            }
            // satisfy constraints by building block structure over violated constraints
            // and moving the blocks to their desired positions
            satisfy() {
                if (this.bs == null) {
                    this.bs = new Blocks(this.vs);
                }
                /* DEBUG
                            console.log("satisfy: " + this.bs);
                DEBUG */
                this.bs.split(this.inactive);
                var v = null;
                while ((v = this.mostViolated()) && (v.equality || v.slack() < Solver.ZERO_UPPERBOUND && !v.active)) {
                    var lb = v.left.block,
                        rb = v.right.block;
                    /* DEBUG
                                    console.log("most violated is: " + v);
                                    this.bs.contains(lb);
                                    this.bs.contains(rb);
                    DEBUG */
                    if (lb !== rb) {
                        this.bs.merge(v);
                    } else {
                        if (lb.isActiveDirectedPathBetween(v.right, v.left)) {
                            // cycle found!
                            v.unsatisfiable = true;
                            continue;
                        }
                        // constraint is within block, need to split first
                        var split = lb.splitBetween(v.left, v.right);
                        if (split !== null) {
                            this.bs.insert(split.lb);
                            this.bs.insert(split.rb);
                            this.bs.remove(lb);
                            this.inactive.push(split.constraint);
                        } else {
                            /* DEBUG
                                                    console.log("unsatisfiable constraint found");
                            DEBUG */
                            v.unsatisfiable = true;
                            continue;
                        }
                        if (v.slack() >= 0) {
                            /* DEBUG
                                                    console.log("violated constraint indirectly satisfied: " + v);
                            DEBUG */
                            // v was satisfied by the above split!
                            this.inactive.push(v);
                        } else {
                            /* DEBUG
                                                    console.log("merge after split:");
                            DEBUG */
                            this.bs.merge(v);
                        }
                    }
                    /* DEBUG
                                    this.bs.contains(v.left.block);
                                    this.bs.contains(v.right.block);
                                    this.checkInactive();
                    DEBUG */
                }
                /* DEBUG
                            this.checkSatisfied();
                DEBUG */
            }
            // repeatedly build and split block structure until we converge to an optimal solution
            solve() {
                this.satisfy();
                var lastcost = Number.MAX_VALUE,
                    cost = this.bs.cost();
                while (Math.abs(lastcost - cost) > 0.0001) {
                    this.satisfy();
                    lastcost = cost;
                    cost = this.bs.cost();
                }
                return cost;
            }
        }
        Solver.LAGRANGIAN_TOLERANCE = -1e-4;
        Solver.ZERO_UPPERBOUND = -1e-10;
        exports.Solver = Solver;
        /**
         * Remove overlap between spans while keeping their centers as close as possible to the specified desiredCenters.
         * Lower and upper bounds will be respected if the spans physically fit between them
         * (otherwise they'll be moved and their new position returned).
         * If no upper/lower bound is specified then the bounds of the moved spans will be returned.
         * returns a new center for each span.
         */
        function removeOverlapInOneDimension(spans, lowerBound, upperBound) {
            const vs = spans.map(s => new Variable(s.desiredCenter));
            const cs = [];
            const n = spans.length;
            for (var i = 0; i < n - 1; i++) {
                const left = spans[i],
                    right = spans[i + 1];
                cs.push(new Constraint(vs[i], vs[i + 1], (left.size + right.size) / 2));
            }
            const leftMost = vs[0],
                rightMost = vs[n - 1],
                leftMostSize = spans[0].size / 2,
                rightMostSize = spans[n - 1].size / 2;
            let vLower = null,
                vUpper = null;
            if (lowerBound) {
                vLower = new Variable(lowerBound, leftMost.weight * 1000);
                vs.push(vLower);
                cs.push(new Constraint(vLower, leftMost, leftMostSize));
            }
            if (upperBound) {
                vUpper = new Variable(upperBound, rightMost.weight * 1000);
                vs.push(vUpper);
                cs.push(new Constraint(rightMost, vUpper, rightMostSize));
            }
            var solver = new Solver(vs, cs);
            solver.solve();
            return {
                newCenters: vs.slice(0, spans.length).map(v => v.position()),
                lowerBound: vLower ? vLower.position() : leftMost.position() - leftMostSize,
                upperBound: vUpper ? vUpper.position() : rightMost.position() + rightMostSize
            };
        }
        exports.removeOverlapInOneDimension = removeOverlapInOneDimension;
    }, {}],
    21: [function(require, module, exports) {
        var read = require("./lib/read-one"),
            readMany = require("./lib/read-many"),
            write = require("./lib/write-one"),
            version = require("./lib/version");

        module.exports = {
            graphlib: require("./lib/graphlib"),

            // Parsing
            read: read,
            readMany: readMany,

            // Writing
            write: write,

            // Version
            version: version,

            // For levelup encoding
            type: "dot",
            buffer: false
        };

    }, {
        "./lib/graphlib": 24,
        "./lib/read-many": 26,
        "./lib/read-one": 27,
        "./lib/version": 28,
        "./lib/write-one": 29
    }],
    22: [function(require, module, exports) {
        "use strict";

        var _ = require("./lodash"),
            Graph = require("./graphlib").Graph;

        module.exports = buildGraph;

        function buildGraph(parseTree) {
            var isDirected = parseTree.type !== "graph",
                isMultigraph = !parseTree.strict,
                defaultStack = [{
                    node: {},
                    edge: {}
                }],
                id = parseTree.id,
                g = new Graph({
                    directed: isDirected,
                    multigraph: isMultigraph,
                    compound: true
                });
            g.setGraph(id === null ? {} : {
                id: id
            });
            _.each(parseTree.stmts, function(stmt) {
                handleStmt(g, stmt, defaultStack);
            });
            return g;
        }

        function handleStmt(g, stmt, defaultStack, sg) {
            switch (stmt.type) {
                case "node":
                    handleNodeStmt(g, stmt, defaultStack, sg);
                    break;
                case "edge":
                    handleEdgeStmt(g, stmt, defaultStack, sg);
                    break;
                case "subgraph":
                    handleSubgraphStmt(g, stmt, defaultStack, sg);
                    break;
                case "attr":
                    handleAttrStmt(g, stmt, defaultStack);
                    break;
                case "inlineAttr":
                    handleInlineAttrsStmt(g, stmt, defaultStack, sg);
                    break;
            }
        }

        function handleNodeStmt(g, stmt, defaultStack, sg) {
            var v = stmt.id,
                attrs = stmt.attrs;
            maybeCreateNode(g, v, defaultStack, sg);
            _.merge(g.node(v), attrs);
        }

        function handleEdgeStmt(g, stmt, defaultStack, sg) {
            var attrs = stmt.attrs,
                prev, curr;
            _.each(stmt.elems, function(elem) {
                handleStmt(g, elem, defaultStack, sg);

                switch (elem.type) {
                    case "node":
                        curr = [elem.id];
                        break;
                    case "subgraph":
                        curr = collectNodeIds(elem);
                        break;
                }

                _.each(prev, function(v) {
                    _.each(curr, function(w) {
                        var name;
                        if (g.hasEdge(v, w) && g.isMultigraph()) {
                            name = _.uniqueId("edge");
                        }
                        if (!g.hasEdge(v, w, name)) {
                            g.setEdge(v, w, _.clone(_.last(defaultStack).edge), name);
                        }
                        _.merge(g.edge(v, w, name), attrs);
                    });
                });

                prev = curr;
            });
        }

        function handleSubgraphStmt(g, stmt, defaultStack, sg) {
            var id = stmt.id;
            if (id === undefined) {
                id = generateSubgraphId(g);
            }

            defaultStack.push(_.clone(_.last(defaultStack)));

            maybeCreateNode(g, id, defaultStack, sg);

            _.each(stmt.stmts, function(s) {
                handleStmt(g, s, defaultStack, id);
            });

            // If there are no statements remove the subgraph
            if (!g.children(id).length) {
                g.removeNode(id);
            }

            defaultStack.pop();
        }

        function handleAttrStmt(g, stmt, defaultStack) {
            _.merge(_.last(defaultStack)[stmt.attrType], stmt.attrs);
        }

        function handleInlineAttrsStmt(g, stmt, defaultStack, sg) {
            _.merge(sg ? g.node(sg) : g.graph(), stmt.attrs);
        }

        function generateSubgraphId(g) {
            var id;
            do {
                id = _.uniqueId("sg");
            } while (g.hasNode(id));
            return id;
        }

        function maybeCreateNode(g, v, defaultStack, sg) {
            if (!g.hasNode(v)) {
                g.setNode(v, _.clone(_.last(defaultStack).node));
                g.setParent(v, sg);
            }
        }

        // Collect all nodes involved in a subgraph statement
        function collectNodeIds(stmt) {
            var ids = {},
                stack = [],
                curr;

            var push = stack.push.bind(stack);

            push(stmt);
            while (stack.length) {
                curr = stack.pop();
                switch (curr.type) {
                    case "node":
                        ids[curr.id] = true;
                        break;
                    case "edge":
                        _.each(curr.elems, push);
                        break;
                    case "subgraph":
                        _.each(curr.stmts, push);
                        break;
                }
            }

            return _.keys(ids);
        }


    }, {
        "./graphlib": 24,
        "./lodash": 25
    }],
    23: [function(require, module, exports) {
        module.exports = (function() {
            /*
             * Generated by PEG.js 0.8.0.
             *
             * http://pegjs.majda.cz/
             */

            function peg$subclass(child, parent) {
                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
            }

            function SyntaxError(message, expected, found, offset, line, column) {
                this.message = message;
                this.expected = expected;
                this.found = found;
                this.offset = offset;
                this.line = line;
                this.column = column;

                this.name = "SyntaxError";
            }

            peg$subclass(SyntaxError, Error);

            function parse(input) {
                var options = arguments.length > 1 ? arguments[1] : {},

                    peg$FAILED = {},

                    peg$startRuleFunctions = {
                        start: peg$parsestart,
                        graphStmt: peg$parsegraphStmt
                    },
                    peg$startRuleFunction = peg$parsestart,

                    peg$c0 = [],
                    peg$c1 = peg$FAILED,
                    peg$c2 = null,
                    peg$c3 = "{",
                    peg$c4 = {
                        type: "literal",
                        value: "{",
                        description: "\"{\""
                    },
                    peg$c5 = "}",
                    peg$c6 = {
                        type: "literal",
                        value: "}",
                        description: "\"}\""
                    },
                    peg$c7 = function(strict, type, id, stmts) {
                        return {
                            type: type,
                            id: id,
                            strict: strict !== null,
                            stmts: stmts
                        };
                    },
                    peg$c8 = ";",
                    peg$c9 = {
                        type: "literal",
                        value: ";",
                        description: "\";\""
                    },
                    peg$c10 = function(first, rest) {
                        var result = [first];
                        for (var i = 0; i < rest.length; ++i) {
                            result.push(rest[i][1]);
                        }
                        return result;
                    },
                    peg$c11 = function(type, attrs) {
                        return {
                            type: "attr",
                            attrType: type,
                            attrs: attrs || {}
                        };
                    },
                    peg$c12 = "=",
                    peg$c13 = {
                        type: "literal",
                        value: "=",
                        description: "\"=\""
                    },
                    peg$c14 = function(k, v) {
                        var attrs = {};
                        attrs[k] = v;
                        return {
                            type: "inlineAttr",
                            attrs: attrs
                        };
                    },
                    peg$c15 = function(id, attrs) {
                        return {
                            type: "node",
                            id: id,
                            attrs: attrs || {}
                        };
                    },
                    peg$c16 = function(lhs, rhs, attrs) {
                        var elems = [lhs];
                        for (var i = 0; i < rhs.length; ++i) {
                            elems.push(rhs[i]);
                        }
                        return {
                            type: "edge",
                            elems: elems,
                            attrs: attrs || {}
                        };
                    },
                    peg$c17 = function(id, stmts) {
                        id = (id && id[2]) || [];
                        return {
                            type: "subgraph",
                            id: id[0],
                            stmts: stmts
                        };
                    },
                    peg$c18 = function(first, rest) {
                        var result = first;
                        for (var i = 0; i < rest.length; ++i) {
                            _.merge(result, rest[i][1]);
                        }
                        return result;
                    },
                    peg$c19 = "[",
                    peg$c20 = {
                        type: "literal",
                        value: "[",
                        description: "\"[\""
                    },
                    peg$c21 = "]",
                    peg$c22 = {
                        type: "literal",
                        value: "]",
                        description: "\"]\""
                    },
                    peg$c23 = function(aList) {
                        return aList;
                    },
                    peg$c24 = ",",
                    peg$c25 = {
                        type: "literal",
                        value: ",",
                        description: "\",\""
                    },
                    peg$c26 = function(first, rest) {
                        var result = first;
                        for (var i = 0; i < rest.length; ++i) {
                            _.merge(result, rest[i][3]);
                        }
                        return result;
                    },
                    peg$c27 = "--",
                    peg$c28 = {
                        type: "literal",
                        value: "--",
                        description: "\"--\""
                    },
                    peg$c29 = function() {
                        return directed;
                    },
                    peg$c30 = void 0,
                    peg$c31 = "->",
                    peg$c32 = {
                        type: "literal",
                        value: "->",
                        description: "\"->\""
                    },
                    peg$c33 = function(rhs, rest) {
                        var result = [rhs];
                        if (rest) {
                            for (var i = 0; i < rest.length; ++i) {
                                result.push(rest[i]);
                            }
                        }
                        return result;
                    },
                    peg$c34 = function(k, v) {
                        var result = {};
                        result[k] = v[3];
                        return result;
                    },
                    peg$c35 = function(id) {
                        return {
                            type: "node",
                            id: id,
                            attrs: {}
                        };
                    },
                    peg$c36 = function(id) {
                        return id;
                    },
                    peg$c37 = ":",
                    peg$c38 = {
                        type: "literal",
                        value: ":",
                        description: "\":\""
                    },
                    peg$c39 = "ne",
                    peg$c40 = {
                        type: "literal",
                        value: "ne",
                        description: "\"ne\""
                    },
                    peg$c41 = "se",
                    peg$c42 = {
                        type: "literal",
                        value: "se",
                        description: "\"se\""
                    },
                    peg$c43 = "sw",
                    peg$c44 = {
                        type: "literal",
                        value: "sw",
                        description: "\"sw\""
                    },
                    peg$c45 = "nw",
                    peg$c46 = {
                        type: "literal",
                        value: "nw",
                        description: "\"nw\""
                    },
                    peg$c47 = "n",
                    peg$c48 = {
                        type: "literal",
                        value: "n",
                        description: "\"n\""
                    },
                    peg$c49 = "e",
                    peg$c50 = {
                        type: "literal",
                        value: "e",
                        description: "\"e\""
                    },
                    peg$c51 = "s",
                    peg$c52 = {
                        type: "literal",
                        value: "s",
                        description: "\"s\""
                    },
                    peg$c53 = "w",
                    peg$c54 = {
                        type: "literal",
                        value: "w",
                        description: "\"w\""
                    },
                    peg$c55 = "c",
                    peg$c56 = {
                        type: "literal",
                        value: "c",
                        description: "\"c\""
                    },
                    peg$c57 = "_",
                    peg$c58 = {
                        type: "literal",
                        value: "_",
                        description: "\"_\""
                    },
                    peg$c59 = {
                        type: "other",
                        description: "identifier"
                    },
                    peg$c60 = /^[a-zA-Z\u0200-\u0377_]/,
                    peg$c61 = {
                        type: "class",
                        value: "[a-zA-Z\\u0200-\\u0377_]",
                        description: "[a-zA-Z\\u0200-\\u0377_]"
                    },
                    peg$c62 = /^[a-zA-Z\u0200-\u0377_0-9]/,
                    peg$c63 = {
                        type: "class",
                        value: "[a-zA-Z\\u0200-\\u0377_0-9]",
                        description: "[a-zA-Z\\u0200-\\u0377_0-9]"
                    },
                    peg$c64 = function(fst, rest) {
                        return fst + rest.join("");
                    },
                    peg$c65 = "-",
                    peg$c66 = {
                        type: "literal",
                        value: "-",
                        description: "\"-\""
                    },
                    peg$c67 = ".",
                    peg$c68 = {
                        type: "literal",
                        value: ".",
                        description: "\".\""
                    },
                    peg$c69 = /^[0-9]/,
                    peg$c70 = {
                        type: "class",
                        value: "[0-9]",
                        description: "[0-9]"
                    },
                    peg$c71 = function(sign, dot, after) {
                        return (sign || "") + dot + after.join("");
                    },
                    peg$c72 = function(sign, before, after) {
                        return (sign || "") + before.join("") + (after ? after[0] : "") + (after ? after[1].join("") : "");
                    },
                    peg$c73 = "\"",
                    peg$c74 = {
                        type: "literal",
                        value: "\"",
                        description: "\"\\\"\""
                    },
                    peg$c75 = "\\\"",
                    peg$c76 = {
                        type: "literal",
                        value: "\\\"",
                        description: "\"\\\\\\\"\""
                    },
                    peg$c77 = function() {
                        return '"';
                    },
                    peg$c78 = "\\",
                    peg$c79 = {
                        type: "literal",
                        value: "\\",
                        description: "\"\\\\\""
                    },
                    peg$c80 = /^[^"]/,
                    peg$c81 = {
                        type: "class",
                        value: "[^\"]",
                        description: "[^\"]"
                    },
                    peg$c82 = function(ch) {
                        return "\\" + ch;
                    },
                    peg$c83 = function(id) {
                        return id.join("");
                    },
                    peg$c84 = "node",
                    peg$c85 = {
                        type: "literal",
                        value: "node",
                        description: "\"node\""
                    },
                    peg$c86 = function(k) {
                        return k.toLowerCase();
                    },
                    peg$c87 = "edge",
                    peg$c88 = {
                        type: "literal",
                        value: "edge",
                        description: "\"edge\""
                    },
                    peg$c89 = "graph",
                    peg$c90 = {
                        type: "literal",
                        value: "graph",
                        description: "\"graph\""
                    },
                    peg$c91 = "digraph",
                    peg$c92 = {
                        type: "literal",
                        value: "digraph",
                        description: "\"digraph\""
                    },
                    peg$c93 = "subgraph",
                    peg$c94 = {
                        type: "literal",
                        value: "subgraph",
                        description: "\"subgraph\""
                    },
                    peg$c95 = "strict",
                    peg$c96 = {
                        type: "literal",
                        value: "strict",
                        description: "\"strict\""
                    },
                    peg$c97 = function(graph) {
                        directed = graph === "digraph";
                        return graph;
                    },
                    peg$c98 = {
                        type: "other",
                        description: "whitespace"
                    },
                    peg$c99 = /^[ \t\r\n]/,
                    peg$c100 = {
                        type: "class",
                        value: "[ \\t\\r\\n]",
                        description: "[ \\t\\r\\n]"
                    },
                    peg$c101 = {
                        type: "other",
                        description: "comment"
                    },
                    peg$c102 = "//",
                    peg$c103 = {
                        type: "literal",
                        value: "//",
                        description: "\"//\""
                    },
                    peg$c104 = /^[^\n]/,
                    peg$c105 = {
                        type: "class",
                        value: "[^\\n]",
                        description: "[^\\n]"
                    },
                    peg$c106 = "/*",
                    peg$c107 = {
                        type: "literal",
                        value: "/*",
                        description: "\"/*\""
                    },
                    peg$c108 = "*/",
                    peg$c109 = {
                        type: "literal",
                        value: "*/",
                        description: "\"*/\""
                    },
                    peg$c110 = {
                        type: "any",
                        description: "any character"
                    },

                    peg$currPos = 0,
                    peg$reportedPos = 0,
                    peg$cachedPos = 0,
                    peg$cachedPosDetails = {
                        line: 1,
                        column: 1,
                        seenCR: false
                    },
                    peg$maxFailPos = 0,
                    peg$maxFailExpected = [],
                    peg$silentFails = 0,

                    peg$result;

                if ("startRule" in options) {
                    if (!(options.startRule in peg$startRuleFunctions)) {
                        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
                    }

                    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
                }

                function text() {
                    return input.substring(peg$reportedPos, peg$currPos);
                }

                function offset() {
                    return peg$reportedPos;
                }

                function line() {
                    return peg$computePosDetails(peg$reportedPos).line;
                }

                function column() {
                    return peg$computePosDetails(peg$reportedPos).column;
                }

                function expected(description) {
                    throw peg$buildException(
                        null,
                        [{
                            type: "other",
                            description: description
                        }],
                        peg$reportedPos
                    );
                }

                function error(message) {
                    throw peg$buildException(message, null, peg$reportedPos);
                }

                function peg$computePosDetails(pos) {
                    function advance(details, startPos, endPos) {
                        var p, ch;

                        for (p = startPos; p < endPos; p++) {
                            ch = input.charAt(p);
                            if (ch === "\n") {
                                if (!details.seenCR) {
                                    details.line++;
                                }
                                details.column = 1;
                                details.seenCR = false;
                            } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
                                details.line++;
                                details.column = 1;
                                details.seenCR = true;
                            } else {
                                details.column++;
                                details.seenCR = false;
                            }
                        }
                    }

                    if (peg$cachedPos !== pos) {
                        if (peg$cachedPos > pos) {
                            peg$cachedPos = 0;
                            peg$cachedPosDetails = {
                                line: 1,
                                column: 1,
                                seenCR: false
                            };
                        }
                        advance(peg$cachedPosDetails, peg$cachedPos, pos);
                        peg$cachedPos = pos;
                    }

                    return peg$cachedPosDetails;
                }

                function peg$fail(expected) {
                    if (peg$currPos < peg$maxFailPos) {
                        return;
                    }

                    if (peg$currPos > peg$maxFailPos) {
                        peg$maxFailPos = peg$currPos;
                        peg$maxFailExpected = [];
                    }

                    peg$maxFailExpected.push(expected);
                }

                function peg$buildException(message, expected, pos) {
                    function cleanupExpected(expected) {
                        var i = 1;

                        expected.sort(function(a, b) {
                            if (a.description < b.description) {
                                return -1;
                            } else if (a.description > b.description) {
                                return 1;
                            } else {
                                return 0;
                            }
                        });

                        while (i < expected.length) {
                            if (expected[i - 1] === expected[i]) {
                                expected.splice(i, 1);
                            } else {
                                i++;
                            }
                        }
                    }

                    function buildMessage(expected, found) {
                        function stringEscape(s) {
                            function hex(ch) {
                                return ch.charCodeAt(0).toString(16).toUpperCase();
                            }

                            return s
                                .replace(/\\/g, '\\\\')
                                .replace(/"/g, '\\"')
                                .replace(/\x08/g, '\\b')
                                .replace(/\t/g, '\\t')
                                .replace(/\n/g, '\\n')
                                .replace(/\f/g, '\\f')
                                .replace(/\r/g, '\\r')
                                .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
                                    return '\\x0' + hex(ch);
                                })
                                .replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
                                    return '\\x' + hex(ch);
                                })
                                .replace(/[\u0180-\u0FFF]/g, function(ch) {
                                    return '\\u0' + hex(ch);
                                })
                                .replace(/[\u1080-\uFFFF]/g, function(ch) {
                                    return '\\u' + hex(ch);
                                });
                        }

                        var expectedDescs = new Array(expected.length),
                            expectedDesc, foundDesc, i;

                        for (i = 0; i < expected.length; i++) {
                            expectedDescs[i] = expected[i].description;
                        }

                        expectedDesc = expected.length > 1 ?
                            expectedDescs.slice(0, -1).join(", ") +
                            " or " +
                            expectedDescs[expected.length - 1] :
                            expectedDescs[0];

                        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

                        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
                    }

                    var posDetails = peg$computePosDetails(pos),
                        found = pos < input.length ? input.charAt(pos) : null;

                    if (expected !== null) {
                        cleanupExpected(expected);
                    }

                    return new SyntaxError(
                        message !== null ? message : buildMessage(expected, found),
                        expected,
                        found,
                        pos,
                        posDetails.line,
                        posDetails.column
                    );
                }

                function peg$parsestart() {
                    var s0, s1;

                    s0 = [];
                    s1 = peg$parsegraphStmt();
                    if (s1 !== peg$FAILED) {
                        while (s1 !== peg$FAILED) {
                            s0.push(s1);
                            s1 = peg$parsegraphStmt();
                        }
                    } else {
                        s0 = peg$c1;
                    }

                    return s0;
                }

                function peg$parsegraphStmt() {
                    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;

                    s0 = peg$currPos;
                    s1 = [];
                    s2 = peg$parse_();
                    while (s2 !== peg$FAILED) {
                        s1.push(s2);
                        s2 = peg$parse_();
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        s3 = peg$parsestrict();
                        if (s3 !== peg$FAILED) {
                            s4 = peg$parse_();
                            if (s4 !== peg$FAILED) {
                                s3 = [s3, s4];
                                s2 = s3;
                            } else {
                                peg$currPos = s2;
                                s2 = peg$c1;
                            }
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c1;
                        }
                        if (s2 === peg$FAILED) {
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            s3 = peg$parsegraphType();
                            if (s3 !== peg$FAILED) {
                                s4 = [];
                                s5 = peg$parse_();
                                while (s5 !== peg$FAILED) {
                                    s4.push(s5);
                                    s5 = peg$parse_();
                                }
                                if (s4 !== peg$FAILED) {
                                    s5 = peg$parseid();
                                    if (s5 === peg$FAILED) {
                                        s5 = peg$c2;
                                    }
                                    if (s5 !== peg$FAILED) {
                                        s6 = [];
                                        s7 = peg$parse_();
                                        while (s7 !== peg$FAILED) {
                                            s6.push(s7);
                                            s7 = peg$parse_();
                                        }
                                        if (s6 !== peg$FAILED) {
                                            if (input.charCodeAt(peg$currPos) === 123) {
                                                s7 = peg$c3;
                                                peg$currPos++;
                                            } else {
                                                s7 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c4);
                                                }
                                            }
                                            if (s7 !== peg$FAILED) {
                                                s8 = [];
                                                s9 = peg$parse_();
                                                while (s9 !== peg$FAILED) {
                                                    s8.push(s9);
                                                    s9 = peg$parse_();
                                                }
                                                if (s8 !== peg$FAILED) {
                                                    s9 = peg$parsestmtList();
                                                    if (s9 === peg$FAILED) {
                                                        s9 = peg$c2;
                                                    }
                                                    if (s9 !== peg$FAILED) {
                                                        s10 = [];
                                                        s11 = peg$parse_();
                                                        while (s11 !== peg$FAILED) {
                                                            s10.push(s11);
                                                            s11 = peg$parse_();
                                                        }
                                                        if (s10 !== peg$FAILED) {
                                                            if (input.charCodeAt(peg$currPos) === 125) {
                                                                s11 = peg$c5;
                                                                peg$currPos++;
                                                            } else {
                                                                s11 = peg$FAILED;
                                                                if (peg$silentFails === 0) {
                                                                    peg$fail(peg$c6);
                                                                }
                                                            }
                                                            if (s11 !== peg$FAILED) {
                                                                s12 = [];
                                                                s13 = peg$parse_();
                                                                while (s13 !== peg$FAILED) {
                                                                    s12.push(s13);
                                                                    s13 = peg$parse_();
                                                                }
                                                                if (s12 !== peg$FAILED) {
                                                                    peg$reportedPos = s0;
                                                                    s1 = peg$c7(s2, s3, s5, s9);
                                                                    s0 = s1;
                                                                } else {
                                                                    peg$currPos = s0;
                                                                    s0 = peg$c1;
                                                                }
                                                            } else {
                                                                peg$currPos = s0;
                                                                s0 = peg$c1;
                                                            }
                                                        } else {
                                                            peg$currPos = s0;
                                                            s0 = peg$c1;
                                                        }
                                                    } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$c1;
                                                    }
                                                } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$c1;
                                                }
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$c1;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$c1;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c1;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c1;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c1;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c1;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c1;
                    }

                    return s0;
                }

                function peg$parsestmtList() {
                    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

                    s0 = peg$currPos;
                    s1 = peg$parsestmt();
                    if (s1 !== peg$FAILED) {
                        s2 = [];
                        s3 = peg$parse_();
                        while (s3 !== peg$FAILED) {
                            s2.push(s3);
                            s3 = peg$parse_();
                        }
                        if (s2 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 59) {
                                s3 = peg$c8;
                                peg$currPos++;
                            } else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c9);
                                }
                            }
                            if (s3 === peg$FAILED) {
                                s3 = peg$c2;
                            }
                            if (s3 !== peg$FAILED) {
                                s4 = [];
                                s5 = peg$currPos;
                                s6 = [];
                                s7 = peg$parse_();
                                while (s7 !== peg$FAILED) {
                                    s6.push(s7);
                                    s7 = peg$parse_();
                                }
                                if (s6 !== peg$FAILED) {
                                    s7 = peg$parsestmt();
                                    if (s7 !== peg$FAILED) {
                                        s8 = [];
                                        s9 = peg$parse_();
                                        while (s9 !== peg$FAILED) {
                                            s8.push(s9);
                                            s9 = peg$parse_();
                                        }
                                        if (s8 !== peg$FAILED) {
                                            if (input.charCodeAt(peg$currPos) === 59) {
                                                s9 = peg$c8;
                                                peg$currPos++;
                                            } else {
                                                s9 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c9);
                                                }
                                            }
                                            if (s9 === peg$FAILED) {
                                                s9 = peg$c2;
                                            }
                                            if (s9 !== peg$FAILED) {
                                                s6 = [s6, s7, s8, s9];
                                                s5 = s6;
                                            } else {
                                                peg$currPos = s5;
                                                s5 = peg$c1;
                                            }
                                        } else {
                                            peg$currPos = s5;
                                            s5 = peg$c1;
                                        }
                                    } else {
                                        peg$currPos = s5;
                                        s5 = peg$c1;
                                    }
                                } else {
                                    peg$currPos = s5;
                                    s5 = peg$c1;
                                }
                                while (s5 !== peg$FAILED) {
                                    s4.push(s5);
                                    s5 = peg$currPos;
                                    s6 = [];
                                    s7 = peg$parse_();
                                    while (s7 !== peg$FAILED) {
                                        s6.push(s7);
                                        s7 = peg$parse_();
                                    }
                                    if (s6 !== peg$FAILED) {
                                        s7 = peg$parsestmt();
                                        if (s7 !== peg$FAILED) {
                                            s8 = [];
                                            s9 = peg$parse_();
                                            while (s9 !== peg$FAILED) {
                                                s8.push(s9);
                                                s9 = peg$parse_();
                                            }
                                            if (s8 !== peg$FAILED) {
                                                if (input.charCodeAt(peg$currPos) === 59) {
                                                    s9 = peg$c8;
                                                    peg$currPos++;
                                                } else {
                                                    s9 = peg$FAILED;
                                                    if (peg$silentFails === 0) {
                                                        peg$fail(peg$c9);
                                                    }
                                                }
                                                if (s9 === peg$FAILED) {
                                                    s9 = peg$c2;
                                                }
                                                if (s9 !== peg$FAILED) {
                                                    s6 = [s6, s7, s8, s9];
                                                    s5 = s6;
                                                } else {
                                                    peg$currPos = s5;
                                                    s5 = peg$c1;
                                                }
                                            } else {
                                                peg$currPos = s5;
                                                s5 = peg$c1;
                                            }
                                        } else {
                                            peg$currPos = s5;
                                            s5 = peg$c1;
                                        }
                                    } else {
                                        peg$currPos = s5;
                                        s5 = peg$c1;
                                    }
                                }
                                if (s4 !== peg$FAILED) {
                                    peg$reportedPos = s0;
                                    s1 = peg$c10(s1, s4);
                                    s0 = s1;
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c1;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c1;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c1;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c1;
                    }

                    return s0;
                }

                function peg$parsestmt() {
                    var s0;

                    s0 = peg$parseattrStmt();
                    if (s0 === peg$FAILED) {
                        s0 = peg$parseedgeStmt();
                        if (s0 === peg$FAILED) {
                            s0 = peg$parsesubgraphStmt();
                            if (s0 === peg$FAILED) {
                                s0 = peg$parseinlineAttrStmt();
                                if (s0 === peg$FAILED) {
                                    s0 = peg$parsenodeStmt();
                                }
                            }
                        }
                    }

                    return s0;
                }

                function peg$parseattrStmt() {
                    var s0, s1, s2, s3;

                    s0 = peg$currPos;
                    s1 = peg$parsegraph();
                    if (s1 === peg$FAILED) {
                        s1 = peg$parsenode();
                        if (s1 === peg$FAILED) {
                            s1 = peg$parseedge();
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = [];
                        s3 = peg$parse_();
                        while (s3 !== peg$FAILED) {
                            s2.push(s3);
                            s3 = peg$parse_();
                        }
                        if (s2 !== peg$FAILED) {
                            s3 = peg$parseattrList();
                            if (s3 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c11(s1, s3);
                                s0 = s1;
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c1;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c1;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c1;
                    }

                    return s0;
                }

                function peg$parseinlineAttrStmt() {
                    var s0, s1, s2, s3, s4, s5;

                    s0 = peg$currPos;
                    s1 = peg$parseid();
                    if (s1 !== peg$FAILED) {
                        s2 = [];
                        s3 = peg$parse_();
                        while (s3 !== peg$FAILED) {
                            s2.push(s3);
                            s3 = peg$parse_();
                        }
                        if (s2 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 61) {
                                s3 = peg$c12;
                                peg$currPos++;
                            } else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c13);
                                }
                            }
                            if (s3 !== peg$FAILED) {
                                s4 = [];
                                s5 = peg$parse_();
                                while (s5 !== peg$FAILED) {
                                    s4.push(s5);
                                    s5 = peg$parse_();
                                }
                                if (s4 !== peg$FAILED) {
                                    s5 = peg$parseid();
                                    if (s5 !== peg$FAILED) {
                                        peg$reportedPos = s0;
                                        s1 = peg$c14(s1, s5);
                                        s0 = s1;
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c1;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c1;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c1;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c1;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c1;
                    }

                    return s0;
                }

                function peg$parsenodeStmt() {
                    var s0, s1, s2, s3;

                    s0 = peg$currPos;
                    s1 = peg$parsenodeId();
                    if (s1 !== peg$FAILED) {
                        s2 = [];
                        s3 = peg$parse_();
                        while (s3 !== peg$FAILED) {
                            s2.push(s3);
                            s3 = peg$parse_();
                        }
                        if (s2 !== peg$FAILED) {
                            s3 = peg$parseattrList();
                            if (s3 === peg$FAILED) {
                                s3 = peg$c2;
                            }
                            if (s3 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c15(s1, s3);
                                s0 = s1;
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c1;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c1;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c1;
                    }

                    return s0;
                }

                function peg$parseedgeStmt() {
                    var s0, s1, s2, s3, s4, s5;

                    s0 = peg$currPos;
                    s1 = peg$parsenodeIdOrSubgraph();
                    if (s1 !== peg$FAILED) {
                        s2 = [];
                        s3 = peg$parse_();
                        while (s3 !== peg$FAILED) {
                            s2.push(s3);
                            s3 = peg$parse_();
                        }
                        if (s2 !== peg$FAILED) {
                            s3 = peg$parseedgeRHS();
                            if (s3 !== peg$FAILED) {
                                s4 = [];
                                s5 = peg$parse_();
                                while (s5 !== peg$FAILED) {
                                    s4.push(s5);
                                    s5 = peg$parse_();
                                }
                                if (s4 !== peg$FAILED) {
                                    s5 = peg$parseattrList();
                                    if (s5 === peg$FAILED) {
                                        s5 = peg$c2;
                                    }
                                    if (s5 !== peg$FAILED) {
                                        peg$reportedPos = s0;
                                        s1 = peg$c16(s1, s3, s5);
                                        s0 = s1;
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c1;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c1;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c1;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c1;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c1;
                    }

                    return s0;
                }

                function peg$parsesubgraphStmt() {
                    var s0, s1, s2, s3, s4, s5, s6, s7;

                    s0 = peg$currPos;
                    s1 = peg$currPos;
                    s2 = peg$parsesubgraph();
                    if (s2 !== peg$FAILED) {
                        s3 = [];
                        s4 = peg$parse_();
                        while (s4 !== peg$FAILED) {
                            s3.push(s4);
                            s4 = peg$parse_();
                        }
                        if (s3 !== peg$FAILED) {
                            s4 = peg$currPos;
                            s5 = peg$parseid();
                            if (s5 !== peg$FAILED) {
                                s6 = [];
                                s7 = peg$parse_();
                                while (s7 !== peg$FAILED) {
                                    s6.push(s7);
                                    s7 = peg$parse_();
                                }
                                if (s6 !== peg$FAILED) {
                                    s5 = [s5, s6];
                                    s4 = s5;
                                } else {
                                    peg$currPos = s4;
                                    s4 = peg$c1;
                                }
                            } else {
                                peg$currPos = s4;
                                s4 = peg$c1;
                            }
                            if (s4 === peg$FAILED) {
                                s4 = peg$c2;
                            }
                            if (s4 !== peg$FAILED) {
                                s2 = [s2, s3, s4];
                                s1 = s2;
                            } else {
                                peg$currPos = s1;
                                s1 = peg$c1;
                            }
                        } else {
                            peg$currPos = s1;
                            s1 = peg$c1;
                        }
                    } else {
                        peg$currPos = s1;
                        s1 = peg$c1;
                    }
                    if (s1 === peg$FAILED) {
                        s1 = peg$c2;
                    }
                    if (s1 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 123) {
                            s2 = peg$c3;
                            peg$currPos++;
                        } else {
                            s2 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c4);
                            }
                        }
                        if (s2 !== peg$FAILED) {
                            s3 = [];
                            s4 = peg$parse_();
                            while (s4 !== peg$FAILED) {
                                s3.push(s4);
                                s4 = peg$parse_();
                            }
                            if (s3 !== peg$FAILED) {
                                s4 = peg$parsestmtList();
                                if (s4 === peg$FAILED) {
                                    s4 = peg$c2;
                                }
                                if (s4 !== peg$FAILED) {
                                    s5 = [];
                                    s6 = peg$parse_();
                                    while (s6 !== peg$FAILED) {
                                        s5.push(s6);
                                        s6 = peg$parse_();
                                    }
                                    if (s5 !== peg$FAILED) {
                                        if (input.charCodeAt(peg$currPos) === 125) {
                                            s6 = peg$c5;
                                            peg$currPos++;
                                        } else {
                                            s6 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c6);
                                            }
                                        }
                                        if (s6 !== peg$FAILED) {
                                            peg$reportedPos = s0;
                                            s1 = peg$c17(s1, s4);
                                            s0 = s1;
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$c1;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c1;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c1;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c1;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c1;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c1;
                    }

                    return s0;
                }

                function peg$parseattrList() {
                    var s0, s1, s2, s3, s4, s5;

                    s0 = peg$currPos;
                    s1 = peg$parseattrListBlock();
                    if (s1 !== peg$FAILED) {
                        s2 = [];
                        s3 = peg$currPos;
                        s4 = [];
                        s5 = peg$parse_();
                        while (s5 !== peg$FAILED) {
                            s4.push(s5);
                            s5 = peg$parse_();
                        }
                        if (s4 !== peg$FAILED) {
                            s5 = peg$parseattrListBlock();
                            if (s5 !== peg$FAILED) {
                                s4 = [s4, s5];
                                s3 = s4;
                            } else {
                                peg$currPos = s3;
                                s3 = peg$c1;
                            }
                        } else {
                            peg$currPos = s3;
                            s3 = peg$c1;
                        }
                        while (s3 !== peg$FAILED) {
                            s2.push(s3);
                            s3 = peg$currPos;
                            s4 = [];
                            s5 = peg$parse_();
                            while (s5 !== peg$FAILED) {
                                s4.push(s5);
                                s5 = peg$parse_();
                            }
                            if (s4 !== peg$FAILED) {
                                s5 = peg$parseattrListBlock();
                                if (s5 !== peg$FAILED) {
                                    s4 = [s4, s5];
                                    s3 = s4;
                                } else {
                                    peg$currPos = s3;
                                    s3 = peg$c1;
                                }
                            } else {
                                peg$currPos = s3;
                                s3 = peg$c1;
                            }
                        }
                        if (s2 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c18(s1, s2);
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c1;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c1;
                    }

                    return s0;
                }

                function peg$parseattrListBlock() {
                    var s0, s1, s2, s3, s4, s5;

                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 91) {
                        s1 = peg$c19;
                        peg$currPos++;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c20);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = [];
                        s3 = peg$parse_();
                        while (s3 !== peg$FAILED) {
                            s2.push(s3);
                            s3 = peg$parse_();
                        }
                        if (s2 !== peg$FAILED) {
                            s3 = peg$parseaList();
                            if (s3 === peg$FAILED) {
                                s3 = peg$c2;
                            }
                            if (s3 !== peg$FAILED) {
                                s4 = [];
                                s5 = peg$parse_();
                                while (s5 !== peg$FAILED) {
                                    s4.push(s5);
                                    s5 = peg$parse_();
                                }
                                if (s4 !== peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 93) {
                                        s5 = peg$c21;
                                        peg$currPos++;
                                    } else {
                                        s5 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c22);
                                        }
                                    }
                                    if (s5 !== peg$FAILED) {
                                        peg$reportedPos = s0;
                                        s1 = peg$c23(s3);
                                        s0 = s1;
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c1;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c1;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c1;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c1;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c1;
                    }

                    return s0;
                }

                function peg$parseaList() {
                    var s0, s1, s2, s3, s4, s5, s6, s7;

                    s0 = peg$currPos;
                    s1 = peg$parseidDef();
                    if (s1 !== peg$FAILED) {
                        s2 = [];
                        s3 = peg$currPos;
                        s4 = [];
                        s5 = peg$parse_();
                        while (s5 !== peg$FAILED) {
                            s4.push(s5);
                            s5 = peg$parse_();
                        }
                        if (s4 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 44) {
                                s5 = peg$c24;
                                peg$currPos++;
                            } else {
                                s5 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c25);
                                }
                            }
                            if (s5 === peg$FAILED) {
                                s5 = peg$c2;
                            }
                            if (s5 !== peg$FAILED) {
                                s6 = [];
                                s7 = peg$parse_();
                                while (s7 !== peg$FAILED) {
                                    s6.push(s7);
                                    s7 = peg$parse_();
                                }
                                if (s6 !== peg$FAILED) {
                                    s7 = peg$parseidDef();
                                    if (s7 !== peg$FAILED) {
                                        s4 = [s4, s5, s6, s7];
                                        s3 = s4;
                                    } else {
                                        peg$currPos = s3;
                                        s3 = peg$c1;
                                    }
                                } else {
                                    peg$currPos = s3;
                                    s3 = peg$c1;
                                }
                            } else {
                                peg$currPos = s3;
                                s3 = peg$c1;
                            }
                        } else {
                            peg$currPos = s3;
                            s3 = peg$c1;
                        }
                        while (s3 !== peg$FAILED) {
                            s2.push(s3);
                            s3 = peg$currPos;
                            s4 = [];
                            s5 = peg$parse_();
                            while (s5 !== peg$FAILED) {
                                s4.push(s5);
                                s5 = peg$parse_();
                            }
                            if (s4 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 44) {
                                    s5 = peg$c24;
                                    peg$currPos++;
                                } else {
                                    s5 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c25);
                                    }
                                }
                                if (s5 === peg$FAILED) {
                                    s5 = peg$c2;
                                }
                                if (s5 !== peg$FAILED) {
                                    s6 = [];
                                    s7 = peg$parse_();
                                    while (s7 !== peg$FAILED) {
                                        s6.push(s7);
                                        s7 = peg$parse_();
                                    }
                                    if (s6 !== peg$FAILED) {
                                        s7 = peg$parseidDef();
                                        if (s7 !== peg$FAILED) {
                                            s4 = [s4, s5, s6, s7];
                                            s3 = s4;
                                        } else {
                                            peg$currPos = s3;
                                            s3 = peg$c1;
                                        }
                                    } else {
                                        peg$currPos = s3;
                                        s3 = peg$c1;
                                    }
                                } else {
                                    peg$currPos = s3;
                                    s3 = peg$c1;
                                }
                            } else {
                                peg$currPos = s3;
                                s3 = peg$c1;
                            }
                        }
                        if (s2 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c26(s1, s2);
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c1;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c1;
                    }

                    return s0;
                }

                function peg$parseedgeRHS() {
                    var s0, s1, s2, s3, s4, s5;

                    s0 = peg$currPos;
                    s1 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c27) {
                        s2 = peg$c27;
                        peg$currPos += 2;
                    } else {
                        s2 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c28);
                        }
                    }
                    if (s2 !== peg$FAILED) {
                        peg$reportedPos = peg$currPos;
                        s3 = peg$c29();
                        if (s3) {
                            s3 = peg$c1;
                        } else {
                            s3 = peg$c30;
                        }
                        if (s3 !== peg$FAILED) {
                            s2 = [s2, s3];
                            s1 = s2;
                        } else {
                            peg$currPos = s1;
                            s1 = peg$c1;
                        }
                    } else {
                        peg$currPos = s1;
                        s1 = peg$c1;
                    }
                    if (s1 === peg$FAILED) {
                        s1 = peg$currPos;
                        if (input.substr(peg$currPos, 2) === peg$c31) {
                            s2 = peg$c31;
                            peg$currPos += 2;
                        } else {
                            s2 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c32);
                            }
                        }
                        if (s2 !== peg$FAILED) {
                            peg$reportedPos = peg$currPos;
                            s3 = peg$c29();
                            if (s3) {
                                s3 = peg$c30;
                            } else {
                                s3 = peg$c1;
                            }
                            if (s3 !== peg$FAILED) {
                                s2 = [s2, s3];
                                s1 = s2;
                            } else {
                                peg$currPos = s1;
                                s1 = peg$c1;
                            }
                        } else {
                            peg$currPos = s1;
                            s1 = peg$c1;
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = [];
                        s3 = peg$parse_();
                        while (s3 !== peg$FAILED) {
                            s2.push(s3);
                            s3 = peg$parse_();
                        }
                        if (s2 !== peg$FAILED) {
                            s3 = peg$parsenodeIdOrSubgraph();
                            if (s3 !== peg$FAILED) {
                                s4 = [];
                                s5 = peg$parse_();
                                while (s5 !== peg$FAILED) {
                                    s4.push(s5);
                                    s5 = peg$parse_();
                                }
                                if (s4 !== peg$FAILED) {
                                    s5 = peg$parseedgeRHS();
                                    if (s5 === peg$FAILED) {
                                        s5 = peg$c2;
                                    }
                                    if (s5 !== peg$FAILED) {
                                        peg$reportedPos = s0;
                                        s1 = peg$c33(s3, s5);
                                        s0 = s1;
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c1;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c1;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c1;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c1;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c1;
                    }

                    return s0;
                }

                function peg$parseidDef() {
                    var s0, s1, s2, s3, s4, s5, s6;

                    s0 = peg$currPos;
                    s1 = peg$parseid();
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        s3 = [];
                        s4 = peg$parse_();
                        while (s4 !== peg$FAILED) {
                            s3.push(s4);
                            s4 = peg$parse_();
                        }
                        if (s3 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 61) {
                                s4 = peg$c12;
                                peg$currPos++;
                            } else {
                                s4 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c13);
                                }
                            }
                            if (s4 !== peg$FAILED) {
                                s5 = [];
                                s6 = peg$parse_();
                                while (s6 !== peg$FAILED) {
                                    s5.push(s6);
                                    s6 = peg$parse_();
                                }
                                if (s5 !== peg$FAILED) {
                                    s6 = peg$parseid();
                                    if (s6 !== peg$FAILED) {
                                        s3 = [s3, s4, s5, s6];
                                        s2 = s3;
                                    } else {
                                        peg$currPos = s2;
                                        s2 = peg$c1;
                                    }
                                } else {
                                    peg$currPos = s2;
                                    s2 = peg$c1;
                                }
                            } else {
                                peg$currPos = s2;
                                s2 = peg$c1;
                            }
                        } else {
                            peg$currPos = s2;
                            s2 = peg$c1;
                        }
                        if (s2 === peg$FAILED) {
                            s2 = peg$c2;
                        }
                        if (s2 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c34(s1, s2);
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c1;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c1;
                    }

                    return s0;
                }

                function peg$parsenodeIdOrSubgraph() {
                    var s0, s1;

                    s0 = peg$parsesubgraphStmt();
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        s1 = peg$parsenodeId();
                        if (s1 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c35(s1);
                        }
                        s0 = s1;
                    }

                    return s0;
                }

                function peg$parsenodeId() {
                    var s0, s1, s2, s3;

                    s0 = peg$currPos;
                    s1 = peg$parseid();
                    if (s1 !== peg$FAILED) {
                        s2 = [];
                        s3 = peg$parse_();
                        while (s3 !== peg$FAILED) {
                            s2.push(s3);
                            s3 = peg$parse_();
                        }
                        if (s2 !== peg$FAILED) {
                            s3 = peg$parseport();
                            if (s3 === peg$FAILED) {
                                s3 = peg$c2;
                            }
                            if (s3 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c36(s1);
                                s0 = s1;
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c1;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c1;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c1;
                    }

                    return s0;
                }

                function peg$parseport() {
                    var s0, s1, s2, s3, s4, s5, s6, s7, s8;

                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 58) {
                        s1 = peg$c37;
                        peg$currPos++;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c38);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = [];
                        s3 = peg$parse_();
                        while (s3 !== peg$FAILED) {
                            s2.push(s3);
                            s3 = peg$parse_();
                        }
                        if (s2 !== peg$FAILED) {
                            s3 = peg$parseid();
                            if (s3 !== peg$FAILED) {
                                s4 = [];
                                s5 = peg$parse_();
                                while (s5 !== peg$FAILED) {
                                    s4.push(s5);
                                    s5 = peg$parse_();
                                }
                                if (s4 !== peg$FAILED) {
                                    s5 = peg$currPos;
                                    if (input.charCodeAt(peg$currPos) === 58) {
                                        s6 = peg$c37;
                                        peg$currPos++;
                                    } else {
                                        s6 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c38);
                                        }
                                    }
                                    if (s6 !== peg$FAILED) {
                                        s7 = [];
                                        s8 = peg$parse_();
                                        while (s8 !== peg$FAILED) {
                                            s7.push(s8);
                                            s8 = peg$parse_();
                                        }
                                        if (s7 !== peg$FAILED) {
                                            s8 = peg$parsecompassPt();
                                            if (s8 !== peg$FAILED) {
                                                s6 = [s6, s7, s8];
                                                s5 = s6;
                                            } else {
                                                peg$currPos = s5;
                                                s5 = peg$c1;
                                            }
                                        } else {
                                            peg$currPos = s5;
                                            s5 = peg$c1;
                                        }
                                    } else {
                                        peg$currPos = s5;
                                        s5 = peg$c1;
                                    }
                                    if (s5 === peg$FAILED) {
                                        s5 = peg$c2;
                                    }
                                    if (s5 !== peg$FAILED) {
                                        s1 = [s1, s2, s3, s4, s5];
                                        s0 = s1;
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c1;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c1;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c1;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c1;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c1;
                    }

                    return s0;
                }

                function peg$parsecompassPt() {
                    var s0;

                    if (input.substr(peg$currPos, 2) === peg$c39) {
                        s0 = peg$c39;
                        peg$currPos += 2;
                    } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c40);
                        }
                    }
                    if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c41) {
                            s0 = peg$c41;
                            peg$currPos += 2;
                        } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c42);
                            }
                        }
                        if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 2) === peg$c43) {
                                s0 = peg$c43;
                                peg$currPos += 2;
                            } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c44);
                                }
                            }
                            if (s0 === peg$FAILED) {
                                if (input.substr(peg$currPos, 2) === peg$c45) {
                                    s0 = peg$c45;
                                    peg$currPos += 2;
                                } else {
                                    s0 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c46);
                                    }
                                }
                                if (s0 === peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 110) {
                                        s0 = peg$c47;
                                        peg$currPos++;
                                    } else {
                                        s0 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c48);
                                        }
                                    }
                                    if (s0 === peg$FAILED) {
                                        if (input.charCodeAt(peg$currPos) === 101) {
                                            s0 = peg$c49;
                                            peg$currPos++;
                                        } else {
                                            s0 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c50);
                                            }
                                        }
                                        if (s0 === peg$FAILED) {
                                            if (input.charCodeAt(peg$currPos) === 115) {
                                                s0 = peg$c51;
                                                peg$currPos++;
                                            } else {
                                                s0 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c52);
                                                }
                                            }
                                            if (s0 === peg$FAILED) {
                                                if (input.charCodeAt(peg$currPos) === 119) {
                                                    s0 = peg$c53;
                                                    peg$currPos++;
                                                } else {
                                                    s0 = peg$FAILED;
                                                    if (peg$silentFails === 0) {
                                                        peg$fail(peg$c54);
                                                    }
                                                }
                                                if (s0 === peg$FAILED) {
                                                    if (input.charCodeAt(peg$currPos) === 99) {
                                                        s0 = peg$c55;
                                                        peg$currPos++;
                                                    } else {
                                                        s0 = peg$FAILED;
                                                        if (peg$silentFails === 0) {
                                                            peg$fail(peg$c56);
                                                        }
                                                    }
                                                    if (s0 === peg$FAILED) {
                                                        if (input.charCodeAt(peg$currPos) === 95) {
                                                            s0 = peg$c57;
                                                            peg$currPos++;
                                                        } else {
                                                            s0 = peg$FAILED;
                                                            if (peg$silentFails === 0) {
                                                                peg$fail(peg$c58);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    return s0;
                }

                function peg$parseid() {
                    var s0, s1, s2, s3, s4, s5, s6;

                    peg$silentFails++;
                    s0 = peg$currPos;
                    if (peg$c60.test(input.charAt(peg$currPos))) {
                        s1 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c61);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = [];
                        if (peg$c62.test(input.charAt(peg$currPos))) {
                            s3 = input.charAt(peg$currPos);
                            peg$currPos++;
                        } else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c63);
                            }
                        }
                        while (s3 !== peg$FAILED) {
                            s2.push(s3);
                            if (peg$c62.test(input.charAt(peg$currPos))) {
                                s3 = input.charAt(peg$currPos);
                                peg$currPos++;
                            } else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c63);
                                }
                            }
                        }
                        if (s2 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c64(s1, s2);
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c1;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c1;
                    }
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 45) {
                            s1 = peg$c65;
                            peg$currPos++;
                        } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c66);
                            }
                        }
                        if (s1 === peg$FAILED) {
                            s1 = peg$c2;
                        }
                        if (s1 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 46) {
                                s2 = peg$c67;
                                peg$currPos++;
                            } else {
                                s2 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c68);
                                }
                            }
                            if (s2 !== peg$FAILED) {
                                s3 = [];
                                if (peg$c69.test(input.charAt(peg$currPos))) {
                                    s4 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                } else {
                                    s4 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c70);
                                    }
                                }
                                if (s4 !== peg$FAILED) {
                                    while (s4 !== peg$FAILED) {
                                        s3.push(s4);
                                        if (peg$c69.test(input.charAt(peg$currPos))) {
                                            s4 = input.charAt(peg$currPos);
                                            peg$currPos++;
                                        } else {
                                            s4 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c70);
                                            }
                                        }
                                    }
                                } else {
                                    s3 = peg$c1;
                                }
                                if (s3 !== peg$FAILED) {
                                    peg$reportedPos = s0;
                                    s1 = peg$c71(s1, s2, s3);
                                    s0 = s1;
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c1;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c1;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c1;
                        }
                        if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            if (input.charCodeAt(peg$currPos) === 45) {
                                s1 = peg$c65;
                                peg$currPos++;
                            } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c66);
                                }
                            }
                            if (s1 === peg$FAILED) {
                                s1 = peg$c2;
                            }
                            if (s1 !== peg$FAILED) {
                                s2 = [];
                                if (peg$c69.test(input.charAt(peg$currPos))) {
                                    s3 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                } else {
                                    s3 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c70);
                                    }
                                }
                                if (s3 !== peg$FAILED) {
                                    while (s3 !== peg$FAILED) {
                                        s2.push(s3);
                                        if (peg$c69.test(input.charAt(peg$currPos))) {
                                            s3 = input.charAt(peg$currPos);
                                            peg$currPos++;
                                        } else {
                                            s3 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c70);
                                            }
                                        }
                                    }
                                } else {
                                    s2 = peg$c1;
                                }
                                if (s2 !== peg$FAILED) {
                                    s3 = peg$currPos;
                                    if (input.charCodeAt(peg$currPos) === 46) {
                                        s4 = peg$c67;
                                        peg$currPos++;
                                    } else {
                                        s4 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c68);
                                        }
                                    }
                                    if (s4 !== peg$FAILED) {
                                        s5 = [];
                                        if (peg$c69.test(input.charAt(peg$currPos))) {
                                            s6 = input.charAt(peg$currPos);
                                            peg$currPos++;
                                        } else {
                                            s6 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c70);
                                            }
                                        }
                                        while (s6 !== peg$FAILED) {
                                            s5.push(s6);
                                            if (peg$c69.test(input.charAt(peg$currPos))) {
                                                s6 = input.charAt(peg$currPos);
                                                peg$currPos++;
                                            } else {
                                                s6 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c70);
                                                }
                                            }
                                        }
                                        if (s5 !== peg$FAILED) {
                                            s4 = [s4, s5];
                                            s3 = s4;
                                        } else {
                                            peg$currPos = s3;
                                            s3 = peg$c1;
                                        }
                                    } else {
                                        peg$currPos = s3;
                                        s3 = peg$c1;
                                    }
                                    if (s3 === peg$FAILED) {
                                        s3 = peg$c2;
                                    }
                                    if (s3 !== peg$FAILED) {
                                        peg$reportedPos = s0;
                                        s1 = peg$c72(s1, s2, s3);
                                        s0 = s1;
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c1;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c1;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c1;
                            }
                            if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                if (input.charCodeAt(peg$currPos) === 34) {
                                    s1 = peg$c73;
                                    peg$currPos++;
                                } else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c74);
                                    }
                                }
                                if (s1 !== peg$FAILED) {
                                    s2 = [];
                                    s3 = peg$currPos;
                                    if (input.substr(peg$currPos, 2) === peg$c75) {
                                        s4 = peg$c75;
                                        peg$currPos += 2;
                                    } else {
                                        s4 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c76);
                                        }
                                    }
                                    if (s4 !== peg$FAILED) {
                                        peg$reportedPos = s3;
                                        s4 = peg$c77();
                                    }
                                    s3 = s4;
                                    if (s3 === peg$FAILED) {
                                        s3 = peg$currPos;
                                        if (input.charCodeAt(peg$currPos) === 92) {
                                            s4 = peg$c78;
                                            peg$currPos++;
                                        } else {
                                            s4 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c79);
                                            }
                                        }
                                        if (s4 !== peg$FAILED) {
                                            if (peg$c80.test(input.charAt(peg$currPos))) {
                                                s5 = input.charAt(peg$currPos);
                                                peg$currPos++;
                                            } else {
                                                s5 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c81);
                                                }
                                            }
                                            if (s5 !== peg$FAILED) {
                                                peg$reportedPos = s3;
                                                s4 = peg$c82(s5);
                                                s3 = s4;
                                            } else {
                                                peg$currPos = s3;
                                                s3 = peg$c1;
                                            }
                                        } else {
                                            peg$currPos = s3;
                                            s3 = peg$c1;
                                        }
                                        if (s3 === peg$FAILED) {
                                            if (peg$c80.test(input.charAt(peg$currPos))) {
                                                s3 = input.charAt(peg$currPos);
                                                peg$currPos++;
                                            } else {
                                                s3 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c81);
                                                }
                                            }
                                        }
                                    }
                                    while (s3 !== peg$FAILED) {
                                        s2.push(s3);
                                        s3 = peg$currPos;
                                        if (input.substr(peg$currPos, 2) === peg$c75) {
                                            s4 = peg$c75;
                                            peg$currPos += 2;
                                        } else {
                                            s4 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c76);
                                            }
                                        }
                                        if (s4 !== peg$FAILED) {
                                            peg$reportedPos = s3;
                                            s4 = peg$c77();
                                        }
                                        s3 = s4;
                                        if (s3 === peg$FAILED) {
                                            s3 = peg$currPos;
                                            if (input.charCodeAt(peg$currPos) === 92) {
                                                s4 = peg$c78;
                                                peg$currPos++;
                                            } else {
                                                s4 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                    peg$fail(peg$c79);
                                                }
                                            }
                                            if (s4 !== peg$FAILED) {
                                                if (peg$c80.test(input.charAt(peg$currPos))) {
                                                    s5 = input.charAt(peg$currPos);
                                                    peg$currPos++;
                                                } else {
                                                    s5 = peg$FAILED;
                                                    if (peg$silentFails === 0) {
                                                        peg$fail(peg$c81);
                                                    }
                                                }
                                                if (s5 !== peg$FAILED) {
                                                    peg$reportedPos = s3;
                                                    s4 = peg$c82(s5);
                                                    s3 = s4;
                                                } else {
                                                    peg$currPos = s3;
                                                    s3 = peg$c1;
                                                }
                                            } else {
                                                peg$currPos = s3;
                                                s3 = peg$c1;
                                            }
                                            if (s3 === peg$FAILED) {
                                                if (peg$c80.test(input.charAt(peg$currPos))) {
                                                    s3 = input.charAt(peg$currPos);
                                                    peg$currPos++;
                                                } else {
                                                    s3 = peg$FAILED;
                                                    if (peg$silentFails === 0) {
                                                        peg$fail(peg$c81);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    if (s2 !== peg$FAILED) {
                                        if (input.charCodeAt(peg$currPos) === 34) {
                                            s3 = peg$c73;
                                            peg$currPos++;
                                        } else {
                                            s3 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                                peg$fail(peg$c74);
                                            }
                                        }
                                        if (s3 !== peg$FAILED) {
                                            peg$reportedPos = s0;
                                            s1 = peg$c83(s2);
                                            s0 = s1;
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$c1;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$c1;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c1;
                                }
                            }
                        }
                    }
                    peg$silentFails--;
                    if (s0 === peg$FAILED) {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c59);
                        }
                    }

                    return s0;
                }

                function peg$parsenode() {
                    var s0, s1;

                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c84) {
                        s1 = input.substr(peg$currPos, 4);
                        peg$currPos += 4;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c85);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c86(s1);
                    }
                    s0 = s1;

                    return s0;
                }

                function peg$parseedge() {
                    var s0, s1;

                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c87) {
                        s1 = input.substr(peg$currPos, 4);
                        peg$currPos += 4;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c88);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c86(s1);
                    }
                    s0 = s1;

                    return s0;
                }

                function peg$parsegraph() {
                    var s0, s1;

                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c89) {
                        s1 = input.substr(peg$currPos, 5);
                        peg$currPos += 5;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c90);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c86(s1);
                    }
                    s0 = s1;

                    return s0;
                }

                function peg$parsedigraph() {
                    var s0, s1;

                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c91) {
                        s1 = input.substr(peg$currPos, 7);
                        peg$currPos += 7;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c92);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c86(s1);
                    }
                    s0 = s1;

                    return s0;
                }

                function peg$parsesubgraph() {
                    var s0, s1;

                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c93) {
                        s1 = input.substr(peg$currPos, 8);
                        peg$currPos += 8;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c94);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c86(s1);
                    }
                    s0 = s1;

                    return s0;
                }

                function peg$parsestrict() {
                    var s0, s1;

                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c95) {
                        s1 = input.substr(peg$currPos, 6);
                        peg$currPos += 6;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c96);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c86(s1);
                    }
                    s0 = s1;

                    return s0;
                }

                function peg$parsegraphType() {
                    var s0, s1;

                    s0 = peg$parsegraph();
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        s1 = peg$parsedigraph();
                        if (s1 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c97(s1);
                        }
                        s0 = s1;
                    }

                    return s0;
                }

                function peg$parsewhitespace() {
                    var s0, s1;

                    peg$silentFails++;
                    s0 = [];
                    if (peg$c99.test(input.charAt(peg$currPos))) {
                        s1 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c100);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        while (s1 !== peg$FAILED) {
                            s0.push(s1);
                            if (peg$c99.test(input.charAt(peg$currPos))) {
                                s1 = input.charAt(peg$currPos);
                                peg$currPos++;
                            } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c100);
                                }
                            }
                        }
                    } else {
                        s0 = peg$c1;
                    }
                    peg$silentFails--;
                    if (s0 === peg$FAILED) {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c98);
                        }
                    }

                    return s0;
                }

                function peg$parsecomment() {
                    var s0, s1, s2, s3, s4, s5;

                    peg$silentFails++;
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c102) {
                        s1 = peg$c102;
                        peg$currPos += 2;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c103);
                        }
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = [];
                        if (peg$c104.test(input.charAt(peg$currPos))) {
                            s3 = input.charAt(peg$currPos);
                            peg$currPos++;
                        } else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c105);
                            }
                        }
                        while (s3 !== peg$FAILED) {
                            s2.push(s3);
                            if (peg$c104.test(input.charAt(peg$currPos))) {
                                s3 = input.charAt(peg$currPos);
                                peg$currPos++;
                            } else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c105);
                                }
                            }
                        }
                        if (s2 !== peg$FAILED) {
                            s1 = [s1, s2];
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c1;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$c1;
                    }
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.substr(peg$currPos, 2) === peg$c106) {
                            s1 = peg$c106;
                            peg$currPos += 2;
                        } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                                peg$fail(peg$c107);
                            }
                        }
                        if (s1 !== peg$FAILED) {
                            s2 = [];
                            s3 = peg$currPos;
                            s4 = peg$currPos;
                            peg$silentFails++;
                            if (input.substr(peg$currPos, 2) === peg$c108) {
                                s5 = peg$c108;
                                peg$currPos += 2;
                            } else {
                                s5 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                    peg$fail(peg$c109);
                                }
                            }
                            peg$silentFails--;
                            if (s5 === peg$FAILED) {
                                s4 = peg$c30;
                            } else {
                                peg$currPos = s4;
                                s4 = peg$c1;
                            }
                            if (s4 !== peg$FAILED) {
                                if (input.length > peg$currPos) {
                                    s5 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                } else {
                                    s5 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c110);
                                    }
                                }
                                if (s5 !== peg$FAILED) {
                                    s4 = [s4, s5];
                                    s3 = s4;
                                } else {
                                    peg$currPos = s3;
                                    s3 = peg$c1;
                                }
                            } else {
                                peg$currPos = s3;
                                s3 = peg$c1;
                            }
                            while (s3 !== peg$FAILED) {
                                s2.push(s3);
                                s3 = peg$currPos;
                                s4 = peg$currPos;
                                peg$silentFails++;
                                if (input.substr(peg$currPos, 2) === peg$c108) {
                                    s5 = peg$c108;
                                    peg$currPos += 2;
                                } else {
                                    s5 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c109);
                                    }
                                }
                                peg$silentFails--;
                                if (s5 === peg$FAILED) {
                                    s4 = peg$c30;
                                } else {
                                    peg$currPos = s4;
                                    s4 = peg$c1;
                                }
                                if (s4 !== peg$FAILED) {
                                    if (input.length > peg$currPos) {
                                        s5 = input.charAt(peg$currPos);
                                        peg$currPos++;
                                    } else {
                                        s5 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                            peg$fail(peg$c110);
                                        }
                                    }
                                    if (s5 !== peg$FAILED) {
                                        s4 = [s4, s5];
                                        s3 = s4;
                                    } else {
                                        peg$currPos = s3;
                                        s3 = peg$c1;
                                    }
                                } else {
                                    peg$currPos = s3;
                                    s3 = peg$c1;
                                }
                            }
                            if (s2 !== peg$FAILED) {
                                if (input.substr(peg$currPos, 2) === peg$c108) {
                                    s3 = peg$c108;
                                    peg$currPos += 2;
                                } else {
                                    s3 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$c109);
                                    }
                                }
                                if (s3 !== peg$FAILED) {
                                    s1 = [s1, s2, s3];
                                    s0 = s1;
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$c1;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$c1;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$c1;
                        }
                    }
                    peg$silentFails--;
                    if (s0 === peg$FAILED) {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                            peg$fail(peg$c101);
                        }
                    }

                    return s0;
                }

                function peg$parse_() {
                    var s0;

                    s0 = peg$parsewhitespace();
                    if (s0 === peg$FAILED) {
                        s0 = peg$parsecomment();
                    }

                    return s0;
                }


                var _ = require("./lodash");
                var directed;


                peg$result = peg$startRuleFunction();

                if (peg$result !== peg$FAILED && peg$currPos === input.length) {
                    return peg$result;
                } else {
                    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
                        peg$fail({
                            type: "end",
                            description: "end of input"
                        });
                    }

                    throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
                }
            }

            return {
                SyntaxError: SyntaxError,
                parse: parse
            };
        })();

    }, {
        "./lodash": 25
    }],
    24: [function(require, module, exports) {
        /* global window */

        var graphlib;

        if (require) {
            try {
                graphlib = require("graphlib");
            } catch (e) {}
        }

        if (!graphlib) {
            graphlib = window.graphlib;
        }

        module.exports = graphlib;

    }, {
        "graphlib": 31
    }],
    25: [function(require, module, exports) {
        /* global window */

        var lodash;

        if (require) {
            try {
                lodash = require("lodash");
            } catch (e) {}
        }

        if (!lodash) {
            lodash = window._;
        }

        module.exports = lodash;

    }, {
        "lodash": 30
    }],
    26: [function(require, module, exports) {
        var _ = require("./lodash"),
            grammar = require("./dot-grammar"),
            buildGraph = require("./build-graph");

        module.exports = function readMany(str) {
            var parseTree = grammar.parse(str);
            return _.map(parseTree, buildGraph);
        };

    }, {
        "./build-graph": 22,
        "./dot-grammar": 23,
        "./lodash": 25
    }],
    27: [function(require, module, exports) {
        var grammar = require("./dot-grammar"),
            buildGraph = require("./build-graph");

        module.exports = function readOne(str) {
            var parseTree = grammar.parse(str, {
                startRule: "graphStmt"
            });
            return buildGraph(parseTree);
        };


    }, {
        "./build-graph": 22,
        "./dot-grammar": 23
    }],
    28: [function(require, module, exports) {
        module.exports = '0.6.2';

    }, {}],
    29: [function(require, module, exports) {
        var _ = require("./lodash");

        module.exports = writeOne;

        var UNESCAPED_ID_PATTERN = /^[a-zA-Z\200-\377_][a-zA-Z\200-\377_0-9]*$/;

        function writeOne(g) {
            var ec = g.isDirected() ? "->" : "--",
                writer = new Writer();

            if (!g.isMultigraph()) {
                writer.write("strict ");
            }

            writer.writeLine((g.isDirected() ? "digraph" : "graph") + " {");
            writer.indent();

            var graphAttrs = g.graph();
            if (_.isObject(graphAttrs)) {
                _.each(graphAttrs, function(v, k) {
                    writer.writeLine(id(k) + "=" + id(v) + ";");
                });
            }

            writeSubgraph(g, undefined, writer);

            g.edges().forEach(function(edge) {
                writeEdge(g, edge, ec, writer);
            });

            writer.unindent();
            writer.writeLine("}");

            return writer.toString();
        }

        function writeSubgraph(g, v, writer) {
            var children = g.isCompound() ? g.children(v) : g.nodes();
            _.each(children, function(w) {
                if (!g.isCompound() || !g.children(w).length) {
                    writeNode(g, w, writer);
                } else {
                    writer.writeLine("subgraph " + id(w) + " {");
                    writer.indent();

                    if (_.isObject(g.node(w))) {
                        _.map(g.node(w), function(val, key) {
                            writer.writeLine(id(key) + "=" + id(val) + ";");
                        });
                    }

                    writeSubgraph(g, w, writer);
                    writer.unindent();
                    writer.writeLine("}");
                }
            });
        }

        function writeNode(g, v, writer) {
            writer.write(id(v));
            writeAttrs(g.node(v), writer);
            writer.writeLine();
        }

        function writeEdge(g, edge, ec, writer) {
            var v = edge.v,
                w = edge.w,
                attrs = g.edge(edge);

            writer.write(id(v) + " " + ec + " " + id(w));
            writeAttrs(attrs, writer);
            writer.writeLine();
        }

        function writeAttrs(attrs, writer) {
            if (_.isObject(attrs)) {
                var attrStrs = _.map(attrs, function(val, key) {
                    return id(key) + "=" + id(val);
                });
                if (attrStrs.length) {
                    writer.write(" [" + attrStrs.join(",") + "]");
                }
            }
        }

        function id(obj) {
            if (typeof obj === "number" || obj.toString().match(UNESCAPED_ID_PATTERN)) {
                return obj;
            }

            return "\"" + obj.toString().replace(/"/g, "\\\"") + "\"";
        }

        // Helper object for making a pretty printer
        function Writer() {
            this._indent = "";
            this._content = "";
            this._shouldIndent = true;
        }

        Writer.prototype.INDENT = "  ";

        Writer.prototype.indent = function() {
            this._indent += this.INDENT;
        };

        Writer.prototype.unindent = function() {
            this._indent = this._indent.slice(this.INDENT.length);
        };

        Writer.prototype.writeLine = function(line) {
            this.write((line || "") + "\n");
            this._shouldIndent = true;
        };

        Writer.prototype.write = function(str) {
            if (this._shouldIndent) {
                this._shouldIndent = false;
                this._content += this._indent;
            }
            this._content += str;
        };

        Writer.prototype.toString = function() {
            return this._content;
        };


    }, {
        "./lodash": 25
    }],
    30: [function(require, module, exports) {
        (function(global) {
            /**
             * @license
             * Lo-Dash 2.4.2 (Custom Build) <https://lodash.com/>
             * Build: `lodash modern -o ./dist/lodash.js`
             * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
             * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
             * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
             * Available under MIT license <https://lodash.com/license>
             */
            ;
            (function() {

                /** Used as a safe reference for `undefined` in pre ES5 environments */
                var undefined;

                /** Used to pool arrays and objects used internally */
                var arrayPool = [],
                    objectPool = [];

                /** Used to generate unique IDs */
                var idCounter = 0;

                /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
                var keyPrefix = +new Date + '';

                /** Used as the size when optimizations are enabled for large arrays */
                var largeArraySize = 75;

                /** Used as the max size of the `arrayPool` and `objectPool` */
                var maxPoolSize = 40;

                /** Used to detect and test whitespace */
                var whitespace = (
                    // whitespace
                    ' \t\x0B\f\xA0\ufeff' +

                    // line terminators
                    '\n\r\u2028\u2029' +

                    // unicode category "Zs" space separators
                    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
                );

                /** Used to match empty string literals in compiled template source */
                var reEmptyStringLeading = /\b__p \+= '';/g,
                    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
                    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

                /**
                 * Used to match ES6 template delimiters
                 * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
                 */
                var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

                /** Used to match regexp flags from their coerced string values */
                var reFlags = /\w*$/;

                /** Used to detected named functions */
                var reFuncName = /^\s*function[ \n\r\t]+\w/;

                /** Used to match "interpolate" template delimiters */
                var reInterpolate = /<%=([\s\S]+?)%>/g;

                /** Used to match leading whitespace and zeros to be removed */
                var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');

                /** Used to ensure capturing order of template delimiters */
                var reNoMatch = /($^)/;

                /** Used to detect functions containing a `this` reference */
                var reThis = /\bthis\b/;

                /** Used to match unescaped characters in compiled string literals */
                var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

                /** Used to assign default `context` object properties */
                var contextProps = [
                    'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',
                    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
                    'parseInt', 'setTimeout'
                ];

                /** Used to make template sourceURLs easier to identify */
                var templateCounter = 0;

                /** `Object#toString` result shortcuts */
                var argsClass = '[object Arguments]',
                    arrayClass = '[object Array]',
                    boolClass = '[object Boolean]',
                    dateClass = '[object Date]',
                    funcClass = '[object Function]',
                    numberClass = '[object Number]',
                    objectClass = '[object Object]',
                    regexpClass = '[object RegExp]',
                    stringClass = '[object String]';

                /** Used to identify object classifications that `_.clone` supports */
                var cloneableClasses = {};
                cloneableClasses[funcClass] = false;
                cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
                    cloneableClasses[boolClass] = cloneableClasses[dateClass] =
                    cloneableClasses[numberClass] = cloneableClasses[objectClass] =
                    cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

                /** Used as an internal `_.debounce` options object */
                var debounceOptions = {
                    'leading': false,
                    'maxWait': 0,
                    'trailing': false
                };

                /** Used as the property descriptor for `__bindData__` */
                var descriptor = {
                    'configurable': false,
                    'enumerable': false,
                    'value': null,
                    'writable': false
                };

                /** Used to determine if values are of the language type Object */
                var objectTypes = {
                    'boolean': false,
                    'function': true,
                    'object': true,
                    'number': false,
                    'string': false,
                    'undefined': false
                };

                /** Used to escape characters for inclusion in compiled string literals */
                var stringEscapes = {
                    '\\': '\\',
                    "'": "'",
                    '\n': 'n',
                    '\r': 'r',
                    '\t': 't',
                    '\u2028': 'u2028',
                    '\u2029': 'u2029'
                };

                /** Used as a reference to the global object */
                var root = (objectTypes[typeof window] && window) || this;

                /** Detect free variable `exports` */
                var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

                /** Detect free variable `module` */
                var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

                /** Detect the popular CommonJS extension `module.exports` */
                var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

                /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
                var freeGlobal = objectTypes[typeof global] && global;
                if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
                    root = freeGlobal;
                }

                /*--------------------------------------------------------------------------*/

                /**
                 * The base implementation of `_.indexOf` without support for binary searches
                 * or `fromIndex` constraints.
                 *
                 * @private
                 * @param {Array} array The array to search.
                 * @param {*} value The value to search for.
                 * @param {number} [fromIndex=0] The index to search from.
                 * @returns {number} Returns the index of the matched value or `-1`.
                 */
                function baseIndexOf(array, value, fromIndex) {
                    var index = (fromIndex || 0) - 1,
                        length = array ? array.length : 0;

                    while (++index < length) {
                        if (array[index] === value) {
                            return index;
                        }
                    }
                    return -1;
                }

                /**
                 * An implementation of `_.contains` for cache objects that mimics the return
                 * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
                 *
                 * @private
                 * @param {Object} cache The cache object to inspect.
                 * @param {*} value The value to search for.
                 * @returns {number} Returns `0` if `value` is found, else `-1`.
                 */
                function cacheIndexOf(cache, value) {
                    var type = typeof value;
                    cache = cache.cache;

                    if (type == 'boolean' || value == null) {
                        return cache[value] ? 0 : -1;
                    }
                    if (type != 'number' && type != 'string') {
                        type = 'object';
                    }
                    var key = type == 'number' ? value : keyPrefix + value;
                    cache = (cache = cache[type]) && cache[key];

                    return type == 'object' ?
                        (cache && baseIndexOf(cache, value) > -1 ? 0 : -1) :
                        (cache ? 0 : -1);
                }

                /**
                 * Adds a given value to the corresponding cache object.
                 *
                 * @private
                 * @param {*} value The value to add to the cache.
                 */
                function cachePush(value) {
                    var cache = this.cache,
                        type = typeof value;

                    if (type == 'boolean' || value == null) {
                        cache[value] = true;
                    } else {
                        if (type != 'number' && type != 'string') {
                            type = 'object';
                        }
                        var key = type == 'number' ? value : keyPrefix + value,
                            typeCache = cache[type] || (cache[type] = {});

                        if (type == 'object') {
                            (typeCache[key] || (typeCache[key] = [])).push(value);
                        } else {
                            typeCache[key] = true;
                        }
                    }
                }

                /**
                 * Used by `_.max` and `_.min` as the default callback when a given
                 * collection is a string value.
                 *
                 * @private
                 * @param {string} value The character to inspect.
                 * @returns {number} Returns the code unit of given character.
                 */
                function charAtCallback(value) {
                    return value.charCodeAt(0);
                }

                /**
                 * Used by `sortBy` to compare transformed `collection` elements, stable sorting
                 * them in ascending order.
                 *
                 * @private
                 * @param {Object} a The object to compare to `b`.
                 * @param {Object} b The object to compare to `a`.
                 * @returns {number} Returns the sort order indicator of `1` or `-1`.
                 */
                function compareAscending(a, b) {
                    var ac = a.criteria,
                        bc = b.criteria,
                        index = -1,
                        length = ac.length;

                    while (++index < length) {
                        var value = ac[index],
                            other = bc[index];

                        if (value !== other) {
                            if (value > other || typeof value == 'undefined') {
                                return 1;
                            }
                            if (value < other || typeof other == 'undefined') {
                                return -1;
                            }
                        }
                    }
                    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
                    // that causes it, under certain circumstances, to return the same value for
                    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
                    //
                    // This also ensures a stable sort in V8 and other engines.
                    // See http://code.google.com/p/v8/issues/detail?id=90
                    return a.index - b.index;
                }

                /**
                 * Creates a cache object to optimize linear searches of large arrays.
                 *
                 * @private
                 * @param {Array} [array=[]] The array to search.
                 * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
                 */
                function createCache(array) {
                    var index = -1,
                        length = array.length,
                        first = array[0],
                        mid = array[(length / 2) | 0],
                        last = array[length - 1];

                    if (first && typeof first == 'object' &&
                        mid && typeof mid == 'object' && last && typeof last == 'object') {
                        return false;
                    }
                    var cache = getObject();
                    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

                    var result = getObject();
                    result.array = array;
                    result.cache = cache;
                    result.push = cachePush;

                    while (++index < length) {
                        result.push(array[index]);
                    }
                    return result;
                }

                /**
                 * Used by `template` to escape characters for inclusion in compiled
                 * string literals.
                 *
                 * @private
                 * @param {string} match The matched character to escape.
                 * @returns {string} Returns the escaped character.
                 */
                function escapeStringChar(match) {
                    return '\\' + stringEscapes[match];
                }

                /**
                 * Gets an array from the array pool or creates a new one if the pool is empty.
                 *
                 * @private
                 * @returns {Array} The array from the pool.
                 */
                function getArray() {
                    return arrayPool.pop() || [];
                }

                /**
                 * Gets an object from the object pool or creates a new one if the pool is empty.
                 *
                 * @private
                 * @returns {Object} The object from the pool.
                 */
                function getObject() {
                    return objectPool.pop() || {
                        'array': null,
                        'cache': null,
                        'criteria': null,
                        'false': false,
                        'index': 0,
                        'null': false,
                        'number': null,
                        'object': null,
                        'push': null,
                        'string': null,
                        'true': false,
                        'undefined': false,
                        'value': null
                    };
                }

                /**
                 * Releases the given array back to the array pool.
                 *
                 * @private
                 * @param {Array} [array] The array to release.
                 */
                function releaseArray(array) {
                    array.length = 0;
                    if (arrayPool.length < maxPoolSize) {
                        arrayPool.push(array);
                    }
                }

                /**
                 * Releases the given object back to the object pool.
                 *
                 * @private
                 * @param {Object} [object] The object to release.
                 */
                function releaseObject(object) {
                    var cache = object.cache;
                    if (cache) {
                        releaseObject(cache);
                    }
                    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
                    if (objectPool.length < maxPoolSize) {
                        objectPool.push(object);
                    }
                }

                /**
                 * Slices the `collection` from the `start` index up to, but not including,
                 * the `end` index.
                 *
                 * Note: This function is used instead of `Array#slice` to support node lists
                 * in IE < 9 and to ensure dense arrays are returned.
                 *
                 * @private
                 * @param {Array|Object|string} collection The collection to slice.
                 * @param {number} start The start index.
                 * @param {number} end The end index.
                 * @returns {Array} Returns the new array.
                 */
                function slice(array, start, end) {
                    start || (start = 0);
                    if (typeof end == 'undefined') {
                        end = array ? array.length : 0;
                    }
                    var index = -1,
                        length = end - start || 0,
                        result = Array(length < 0 ? 0 : length);

                    while (++index < length) {
                        result[index] = array[start + index];
                    }
                    return result;
                }

                /*--------------------------------------------------------------------------*/

                /**
                 * Create a new `lodash` function using the given context object.
                 *
                 * @static
                 * @memberOf _
                 * @category Utilities
                 * @param {Object} [context=root] The context object.
                 * @returns {Function} Returns the `lodash` function.
                 */
                function runInContext(context) {
                    // Avoid issues with some ES3 environments that attempt to use values, named
                    // after built-in constructors like `Object`, for the creation of literals.
                    // ES5 clears this up by stating that literals must use built-in constructors.
                    // See http://es5.github.io/#x11.1.5.
                    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

                    /** Native constructor references */
                    var Array = context.Array,
                        Boolean = context.Boolean,
                        Date = context.Date,
                        Function = context.Function,
                        Math = context.Math,
                        Number = context.Number,
                        Object = context.Object,
                        RegExp = context.RegExp,
                        String = context.String,
                        TypeError = context.TypeError;

                    /**
                     * Used for `Array` method references.
                     *
                     * Normally `Array.prototype` would suffice, however, using an array literal
                     * avoids issues in Narwhal.
                     */
                    var arrayRef = [];

                    /** Used for native method references */
                    var objectProto = Object.prototype;

                    /** Used to restore the original `_` reference in `noConflict` */
                    var oldDash = context._;

                    /** Used to resolve the internal [[Class]] of values */
                    var toString = objectProto.toString;

                    /** Used to detect if a method is native */
                    var reNative = RegExp('^' +
                        String(toString)
                        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
                        .replace(/toString| for [^\]]+/g, '.*?') + '$'
                    );

                    /** Native method shortcuts */
                    var ceil = Math.ceil,
                        clearTimeout = context.clearTimeout,
                        floor = Math.floor,
                        fnToString = Function.prototype.toString,
                        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
                        hasOwnProperty = objectProto.hasOwnProperty,
                        push = arrayRef.push,
                        setTimeout = context.setTimeout,
                        splice = arrayRef.splice,
                        unshift = arrayRef.unshift;

                    /** Used to set meta data on functions */
                    var defineProperty = (function() {
                        // IE 8 only accepts DOM elements
                        try {
                            var o = {},
                                func = isNative(func = Object.defineProperty) && func,
                                result = func(o, o, o) && func;
                        } catch (e) {}
                        return result;
                    }());

                    /* Native method shortcuts for methods with the same name as other `lodash` methods */
                    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
                        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
                        nativeIsFinite = context.isFinite,
                        nativeIsNaN = context.isNaN,
                        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
                        nativeMax = Math.max,
                        nativeMin = Math.min,
                        nativeParseInt = context.parseInt,
                        nativeRandom = Math.random;

                    /** Used to lookup a built-in constructor by [[Class]] */
                    var ctorByClass = {};
                    ctorByClass[arrayClass] = Array;
                    ctorByClass[boolClass] = Boolean;
                    ctorByClass[dateClass] = Date;
                    ctorByClass[funcClass] = Function;
                    ctorByClass[objectClass] = Object;
                    ctorByClass[numberClass] = Number;
                    ctorByClass[regexpClass] = RegExp;
                    ctorByClass[stringClass] = String;

                    /*--------------------------------------------------------------------------*/

                    /**
                     * Creates a `lodash` object which wraps the given value to enable intuitive
                     * method chaining.
                     *
                     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
                     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
                     * and `unshift`
                     *
                     * Chaining is supported in custom builds as long as the `value` method is
                     * implicitly or explicitly included in the build.
                     *
                     * The chainable wrapper functions are:
                     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
                     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
                     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
                     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
                     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
                     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
                     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
                     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
                     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
                     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
                     * and `zip`
                     *
                     * The non-chainable wrapper functions are:
                     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
                     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
                     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
                     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
                     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
                     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
                     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
                     * `template`, `unescape`, `uniqueId`, and `value`
                     *
                     * The wrapper functions `first` and `last` return wrapped values when `n` is
                     * provided, otherwise they return unwrapped values.
                     *
                     * Explicit chaining can be enabled by using the `_.chain` method.
                     *
                     * @name _
                     * @constructor
                     * @category Chaining
                     * @param {*} value The value to wrap in a `lodash` instance.
                     * @returns {Object} Returns a `lodash` instance.
                     * @example
                     *
                     * var wrapped = _([1, 2, 3]);
                     *
                     * // returns an unwrapped value
                     * wrapped.reduce(function(sum, num) {
                     *   return sum + num;
                     * });
                     * // => 6
                     *
                     * // returns a wrapped value
                     * var squares = wrapped.map(function(num) {
                     *   return num * num;
                     * });
                     *
                     * _.isArray(squares);
                     * // => false
                     *
                     * _.isArray(squares.value());
                     * // => true
                     */
                    function lodash(value) {
                        // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
                        return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__')) ?
                            value :
                            new lodashWrapper(value);
                    }

                    /**
                     * A fast path for creating `lodash` wrapper objects.
                     *
                     * @private
                     * @param {*} value The value to wrap in a `lodash` instance.
                     * @param {boolean} chainAll A flag to enable chaining for all methods
                     * @returns {Object} Returns a `lodash` instance.
                     */
                    function lodashWrapper(value, chainAll) {
                        this.__chain__ = !!chainAll;
                        this.__wrapped__ = value;
                    }
                    // ensure `new lodashWrapper` is an instance of `lodash`
                    lodashWrapper.prototype = lodash.prototype;

                    /**
                     * An object used to flag environments features.
                     *
                     * @static
                     * @memberOf _
                     * @type Object
                     */
                    var support = lodash.support = {};

                    /**
                     * Detect if functions can be decompiled by `Function#toString`
                     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
                     *
                     * @memberOf _.support
                     * @type boolean
                     */
                    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

                    /**
                     * Detect if `Function#name` is supported (all but IE).
                     *
                     * @memberOf _.support
                     * @type boolean
                     */
                    support.funcNames = typeof Function.name == 'string';

                    /**
                     * By default, the template delimiters used by Lo-Dash are similar to those in
                     * embedded Ruby (ERB). Change the following template settings to use alternative
                     * delimiters.
                     *
                     * @static
                     * @memberOf _
                     * @type Object
                     */
                    lodash.templateSettings = {

                        /**
                         * Used to detect `data` property values to be HTML-escaped.
                         *
                         * @memberOf _.templateSettings
                         * @type RegExp
                         */
                        'escape': /<%-([\s\S]+?)%>/g,

                        /**
                         * Used to detect code to be evaluated.
                         *
                         * @memberOf _.templateSettings
                         * @type RegExp
                         */
                        'evaluate': /<%([\s\S]+?)%>/g,

                        /**
                         * Used to detect `data` property values to inject.
                         *
                         * @memberOf _.templateSettings
                         * @type RegExp
                         */
                        'interpolate': reInterpolate,

                        /**
                         * Used to reference the data object in the template text.
                         *
                         * @memberOf _.templateSettings
                         * @type string
                         */
                        'variable': '',

                        /**
                         * Used to import variables into the compiled template.
                         *
                         * @memberOf _.templateSettings
                         * @type Object
                         */
                        'imports': {

                            /**
                             * A reference to the `lodash` function.
                             *
                             * @memberOf _.templateSettings.imports
                             * @type Function
                             */
                            '_': lodash
                        }
                    };

                    /*--------------------------------------------------------------------------*/

                    /**
                     * The base implementation of `_.bind` that creates the bound function and
                     * sets its meta data.
                     *
                     * @private
                     * @param {Array} bindData The bind data array.
                     * @returns {Function} Returns the new bound function.
                     */
                    function baseBind(bindData) {
                        var func = bindData[0],
                            partialArgs = bindData[2],
                            thisArg = bindData[4];

                        function bound() {
                            // `Function#bind` spec
                            // http://es5.github.io/#x15.3.4.5
                            if (partialArgs) {
                                // avoid `arguments` object deoptimizations by using `slice` instead
                                // of `Array.prototype.slice.call` and not assigning `arguments` to a
                                // variable as a ternary expression
                                var args = slice(partialArgs);
                                push.apply(args, arguments);
                            }
                            // mimic the constructor's `return` behavior
                            // http://es5.github.io/#x13.2.2
                            if (this instanceof bound) {
                                // ensure `new bound` is an instance of `func`
                                var thisBinding = baseCreate(func.prototype),
                                    result = func.apply(thisBinding, args || arguments);
                                return isObject(result) ? result : thisBinding;
                            }
                            return func.apply(thisArg, args || arguments);
                        }
                        setBindData(bound, bindData);
                        return bound;
                    }

                    /**
                     * The base implementation of `_.clone` without argument juggling or support
                     * for `thisArg` binding.
                     *
                     * @private
                     * @param {*} value The value to clone.
                     * @param {boolean} [isDeep=false] Specify a deep clone.
                     * @param {Function} [callback] The function to customize cloning values.
                     * @param {Array} [stackA=[]] Tracks traversed source objects.
                     * @param {Array} [stackB=[]] Associates clones with source counterparts.
                     * @returns {*} Returns the cloned value.
                     */
                    function baseClone(value, isDeep, callback, stackA, stackB) {
                        if (callback) {
                            var result = callback(value);
                            if (typeof result != 'undefined') {
                                return result;
                            }
                        }
                        // inspect [[Class]]
                        var isObj = isObject(value);
                        if (isObj) {
                            var className = toString.call(value);
                            if (!cloneableClasses[className]) {
                                return value;
                            }
                            var ctor = ctorByClass[className];
                            switch (className) {
                                case boolClass:
                                case dateClass:
                                    return new ctor(+value);

                                case numberClass:
                                case stringClass:
                                    return new ctor(value);

                                case regexpClass:
                                    result = ctor(value.source, reFlags.exec(value));
                                    result.lastIndex = value.lastIndex;
                                    return result;
                            }
                        } else {
                            return value;
                        }
                        var isArr = isArray(value);
                        if (isDeep) {
                            // check for circular references and return corresponding clone
                            var initedStack = !stackA;
                            stackA || (stackA = getArray());
                            stackB || (stackB = getArray());

                            var length = stackA.length;
                            while (length--) {
                                if (stackA[length] == value) {
                                    return stackB[length];
                                }
                            }
                            result = isArr ? ctor(value.length) : {};
                        } else {
                            result = isArr ? slice(value) : assign({}, value);
                        }
                        // add array properties assigned by `RegExp#exec`
                        if (isArr) {
                            if (hasOwnProperty.call(value, 'index')) {
                                result.index = value.index;
                            }
                            if (hasOwnProperty.call(value, 'input')) {
                                result.input = value.input;
                            }
                        }
                        // exit for shallow clone
                        if (!isDeep) {
                            return result;
                        }
                        // add the source value to the stack of traversed objects
                        // and associate it with its clone
                        stackA.push(value);
                        stackB.push(result);

                        // recursively populate clone (susceptible to call stack limits)
                        (isArr ? forEach : forOwn)(value, function(objValue, key) {
                            result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
                        });

                        if (initedStack) {
                            releaseArray(stackA);
                            releaseArray(stackB);
                        }
                        return result;
                    }

                    /**
                     * The base implementation of `_.create` without support for assigning
                     * properties to the created object.
                     *
                     * @private
                     * @param {Object} prototype The object to inherit from.
                     * @returns {Object} Returns the new object.
                     */
                    function baseCreate(prototype, properties) {
                        return isObject(prototype) ? nativeCreate(prototype) : {};
                    }
                    // fallback for browsers without `Object.create`
                    if (!nativeCreate) {
                        baseCreate = (function() {
                            function Object() {}
                            return function(prototype) {
                                if (isObject(prototype)) {
                                    Object.prototype = prototype;
                                    var result = new Object;
                                    Object.prototype = null;
                                }
                                return result || context.Object();
                            };
                        }());
                    }

                    /**
                     * The base implementation of `_.createCallback` without support for creating
                     * "_.pluck" or "_.where" style callbacks.
                     *
                     * @private
                     * @param {*} [func=identity] The value to convert to a callback.
                     * @param {*} [thisArg] The `this` binding of the created callback.
                     * @param {number} [argCount] The number of arguments the callback accepts.
                     * @returns {Function} Returns a callback function.
                     */
                    function baseCreateCallback(func, thisArg, argCount) {
                        if (typeof func != 'function') {
                            return identity;
                        }
                        // exit early for no `thisArg` or already bound by `Function#bind`
                        if (typeof thisArg == 'undefined' || !('prototype' in func)) {
                            return func;
                        }
                        var bindData = func.__bindData__;
                        if (typeof bindData == 'undefined') {
                            if (support.funcNames) {
                                bindData = !func.name;
                            }
                            bindData = bindData || !support.funcDecomp;
                            if (!bindData) {
                                var source = fnToString.call(func);
                                if (!support.funcNames) {
                                    bindData = !reFuncName.test(source);
                                }
                                if (!bindData) {
                                    // checks if `func` references the `this` keyword and stores the result
                                    bindData = reThis.test(source);
                                    setBindData(func, bindData);
                                }
                            }
                        }
                        // exit early if there are no `this` references or `func` is bound
                        if (bindData === false || (bindData !== true && bindData[1] & 1)) {
                            return func;
                        }
                        switch (argCount) {
                            case 1:
                                return function(value) {
                                    return func.call(thisArg, value);
                                };
                            case 2:
                                return function(a, b) {
                                    return func.call(thisArg, a, b);
                                };
                            case 3:
                                return function(value, index, collection) {
                                    return func.call(thisArg, value, index, collection);
                                };
                            case 4:
                                return function(accumulator, value, index, collection) {
                                    return func.call(thisArg, accumulator, value, index, collection);
                                };
                        }
                        return bind(func, thisArg);
                    }

                    /**
                     * The base implementation of `createWrapper` that creates the wrapper and
                     * sets its meta data.
                     *
                     * @private
                     * @param {Array} bindData The bind data array.
                     * @returns {Function} Returns the new function.
                     */
                    function baseCreateWrapper(bindData) {
                        var func = bindData[0],
                            bitmask = bindData[1],
                            partialArgs = bindData[2],
                            partialRightArgs = bindData[3],
                            thisArg = bindData[4],
                            arity = bindData[5];

                        var isBind = bitmask & 1,
                            isBindKey = bitmask & 2,
                            isCurry = bitmask & 4,
                            isCurryBound = bitmask & 8,
                            key = func;

                        function bound() {
                            var thisBinding = isBind ? thisArg : this;
                            if (partialArgs) {
                                var args = slice(partialArgs);
                                push.apply(args, arguments);
                            }
                            if (partialRightArgs || isCurry) {
                                args || (args = slice(arguments));
                                if (partialRightArgs) {
                                    push.apply(args, partialRightArgs);
                                }
                                if (isCurry && args.length < arity) {
                                    bitmask |= 16 & ~32;
                                    return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
                                }
                            }
                            args || (args = arguments);
                            if (isBindKey) {
                                func = thisBinding[key];
                            }
                            if (this instanceof bound) {
                                thisBinding = baseCreate(func.prototype);
                                var result = func.apply(thisBinding, args);
                                return isObject(result) ? result : thisBinding;
                            }
                            return func.apply(thisBinding, args);
                        }
                        setBindData(bound, bindData);
                        return bound;
                    }

                    /**
                     * The base implementation of `_.difference` that accepts a single array
                     * of values to exclude.
                     *
                     * @private
                     * @param {Array} array The array to process.
                     * @param {Array} [values] The array of values to exclude.
                     * @returns {Array} Returns a new array of filtered values.
                     */
                    function baseDifference(array, values) {
                        var index = -1,
                            indexOf = getIndexOf(),
                            length = array ? array.length : 0,
                            isLarge = length >= largeArraySize && indexOf === baseIndexOf,
                            result = [];

                        if (isLarge) {
                            var cache = createCache(values);
                            if (cache) {
                                indexOf = cacheIndexOf;
                                values = cache;
                            } else {
                                isLarge = false;
                            }
                        }
                        while (++index < length) {
                            var value = array[index];
                            if (indexOf(values, value) < 0) {
                                result.push(value);
                            }
                        }
                        if (isLarge) {
                            releaseObject(values);
                        }
                        return result;
                    }

                    /**
                     * The base implementation of `_.flatten` without support for callback
                     * shorthands or `thisArg` binding.
                     *
                     * @private
                     * @param {Array} array The array to flatten.
                     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
                     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
                     * @param {number} [fromIndex=0] The index to start from.
                     * @returns {Array} Returns a new flattened array.
                     */
                    function baseFlatten(array, isShallow, isStrict, fromIndex) {
                        var index = (fromIndex || 0) - 1,
                            length = array ? array.length : 0,
                            result = [];

                        while (++index < length) {
                            var value = array[index];

                            if (value && typeof value == 'object' && typeof value.length == 'number' &&
                                (isArray(value) || isArguments(value))) {
                                // recursively flatten arrays (susceptible to call stack limits)
                                if (!isShallow) {
                                    value = baseFlatten(value, isShallow, isStrict);
                                }
                                var valIndex = -1,
                                    valLength = value.length,
                                    resIndex = result.length;

                                result.length += valLength;
                                while (++valIndex < valLength) {
                                    result[resIndex++] = value[valIndex];
                                }
                            } else if (!isStrict) {
                                result.push(value);
                            }
                        }
                        return result;
                    }

                    /**
                     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
                     * that allows partial "_.where" style comparisons.
                     *
                     * @private
                     * @param {*} a The value to compare.
                     * @param {*} b The other value to compare.
                     * @param {Function} [callback] The function to customize comparing values.
                     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
                     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
                     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
                     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                     */
                    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
                        // used to indicate that when comparing objects, `a` has at least the properties of `b`
                        if (callback) {
                            var result = callback(a, b);
                            if (typeof result != 'undefined') {
                                return !!result;
                            }
                        }
                        // exit early for identical values
                        if (a === b) {
                            // treat `+0` vs. `-0` as not equal
                            return a !== 0 || (1 / a == 1 / b);
                        }
                        var type = typeof a,
                            otherType = typeof b;

                        // exit early for unlike primitive values
                        if (a === a &&
                            !(a && objectTypes[type]) &&
                            !(b && objectTypes[otherType])) {
                            return false;
                        }
                        // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
                        // http://es5.github.io/#x15.3.4.4
                        if (a == null || b == null) {
                            return a === b;
                        }
                        // compare [[Class]] names
                        var className = toString.call(a),
                            otherClass = toString.call(b);

                        if (className == argsClass) {
                            className = objectClass;
                        }
                        if (otherClass == argsClass) {
                            otherClass = objectClass;
                        }
                        if (className != otherClass) {
                            return false;
                        }
                        switch (className) {
                            case boolClass:
                            case dateClass:
                                // coerce dates and booleans to numbers, dates to milliseconds and booleans
                                // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
                                return +a == +b;

                            case numberClass:
                                // treat `NaN` vs. `NaN` as equal
                                return (a != +a) ?
                                    b != +b
                                    // but treat `+0` vs. `-0` as not equal
                                    :
                                    (a == 0 ? (1 / a == 1 / b) : a == +b);

                            case regexpClass:
                            case stringClass:
                                // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
                                // treat string primitives and their corresponding object instances as equal
                                return a == String(b);
                        }
                        var isArr = className == arrayClass;
                        if (!isArr) {
                            // unwrap any `lodash` wrapped values
                            var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
                                bWrapped = hasOwnProperty.call(b, '__wrapped__');

                            if (aWrapped || bWrapped) {
                                return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
                            }
                            // exit for functions and DOM nodes
                            if (className != objectClass) {
                                return false;
                            }
                            // in older versions of Opera, `arguments` objects have `Array` constructors
                            var ctorA = a.constructor,
                                ctorB = b.constructor;

                            // non `Object` object instances with different constructors are not equal
                            if (ctorA != ctorB &&
                                !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
                                ('constructor' in a && 'constructor' in b)
                            ) {
                                return false;
                            }
                        }
                        // assume cyclic structures are equal
                        // the algorithm for detecting cyclic structures is adapted from ES 5.1
                        // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
                        var initedStack = !stackA;
                        stackA || (stackA = getArray());
                        stackB || (stackB = getArray());

                        var length = stackA.length;
                        while (length--) {
                            if (stackA[length] == a) {
                                return stackB[length] == b;
                            }
                        }
                        var size = 0;
                        result = true;

                        // add `a` and `b` to the stack of traversed objects
                        stackA.push(a);
                        stackB.push(b);

                        // recursively compare objects and arrays (susceptible to call stack limits)
                        if (isArr) {
                            // compare lengths to determine if a deep comparison is necessary
                            length = a.length;
                            size = b.length;
                            result = size == length;

                            if (result || isWhere) {
                                // deep compare the contents, ignoring non-numeric properties
                                while (size--) {
                                    var index = length,
                                        value = b[size];

                                    if (isWhere) {
                                        while (index--) {
                                            if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                                                break;
                                            }
                                        }
                                    } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
                                        break;
                                    }
                                }
                            }
                        } else {
                            // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
                            // which, in this case, is more costly
                            forIn(b, function(value, key, b) {
                                if (hasOwnProperty.call(b, key)) {
                                    // count the number of properties.
                                    size++;
                                    // deep compare each property value.
                                    return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
                                }
                            });

                            if (result && !isWhere) {
                                // ensure both objects have the same number of properties
                                forIn(a, function(value, key, a) {
                                    if (hasOwnProperty.call(a, key)) {
                                        // `size` will be `-1` if `a` has more properties than `b`
                                        return (result = --size > -1);
                                    }
                                });
                            }
                        }
                        stackA.pop();
                        stackB.pop();

                        if (initedStack) {
                            releaseArray(stackA);
                            releaseArray(stackB);
                        }
                        return result;
                    }

                    /**
                     * The base implementation of `_.merge` without argument juggling or support
                     * for `thisArg` binding.
                     *
                     * @private
                     * @param {Object} object The destination object.
                     * @param {Object} source The source object.
                     * @param {Function} [callback] The function to customize merging properties.
                     * @param {Array} [stackA=[]] Tracks traversed source objects.
                     * @param {Array} [stackB=[]] Associates values with source counterparts.
                     */
                    function baseMerge(object, source, callback, stackA, stackB) {
                        (isArray(source) ? forEach : forOwn)(source, function(source, key) {
                            var found,
                                isArr,
                                result = source,
                                value = object[key];

                            if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
                                // avoid merging previously merged cyclic sources
                                var stackLength = stackA.length;
                                while (stackLength--) {
                                    if ((found = stackA[stackLength] == source)) {
                                        value = stackB[stackLength];
                                        break;
                                    }
                                }
                                if (!found) {
                                    var isShallow;
                                    if (callback) {
                                        result = callback(value, source);
                                        if ((isShallow = typeof result != 'undefined')) {
                                            value = result;
                                        }
                                    }
                                    if (!isShallow) {
                                        value = isArr ?
                                            (isArray(value) ? value : []) :
                                            (isPlainObject(value) ? value : {});
                                    }
                                    // add `source` and associated `value` to the stack of traversed objects
                                    stackA.push(source);
                                    stackB.push(value);

                                    // recursively merge objects and arrays (susceptible to call stack limits)
                                    if (!isShallow) {
                                        baseMerge(value, source, callback, stackA, stackB);
                                    }
                                }
                            } else {
                                if (callback) {
                                    result = callback(value, source);
                                    if (typeof result == 'undefined') {
                                        result = source;
                                    }
                                }
                                if (typeof result != 'undefined') {
                                    value = result;
                                }
                            }
                            object[key] = value;
                        });
                    }

                    /**
                     * The base implementation of `_.random` without argument juggling or support
                     * for returning floating-point numbers.
                     *
                     * @private
                     * @param {number} min The minimum possible value.
                     * @param {number} max The maximum possible value.
                     * @returns {number} Returns a random number.
                     */
                    function baseRandom(min, max) {
                        return min + floor(nativeRandom() * (max - min + 1));
                    }

                    /**
                     * The base implementation of `_.uniq` without support for callback shorthands
                     * or `thisArg` binding.
                     *
                     * @private
                     * @param {Array} array The array to process.
                     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
                     * @param {Function} [callback] The function called per iteration.
                     * @returns {Array} Returns a duplicate-value-free array.
                     */
                    function baseUniq(array, isSorted, callback) {
                        var index = -1,
                            indexOf = getIndexOf(),
                            length = array ? array.length : 0,
                            result = [];

                        var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
                            seen = (callback || isLarge) ? getArray() : result;

                        if (isLarge) {
                            var cache = createCache(seen);
                            indexOf = cacheIndexOf;
                            seen = cache;
                        }
                        while (++index < length) {
                            var value = array[index],
                                computed = callback ? callback(value, index, array) : value;

                            if (isSorted ?
                                !index || seen[seen.length - 1] !== computed :
                                indexOf(seen, computed) < 0
                            ) {
                                if (callback || isLarge) {
                                    seen.push(computed);
                                }
                                result.push(value);
                            }
                        }
                        if (isLarge) {
                            releaseArray(seen.array);
                            releaseObject(seen);
                        } else if (callback) {
                            releaseArray(seen);
                        }
                        return result;
                    }

                    /**
                     * Creates a function that aggregates a collection, creating an object composed
                     * of keys generated from the results of running each element of the collection
                     * through a callback. The given `setter` function sets the keys and values
                     * of the composed object.
                     *
                     * @private
                     * @param {Function} setter The setter function.
                     * @returns {Function} Returns the new aggregator function.
                     */
                    function createAggregator(setter) {
                        return function(collection, callback, thisArg) {
                            var result = {};
                            callback = lodash.createCallback(callback, thisArg, 3);

                            var index = -1,
                                length = collection ? collection.length : 0;

                            if (typeof length == 'number') {
                                while (++index < length) {
                                    var value = collection[index];
                                    setter(result, value, callback(value, index, collection), collection);
                                }
                            } else {
                                forOwn(collection, function(value, key, collection) {
                                    setter(result, value, callback(value, key, collection), collection);
                                });
                            }
                            return result;
                        };
                    }

                    /**
                     * Creates a function that, when called, either curries or invokes `func`
                     * with an optional `this` binding and partially applied arguments.
                     *
                     * @private
                     * @param {Function|string} func The function or method name to reference.
                     * @param {number} bitmask The bitmask of method flags to compose.
                     *  The bitmask may be composed of the following flags:
                     *  1 - `_.bind`
                     *  2 - `_.bindKey`
                     *  4 - `_.curry`
                     *  8 - `_.curry` (bound)
                     *  16 - `_.partial`
                     *  32 - `_.partialRight`
                     * @param {Array} [partialArgs] An array of arguments to prepend to those
                     *  provided to the new function.
                     * @param {Array} [partialRightArgs] An array of arguments to append to those
                     *  provided to the new function.
                     * @param {*} [thisArg] The `this` binding of `func`.
                     * @param {number} [arity] The arity of `func`.
                     * @returns {Function} Returns the new function.
                     */
                    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
                        var isBind = bitmask & 1,
                            isBindKey = bitmask & 2,
                            isCurry = bitmask & 4,
                            isCurryBound = bitmask & 8,
                            isPartial = bitmask & 16,
                            isPartialRight = bitmask & 32;

                        if (!isBindKey && !isFunction(func)) {
                            throw new TypeError;
                        }
                        if (isPartial && !partialArgs.length) {
                            bitmask &= ~16;
                            isPartial = partialArgs = false;
                        }
                        if (isPartialRight && !partialRightArgs.length) {
                            bitmask &= ~32;
                            isPartialRight = partialRightArgs = false;
                        }
                        var bindData = func && func.__bindData__;
                        if (bindData && bindData !== true) {
                            // clone `bindData`
                            bindData = slice(bindData);
                            if (bindData[2]) {
                                bindData[2] = slice(bindData[2]);
                            }
                            if (bindData[3]) {
                                bindData[3] = slice(bindData[3]);
                            }
                            // set `thisBinding` is not previously bound
                            if (isBind && !(bindData[1] & 1)) {
                                bindData[4] = thisArg;
                            }
                            // set if previously bound but not currently (subsequent curried functions)
                            if (!isBind && bindData[1] & 1) {
                                bitmask |= 8;
                            }
                            // set curried arity if not yet set
                            if (isCurry && !(bindData[1] & 4)) {
                                bindData[5] = arity;
                            }
                            // append partial left arguments
                            if (isPartial) {
                                push.apply(bindData[2] || (bindData[2] = []), partialArgs);
                            }
                            // append partial right arguments
                            if (isPartialRight) {
                                unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
                            }
                            // merge flags
                            bindData[1] |= bitmask;
                            return createWrapper.apply(null, bindData);
                        }
                        // fast path for `_.bind`
                        var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
                        return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
                    }

                    /**
                     * Used by `escape` to convert characters to HTML entities.
                     *
                     * @private
                     * @param {string} match The matched character to escape.
                     * @returns {string} Returns the escaped character.
                     */
                    function escapeHtmlChar(match) {
                        return htmlEscapes[match];
                    }

                    /**
                     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
                     * customized, this method returns the custom method, otherwise it returns
                     * the `baseIndexOf` function.
                     *
                     * @private
                     * @returns {Function} Returns the "indexOf" function.
                     */
                    function getIndexOf() {
                        var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
                        return result;
                    }

                    /**
                     * Checks if `value` is a native function.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
                     */
                    function isNative(value) {
                        return typeof value == 'function' && reNative.test(value);
                    }

                    /**
                     * Sets `this` binding data on a given function.
                     *
                     * @private
                     * @param {Function} func The function to set data on.
                     * @param {Array} value The data array to set.
                     */
                    var setBindData = !defineProperty ? noop : function(func, value) {
                        descriptor.value = value;
                        defineProperty(func, '__bindData__', descriptor);
                        descriptor.value = null;
                    };

                    /**
                     * A fallback implementation of `isPlainObject` which checks if a given value
                     * is an object created by the `Object` constructor, assuming objects created
                     * by the `Object` constructor have no inherited enumerable properties and that
                     * there are no `Object.prototype` extensions.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
                     */
                    function shimIsPlainObject(value) {
                        var ctor,
                            result;

                        // avoid non Object objects, `arguments` objects, and DOM elements
                        if (!(value && toString.call(value) == objectClass) ||
                            (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
                            return false;
                        }
                        // In most environments an object's own properties are iterated before
                        // its inherited properties. If the last iterated property is an object's
                        // own property then there are no inherited enumerable properties.
                        forIn(value, function(value, key) {
                            result = key;
                        });
                        return typeof result == 'undefined' || hasOwnProperty.call(value, result);
                    }

                    /**
                     * Used by `unescape` to convert HTML entities to characters.
                     *
                     * @private
                     * @param {string} match The matched character to unescape.
                     * @returns {string} Returns the unescaped character.
                     */
                    function unescapeHtmlChar(match) {
                        return htmlUnescapes[match];
                    }

                    /*--------------------------------------------------------------------------*/

                    /**
                     * Checks if `value` is an `arguments` object.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
                     * @example
                     *
                     * (function() { return _.isArguments(arguments); })(1, 2, 3);
                     * // => true
                     *
                     * _.isArguments([1, 2, 3]);
                     * // => false
                     */
                    function isArguments(value) {
                        return value && typeof value == 'object' && typeof value.length == 'number' &&
                            toString.call(value) == argsClass || false;
                    }

                    /**
                     * Checks if `value` is an array.
                     *
                     * @static
                     * @memberOf _
                     * @type Function
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
                     * @example
                     *
                     * (function() { return _.isArray(arguments); })();
                     * // => false
                     *
                     * _.isArray([1, 2, 3]);
                     * // => true
                     */
                    var isArray = nativeIsArray || function(value) {
                        return value && typeof value == 'object' && typeof value.length == 'number' &&
                            toString.call(value) == arrayClass || false;
                    };

                    /**
                     * A fallback implementation of `Object.keys` which produces an array of the
                     * given object's own enumerable property names.
                     *
                     * @private
                     * @type Function
                     * @param {Object} object The object to inspect.
                     * @returns {Array} Returns an array of property names.
                     */
                    var shimKeys = function(object) {
                        var index, iterable = object,
                            result = [];
                        if (!iterable) return result;
                        if (!(objectTypes[typeof object])) return result;
                        for (index in iterable) {
                            if (hasOwnProperty.call(iterable, index)) {
                                result.push(index);
                            }
                        }
                        return result
                    };

                    /**
                     * Creates an array composed of the own enumerable property names of an object.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The object to inspect.
                     * @returns {Array} Returns an array of property names.
                     * @example
                     *
                     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
                     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
                     */
                    var keys = !nativeKeys ? shimKeys : function(object) {
                        if (!isObject(object)) {
                            return [];
                        }
                        return nativeKeys(object);
                    };

                    /**
                     * Used to convert characters to HTML entities:
                     *
                     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
                     * don't require escaping in HTML and have no special meaning unless they're part
                     * of a tag or an unquoted attribute value.
                     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
                     */
                    var htmlEscapes = {
                        '&': '&amp;',
                        '<': '&lt;',
                        '>': '&gt;',
                        '"': '&quot;',
                        "'": '&#39;'
                    };

                    /** Used to convert HTML entities to characters */
                    var htmlUnescapes = invert(htmlEscapes);

                    /** Used to match HTML entities and HTML characters */
                    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
                        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');

                    /*--------------------------------------------------------------------------*/

                    /**
                     * Assigns own enumerable properties of source object(s) to the destination
                     * object. Subsequent sources will overwrite property assignments of previous
                     * sources. If a callback is provided it will be executed to produce the
                     * assigned values. The callback is bound to `thisArg` and invoked with two
                     * arguments; (objectValue, sourceValue).
                     *
                     * @static
                     * @memberOf _
                     * @type Function
                     * @alias extend
                     * @category Objects
                     * @param {Object} object The destination object.
                     * @param {...Object} [source] The source objects.
                     * @param {Function} [callback] The function to customize assigning values.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns the destination object.
                     * @example
                     *
                     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
                     * // => { 'name': 'fred', 'employer': 'slate' }
                     *
                     * var defaults = _.partialRight(_.assign, function(a, b) {
                     *   return typeof a == 'undefined' ? b : a;
                     * });
                     *
                     * var object = { 'name': 'barney' };
                     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
                     * // => { 'name': 'barney', 'employer': 'slate' }
                     */
                    var assign = function(object, source, guard) {
                        var index, iterable = object,
                            result = iterable;
                        if (!iterable) return result;
                        var args = arguments,
                            argsIndex = 0,
                            argsLength = typeof guard == 'number' ? 2 : args.length;
                        if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
                            var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
                        } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
                            callback = args[--argsLength];
                        }
                        while (++argsIndex < argsLength) {
                            iterable = args[argsIndex];
                            if (iterable && objectTypes[typeof iterable]) {
                                var ownIndex = -1,
                                    ownProps = objectTypes[typeof iterable] && keys(iterable),
                                    length = ownProps ? ownProps.length : 0;

                                while (++ownIndex < length) {
                                    index = ownProps[ownIndex];
                                    result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
                                }
                            }
                        }
                        return result
                    };

                    /**
                     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
                     * be cloned, otherwise they will be assigned by reference. If a callback
                     * is provided it will be executed to produce the cloned values. If the
                     * callback returns `undefined` cloning will be handled by the method instead.
                     * The callback is bound to `thisArg` and invoked with one argument; (value).
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to clone.
                     * @param {boolean} [isDeep=false] Specify a deep clone.
                     * @param {Function} [callback] The function to customize cloning values.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the cloned value.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36 },
                     *   { 'name': 'fred',   'age': 40 }
                     * ];
                     *
                     * var shallow = _.clone(characters);
                     * shallow[0] === characters[0];
                     * // => true
                     *
                     * var deep = _.clone(characters, true);
                     * deep[0] === characters[0];
                     * // => false
                     *
                     * _.mixin({
                     *   'clone': _.partialRight(_.clone, function(value) {
                     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
                     *   })
                     * });
                     *
                     * var clone = _.clone(document.body);
                     * clone.childNodes.length;
                     * // => 0
                     */
                    function clone(value, isDeep, callback, thisArg) {
                        // allows working with "Collections" methods without using their `index`
                        // and `collection` arguments for `isDeep` and `callback`
                        if (typeof isDeep != 'boolean' && isDeep != null) {
                            thisArg = callback;
                            callback = isDeep;
                            isDeep = false;
                        }
                        return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
                    }

                    /**
                     * Creates a deep clone of `value`. If a callback is provided it will be
                     * executed to produce the cloned values. If the callback returns `undefined`
                     * cloning will be handled by the method instead. The callback is bound to
                     * `thisArg` and invoked with one argument; (value).
                     *
                     * Note: This method is loosely based on the structured clone algorithm. Functions
                     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
                     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
                     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to deep clone.
                     * @param {Function} [callback] The function to customize cloning values.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the deep cloned value.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36 },
                     *   { 'name': 'fred',   'age': 40 }
                     * ];
                     *
                     * var deep = _.cloneDeep(characters);
                     * deep[0] === characters[0];
                     * // => false
                     *
                     * var view = {
                     *   'label': 'docs',
                     *   'node': element
                     * };
                     *
                     * var clone = _.cloneDeep(view, function(value) {
                     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
                     * });
                     *
                     * clone.node == view.node;
                     * // => false
                     */
                    function cloneDeep(value, callback, thisArg) {
                        return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
                    }

                    /**
                     * Creates an object that inherits from the given `prototype` object. If a
                     * `properties` object is provided its own enumerable properties are assigned
                     * to the created object.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} prototype The object to inherit from.
                     * @param {Object} [properties] The properties to assign to the object.
                     * @returns {Object} Returns the new object.
                     * @example
                     *
                     * function Shape() {
                     *   this.x = 0;
                     *   this.y = 0;
                     * }
                     *
                     * function Circle() {
                     *   Shape.call(this);
                     * }
                     *
                     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
                     *
                     * var circle = new Circle;
                     * circle instanceof Circle;
                     * // => true
                     *
                     * circle instanceof Shape;
                     * // => true
                     */
                    function create(prototype, properties) {
                        var result = baseCreate(prototype);
                        return properties ? assign(result, properties) : result;
                    }

                    /**
                     * Assigns own enumerable properties of source object(s) to the destination
                     * object for all destination properties that resolve to `undefined`. Once a
                     * property is set, additional defaults of the same property will be ignored.
                     *
                     * @static
                     * @memberOf _
                     * @type Function
                     * @category Objects
                     * @param {Object} object The destination object.
                     * @param {...Object} [source] The source objects.
                     * @param- {Object} [guard] Allows working with `_.reduce` without using its
                     *  `key` and `object` arguments as sources.
                     * @returns {Object} Returns the destination object.
                     * @example
                     *
                     * var object = { 'name': 'barney' };
                     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
                     * // => { 'name': 'barney', 'employer': 'slate' }
                     */
                    var defaults = function(object, source, guard) {
                        var index, iterable = object,
                            result = iterable;
                        if (!iterable) return result;
                        var args = arguments,
                            argsIndex = 0,
                            argsLength = typeof guard == 'number' ? 2 : args.length;
                        while (++argsIndex < argsLength) {
                            iterable = args[argsIndex];
                            if (iterable && objectTypes[typeof iterable]) {
                                var ownIndex = -1,
                                    ownProps = objectTypes[typeof iterable] && keys(iterable),
                                    length = ownProps ? ownProps.length : 0;

                                while (++ownIndex < length) {
                                    index = ownProps[ownIndex];
                                    if (typeof result[index] == 'undefined') result[index] = iterable[index];
                                }
                            }
                        }
                        return result
                    };

                    /**
                     * This method is like `_.findIndex` except that it returns the key of the
                     * first element that passes the callback check, instead of the element itself.
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The object to search.
                     * @param {Function|Object|string} [callback=identity] The function called per
                     *  iteration. If a property name or object is provided it will be used to
                     *  create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
                     * @example
                     *
                     * var characters = {
                     *   'barney': {  'age': 36, 'blocked': false },
                     *   'fred': {    'age': 40, 'blocked': true },
                     *   'pebbles': { 'age': 1,  'blocked': false }
                     * };
                     *
                     * _.findKey(characters, function(chr) {
                     *   return chr.age < 40;
                     * });
                     * // => 'barney' (property order is not guaranteed across environments)
                     *
                     * // using "_.where" callback shorthand
                     * _.findKey(characters, { 'age': 1 });
                     * // => 'pebbles'
                     *
                     * // using "_.pluck" callback shorthand
                     * _.findKey(characters, 'blocked');
                     * // => 'fred'
                     */
                    function findKey(object, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forOwn(object, function(value, key, object) {
                            if (callback(value, key, object)) {
                                result = key;
                                return false;
                            }
                        });
                        return result;
                    }

                    /**
                     * This method is like `_.findKey` except that it iterates over elements
                     * of a `collection` in the opposite order.
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The object to search.
                     * @param {Function|Object|string} [callback=identity] The function called per
                     *  iteration. If a property name or object is provided it will be used to
                     *  create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
                     * @example
                     *
                     * var characters = {
                     *   'barney': {  'age': 36, 'blocked': true },
                     *   'fred': {    'age': 40, 'blocked': false },
                     *   'pebbles': { 'age': 1,  'blocked': true }
                     * };
                     *
                     * _.findLastKey(characters, function(chr) {
                     *   return chr.age < 40;
                     * });
                     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
                     *
                     * // using "_.where" callback shorthand
                     * _.findLastKey(characters, { 'age': 40 });
                     * // => 'fred'
                     *
                     * // using "_.pluck" callback shorthand
                     * _.findLastKey(characters, 'blocked');
                     * // => 'pebbles'
                     */
                    function findLastKey(object, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forOwnRight(object, function(value, key, object) {
                            if (callback(value, key, object)) {
                                result = key;
                                return false;
                            }
                        });
                        return result;
                    }

                    /**
                     * Iterates over own and inherited enumerable properties of an object,
                     * executing the callback for each property. The callback is bound to `thisArg`
                     * and invoked with three arguments; (value, key, object). Callbacks may exit
                     * iteration early by explicitly returning `false`.
                     *
                     * @static
                     * @memberOf _
                     * @type Function
                     * @category Objects
                     * @param {Object} object The object to iterate over.
                     * @param {Function} [callback=identity] The function called per iteration.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * function Shape() {
                     *   this.x = 0;
                     *   this.y = 0;
                     * }
                     *
                     * Shape.prototype.move = function(x, y) {
                     *   this.x += x;
                     *   this.y += y;
                     * };
                     *
                     * _.forIn(new Shape, function(value, key) {
                     *   console.log(key);
                     * });
                     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
                     */
                    var forIn = function(collection, callback, thisArg) {
                        var index, iterable = collection,
                            result = iterable;
                        if (!iterable) return result;
                        if (!objectTypes[typeof iterable]) return result;
                        callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
                        for (index in iterable) {
                            if (callback(iterable[index], index, collection) === false) return result;
                        }
                        return result
                    };

                    /**
                     * This method is like `_.forIn` except that it iterates over elements
                     * of a `collection` in the opposite order.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The object to iterate over.
                     * @param {Function} [callback=identity] The function called per iteration.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * function Shape() {
                     *   this.x = 0;
                     *   this.y = 0;
                     * }
                     *
                     * Shape.prototype.move = function(x, y) {
                     *   this.x += x;
                     *   this.y += y;
                     * };
                     *
                     * _.forInRight(new Shape, function(value, key) {
                     *   console.log(key);
                     * });
                     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
                     */
                    function forInRight(object, callback, thisArg) {
                        var pairs = [];

                        forIn(object, function(value, key) {
                            pairs.push(key, value);
                        });

                        var length = pairs.length;
                        callback = baseCreateCallback(callback, thisArg, 3);
                        while (length--) {
                            if (callback(pairs[length--], pairs[length], object) === false) {
                                break;
                            }
                        }
                        return object;
                    }

                    /**
                     * Iterates over own enumerable properties of an object, executing the callback
                     * for each property. The callback is bound to `thisArg` and invoked with three
                     * arguments; (value, key, object). Callbacks may exit iteration early by
                     * explicitly returning `false`.
                     *
                     * @static
                     * @memberOf _
                     * @type Function
                     * @category Objects
                     * @param {Object} object The object to iterate over.
                     * @param {Function} [callback=identity] The function called per iteration.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
                     *   console.log(key);
                     * });
                     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
                     */
                    var forOwn = function(collection, callback, thisArg) {
                        var index, iterable = collection,
                            result = iterable;
                        if (!iterable) return result;
                        if (!objectTypes[typeof iterable]) return result;
                        callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
                        var ownIndex = -1,
                            ownProps = objectTypes[typeof iterable] && keys(iterable),
                            length = ownProps ? ownProps.length : 0;

                        while (++ownIndex < length) {
                            index = ownProps[ownIndex];
                            if (callback(iterable[index], index, collection) === false) return result;
                        }
                        return result
                    };

                    /**
                     * This method is like `_.forOwn` except that it iterates over elements
                     * of a `collection` in the opposite order.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The object to iterate over.
                     * @param {Function} [callback=identity] The function called per iteration.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
                     *   console.log(key);
                     * });
                     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
                     */
                    function forOwnRight(object, callback, thisArg) {
                        var props = keys(object),
                            length = props.length;

                        callback = baseCreateCallback(callback, thisArg, 3);
                        while (length--) {
                            var key = props[length];
                            if (callback(object[key], key, object) === false) {
                                break;
                            }
                        }
                        return object;
                    }

                    /**
                     * Creates a sorted array of property names of all enumerable properties,
                     * own and inherited, of `object` that have function values.
                     *
                     * @static
                     * @memberOf _
                     * @alias methods
                     * @category Objects
                     * @param {Object} object The object to inspect.
                     * @returns {Array} Returns an array of property names that have function values.
                     * @example
                     *
                     * _.functions(_);
                     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
                     */
                    function functions(object) {
                        var result = [];
                        forIn(object, function(value, key) {
                            if (isFunction(value)) {
                                result.push(key);
                            }
                        });
                        return result.sort();
                    }

                    /**
                     * Checks if the specified property name exists as a direct property of `object`,
                     * instead of an inherited property.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The object to inspect.
                     * @param {string} key The name of the property to check.
                     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
                     * @example
                     *
                     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
                     * // => true
                     */
                    function has(object, key) {
                        return object ? hasOwnProperty.call(object, key) : false;
                    }

                    /**
                     * Creates an object composed of the inverted keys and values of the given object.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The object to invert.
                     * @returns {Object} Returns the created inverted object.
                     * @example
                     *
                     * _.invert({ 'first': 'fred', 'second': 'barney' });
                     * // => { 'fred': 'first', 'barney': 'second' }
                     */
                    function invert(object) {
                        var index = -1,
                            props = keys(object),
                            length = props.length,
                            result = {};

                        while (++index < length) {
                            var key = props[index];
                            result[object[key]] = key;
                        }
                        return result;
                    }

                    /**
                     * Checks if `value` is a boolean value.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
                     * @example
                     *
                     * _.isBoolean(null);
                     * // => false
                     */
                    function isBoolean(value) {
                        return value === true || value === false ||
                            value && typeof value == 'object' && toString.call(value) == boolClass || false;
                    }

                    /**
                     * Checks if `value` is a date.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
                     * @example
                     *
                     * _.isDate(new Date);
                     * // => true
                     */
                    function isDate(value) {
                        return value && typeof value == 'object' && toString.call(value) == dateClass || false;
                    }

                    /**
                     * Checks if `value` is a DOM element.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
                     * @example
                     *
                     * _.isElement(document.body);
                     * // => true
                     */
                    function isElement(value) {
                        return value && value.nodeType === 1 || false;
                    }

                    /**
                     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
                     * length of `0` and objects with no own enumerable properties are considered
                     * "empty".
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Array|Object|string} value The value to inspect.
                     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
                     * @example
                     *
                     * _.isEmpty([1, 2, 3]);
                     * // => false
                     *
                     * _.isEmpty({});
                     * // => true
                     *
                     * _.isEmpty('');
                     * // => true
                     */
                    function isEmpty(value) {
                        var result = true;
                        if (!value) {
                            return result;
                        }
                        var className = toString.call(value),
                            length = value.length;

                        if ((className == arrayClass || className == stringClass || className == argsClass) ||
                            (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
                            return !length;
                        }
                        forOwn(value, function() {
                            return (result = false);
                        });
                        return result;
                    }

                    /**
                     * Performs a deep comparison between two values to determine if they are
                     * equivalent to each other. If a callback is provided it will be executed
                     * to compare values. If the callback returns `undefined` comparisons will
                     * be handled by the method instead. The callback is bound to `thisArg` and
                     * invoked with two arguments; (a, b).
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} a The value to compare.
                     * @param {*} b The other value to compare.
                     * @param {Function} [callback] The function to customize comparing values.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                     * @example
                     *
                     * var object = { 'name': 'fred' };
                     * var copy = { 'name': 'fred' };
                     *
                     * object == copy;
                     * // => false
                     *
                     * _.isEqual(object, copy);
                     * // => true
                     *
                     * var words = ['hello', 'goodbye'];
                     * var otherWords = ['hi', 'goodbye'];
                     *
                     * _.isEqual(words, otherWords, function(a, b) {
                     *   var reGreet = /^(?:hello|hi)$/i,
                     *       aGreet = _.isString(a) && reGreet.test(a),
                     *       bGreet = _.isString(b) && reGreet.test(b);
                     *
                     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
                     * });
                     * // => true
                     */
                    function isEqual(a, b, callback, thisArg) {
                        return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
                    }

                    /**
                     * Checks if `value` is, or can be coerced to, a finite number.
                     *
                     * Note: This is not the same as native `isFinite` which will return true for
                     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
                     * @example
                     *
                     * _.isFinite(-101);
                     * // => true
                     *
                     * _.isFinite('10');
                     * // => true
                     *
                     * _.isFinite(true);
                     * // => false
                     *
                     * _.isFinite('');
                     * // => false
                     *
                     * _.isFinite(Infinity);
                     * // => false
                     */
                    function isFinite(value) {
                        return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
                    }

                    /**
                     * Checks if `value` is a function.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
                     * @example
                     *
                     * _.isFunction(_);
                     * // => true
                     */
                    function isFunction(value) {
                        return typeof value == 'function';
                    }

                    /**
                     * Checks if `value` is the language type of Object.
                     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
                     * @example
                     *
                     * _.isObject({});
                     * // => true
                     *
                     * _.isObject([1, 2, 3]);
                     * // => true
                     *
                     * _.isObject(1);
                     * // => false
                     */
                    function isObject(value) {
                        // check if the value is the ECMAScript language type of Object
                        // http://es5.github.io/#x8
                        // and avoid a V8 bug
                        // http://code.google.com/p/v8/issues/detail?id=2291
                        return !!(value && objectTypes[typeof value]);
                    }

                    /**
                     * Checks if `value` is `NaN`.
                     *
                     * Note: This is not the same as native `isNaN` which will return `true` for
                     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
                     * @example
                     *
                     * _.isNaN(NaN);
                     * // => true
                     *
                     * _.isNaN(new Number(NaN));
                     * // => true
                     *
                     * isNaN(undefined);
                     * // => true
                     *
                     * _.isNaN(undefined);
                     * // => false
                     */
                    function isNaN(value) {
                        // `NaN` as a primitive is the only value that is not equal to itself
                        // (perform the [[Class]] check first to avoid errors with some host objects in IE)
                        return isNumber(value) && value != +value;
                    }

                    /**
                     * Checks if `value` is `null`.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
                     * @example
                     *
                     * _.isNull(null);
                     * // => true
                     *
                     * _.isNull(undefined);
                     * // => false
                     */
                    function isNull(value) {
                        return value === null;
                    }

                    /**
                     * Checks if `value` is a number.
                     *
                     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
                     * @example
                     *
                     * _.isNumber(8.4 * 5);
                     * // => true
                     */
                    function isNumber(value) {
                        return typeof value == 'number' ||
                            value && typeof value == 'object' && toString.call(value) == numberClass || false;
                    }

                    /**
                     * Checks if `value` is an object created by the `Object` constructor.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
                     * @example
                     *
                     * function Shape() {
                     *   this.x = 0;
                     *   this.y = 0;
                     * }
                     *
                     * _.isPlainObject(new Shape);
                     * // => false
                     *
                     * _.isPlainObject([1, 2, 3]);
                     * // => false
                     *
                     * _.isPlainObject({ 'x': 0, 'y': 0 });
                     * // => true
                     */
                    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
                        if (!(value && toString.call(value) == objectClass)) {
                            return false;
                        }
                        var valueOf = value.valueOf,
                            objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

                        return objProto ?
                            (value == objProto || getPrototypeOf(value) == objProto) :
                            shimIsPlainObject(value);
                    };

                    /**
                     * Checks if `value` is a regular expression.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
                     * @example
                     *
                     * _.isRegExp(/fred/);
                     * // => true
                     */
                    function isRegExp(value) {
                        return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
                    }

                    /**
                     * Checks if `value` is a string.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
                     * @example
                     *
                     * _.isString('fred');
                     * // => true
                     */
                    function isString(value) {
                        return typeof value == 'string' ||
                            value && typeof value == 'object' && toString.call(value) == stringClass || false;
                    }

                    /**
                     * Checks if `value` is `undefined`.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
                     * @example
                     *
                     * _.isUndefined(void 0);
                     * // => true
                     */
                    function isUndefined(value) {
                        return typeof value == 'undefined';
                    }

                    /**
                     * Creates an object with the same keys as `object` and values generated by
                     * running each own enumerable property of `object` through the callback.
                     * The callback is bound to `thisArg` and invoked with three arguments;
                     * (value, key, object).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The object to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns a new object with values of the results of each `callback` execution.
                     * @example
                     *
                     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
                     * // => { 'a': 3, 'b': 6, 'c': 9 }
                     *
                     * var characters = {
                     *   'fred': { 'name': 'fred', 'age': 40 },
                     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
                     * };
                     *
                     * // using "_.pluck" callback shorthand
                     * _.mapValues(characters, 'age');
                     * // => { 'fred': 40, 'pebbles': 1 }
                     */
                    function mapValues(object, callback, thisArg) {
                        var result = {};
                        callback = lodash.createCallback(callback, thisArg, 3);

                        forOwn(object, function(value, key, object) {
                            result[key] = callback(value, key, object);
                        });
                        return result;
                    }

                    /**
                     * Recursively merges own enumerable properties of the source object(s), that
                     * don't resolve to `undefined` into the destination object. Subsequent sources
                     * will overwrite property assignments of previous sources. If a callback is
                     * provided it will be executed to produce the merged values of the destination
                     * and source properties. If the callback returns `undefined` merging will
                     * be handled by the method instead. The callback is bound to `thisArg` and
                     * invoked with two arguments; (objectValue, sourceValue).
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The destination object.
                     * @param {...Object} [source] The source objects.
                     * @param {Function} [callback] The function to customize merging properties.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns the destination object.
                     * @example
                     *
                     * var names = {
                     *   'characters': [
                     *     { 'name': 'barney' },
                     *     { 'name': 'fred' }
                     *   ]
                     * };
                     *
                     * var ages = {
                     *   'characters': [
                     *     { 'age': 36 },
                     *     { 'age': 40 }
                     *   ]
                     * };
                     *
                     * _.merge(names, ages);
                     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
                     *
                     * var food = {
                     *   'fruits': ['apple'],
                     *   'vegetables': ['beet']
                     * };
                     *
                     * var otherFood = {
                     *   'fruits': ['banana'],
                     *   'vegetables': ['carrot']
                     * };
                     *
                     * _.merge(food, otherFood, function(a, b) {
                     *   return _.isArray(a) ? a.concat(b) : undefined;
                     * });
                     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
                     */
                    function merge(object) {
                        var args = arguments,
                            length = 2;

                        if (!isObject(object)) {
                            return object;
                        }
                        // allows working with `_.reduce` and `_.reduceRight` without using
                        // their `index` and `collection` arguments
                        if (typeof args[2] != 'number') {
                            length = args.length;
                        }
                        if (length > 3 && typeof args[length - 2] == 'function') {
                            var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
                        } else if (length > 2 && typeof args[length - 1] == 'function') {
                            callback = args[--length];
                        }
                        var sources = slice(arguments, 1, length),
                            index = -1,
                            stackA = getArray(),
                            stackB = getArray();

                        while (++index < length) {
                            baseMerge(object, sources[index], callback, stackA, stackB);
                        }
                        releaseArray(stackA);
                        releaseArray(stackB);
                        return object;
                    }

                    /**
                     * Creates a shallow clone of `object` excluding the specified properties.
                     * Property names may be specified as individual arguments or as arrays of
                     * property names. If a callback is provided it will be executed for each
                     * property of `object` omitting the properties the callback returns truey
                     * for. The callback is bound to `thisArg` and invoked with three arguments;
                     * (value, key, object).
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The source object.
                     * @param {Function|...string|string[]} [callback] The properties to omit or the
                     *  function called per iteration.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns an object without the omitted properties.
                     * @example
                     *
                     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
                     * // => { 'name': 'fred' }
                     *
                     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
                     *   return typeof value == 'number';
                     * });
                     * // => { 'name': 'fred' }
                     */
                    function omit(object, callback, thisArg) {
                        var result = {};
                        if (typeof callback != 'function') {
                            var props = [];
                            forIn(object, function(value, key) {
                                props.push(key);
                            });
                            props = baseDifference(props, baseFlatten(arguments, true, false, 1));

                            var index = -1,
                                length = props.length;

                            while (++index < length) {
                                var key = props[index];
                                result[key] = object[key];
                            }
                        } else {
                            callback = lodash.createCallback(callback, thisArg, 3);
                            forIn(object, function(value, key, object) {
                                if (!callback(value, key, object)) {
                                    result[key] = value;
                                }
                            });
                        }
                        return result;
                    }

                    /**
                     * Creates a two dimensional array of an object's key-value pairs,
                     * i.e. `[[key1, value1], [key2, value2]]`.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The object to inspect.
                     * @returns {Array} Returns new array of key-value pairs.
                     * @example
                     *
                     * _.pairs({ 'barney': 36, 'fred': 40 });
                     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
                     */
                    function pairs(object) {
                        var index = -1,
                            props = keys(object),
                            length = props.length,
                            result = Array(length);

                        while (++index < length) {
                            var key = props[index];
                            result[index] = [key, object[key]];
                        }
                        return result;
                    }

                    /**
                     * Creates a shallow clone of `object` composed of the specified properties.
                     * Property names may be specified as individual arguments or as arrays of
                     * property names. If a callback is provided it will be executed for each
                     * property of `object` picking the properties the callback returns truey
                     * for. The callback is bound to `thisArg` and invoked with three arguments;
                     * (value, key, object).
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The source object.
                     * @param {Function|...string|string[]} [callback] The function called per
                     *  iteration or property names to pick, specified as individual property
                     *  names or arrays of property names.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns an object composed of the picked properties.
                     * @example
                     *
                     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
                     * // => { 'name': 'fred' }
                     *
                     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
                     *   return key.charAt(0) != '_';
                     * });
                     * // => { 'name': 'fred' }
                     */
                    function pick(object, callback, thisArg) {
                        var result = {};
                        if (typeof callback != 'function') {
                            var index = -1,
                                props = baseFlatten(arguments, true, false, 1),
                                length = isObject(object) ? props.length : 0;

                            while (++index < length) {
                                var key = props[index];
                                if (key in object) {
                                    result[key] = object[key];
                                }
                            }
                        } else {
                            callback = lodash.createCallback(callback, thisArg, 3);
                            forIn(object, function(value, key, object) {
                                if (callback(value, key, object)) {
                                    result[key] = value;
                                }
                            });
                        }
                        return result;
                    }

                    /**
                     * An alternative to `_.reduce` this method transforms `object` to a new
                     * `accumulator` object which is the result of running each of its own
                     * enumerable properties through a callback, with each callback execution
                     * potentially mutating the `accumulator` object. The callback is bound to
                     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
                     * Callbacks may exit iteration early by explicitly returning `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Array|Object} object The object to iterate over.
                     * @param {Function} [callback=identity] The function called per iteration.
                     * @param {*} [accumulator] The custom accumulator value.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the accumulated value.
                     * @example
                     *
                     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
                     *   num *= num;
                     *   if (num % 2) {
                     *     return result.push(num) < 3;
                     *   }
                     * });
                     * // => [1, 9, 25]
                     *
                     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
                     *   result[key] = num * 3;
                     * });
                     * // => { 'a': 3, 'b': 6, 'c': 9 }
                     */
                    function transform(object, callback, accumulator, thisArg) {
                        var isArr = isArray(object);
                        if (accumulator == null) {
                            if (isArr) {
                                accumulator = [];
                            } else {
                                var ctor = object && object.constructor,
                                    proto = ctor && ctor.prototype;

                                accumulator = baseCreate(proto);
                            }
                        }
                        if (callback) {
                            callback = lodash.createCallback(callback, thisArg, 4);
                            (isArr ? forEach : forOwn)(object, function(value, index, object) {
                                return callback(accumulator, value, index, object);
                            });
                        }
                        return accumulator;
                    }

                    /**
                     * Creates an array composed of the own enumerable property values of `object`.
                     *
                     * @static
                     * @memberOf _
                     * @category Objects
                     * @param {Object} object The object to inspect.
                     * @returns {Array} Returns an array of property values.
                     * @example
                     *
                     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
                     * // => [1, 2, 3] (property order is not guaranteed across environments)
                     */
                    function values(object) {
                        var index = -1,
                            props = keys(object),
                            length = props.length,
                            result = Array(length);

                        while (++index < length) {
                            result[index] = object[props[index]];
                        }
                        return result;
                    }

                    /*--------------------------------------------------------------------------*/

                    /**
                     * Creates an array of elements from the specified indexes, or keys, of the
                     * `collection`. Indexes may be specified as individual arguments or as arrays
                     * of indexes.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
                     *   to retrieve, specified as individual indexes or arrays of indexes.
                     * @returns {Array} Returns a new array of elements corresponding to the
                     *  provided indexes.
                     * @example
                     *
                     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
                     * // => ['a', 'c', 'e']
                     *
                     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
                     * // => ['fred', 'pebbles']
                     */
                    function at(collection) {
                        var args = arguments,
                            index = -1,
                            props = baseFlatten(args, true, false, 1),
                            length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
                            result = Array(length);

                        while (++index < length) {
                            result[index] = collection[props[index]];
                        }
                        return result;
                    }

                    /**
                     * Checks if a given value is present in a collection using strict equality
                     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
                     * offset from the end of the collection.
                     *
                     * @static
                     * @memberOf _
                     * @alias include
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {*} target The value to check for.
                     * @param {number} [fromIndex=0] The index to search from.
                     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
                     * @example
                     *
                     * _.contains([1, 2, 3], 1);
                     * // => true
                     *
                     * _.contains([1, 2, 3], 1, 2);
                     * // => false
                     *
                     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
                     * // => true
                     *
                     * _.contains('pebbles', 'eb');
                     * // => true
                     */
                    function contains(collection, target, fromIndex) {
                        var index = -1,
                            indexOf = getIndexOf(),
                            length = collection ? collection.length : 0,
                            result = false;

                        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
                        if (isArray(collection)) {
                            result = indexOf(collection, target, fromIndex) > -1;
                        } else if (typeof length == 'number') {
                            result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
                        } else {
                            forOwn(collection, function(value) {
                                if (++index >= fromIndex) {
                                    return !(result = value === target);
                                }
                            });
                        }
                        return result;
                    }

                    /**
                     * Creates an object composed of keys generated from the results of running
                     * each element of `collection` through the callback. The corresponding value
                     * of each key is the number of times the key was returned by the callback.
                     * The callback is bound to `thisArg` and invoked with three arguments;
                     * (value, index|key, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns the composed aggregate object.
                     * @example
                     *
                     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
                     * // => { '4': 1, '6': 2 }
                     *
                     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
                     * // => { '4': 1, '6': 2 }
                     *
                     * _.countBy(['one', 'two', 'three'], 'length');
                     * // => { '3': 2, '5': 1 }
                     */
                    var countBy = createAggregator(function(result, value, key) {
                        (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
                    });

                    /**
                     * Checks if the given callback returns truey value for **all** elements of
                     * a collection. The callback is bound to `thisArg` and invoked with three
                     * arguments; (value, index|key, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias all
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {boolean} Returns `true` if all elements passed the callback check,
                     *  else `false`.
                     * @example
                     *
                     * _.every([true, 1, null, 'yes']);
                     * // => false
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36 },
                     *   { 'name': 'fred',   'age': 40 }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.every(characters, 'age');
                     * // => true
                     *
                     * // using "_.where" callback shorthand
                     * _.every(characters, { 'age': 36 });
                     * // => false
                     */
                    function every(collection, callback, thisArg) {
                        var result = true;
                        callback = lodash.createCallback(callback, thisArg, 3);

                        var index = -1,
                            length = collection ? collection.length : 0;

                        if (typeof length == 'number') {
                            while (++index < length) {
                                if (!(result = !!callback(collection[index], index, collection))) {
                                    break;
                                }
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                return (result = !!callback(value, index, collection));
                            });
                        }
                        return result;
                    }

                    /**
                     * Iterates over elements of a collection, returning an array of all elements
                     * the callback returns truey for. The callback is bound to `thisArg` and
                     * invoked with three arguments; (value, index|key, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias select
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns a new array of elements that passed the callback check.
                     * @example
                     *
                     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
                     * // => [2, 4, 6]
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36, 'blocked': false },
                     *   { 'name': 'fred',   'age': 40, 'blocked': true }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.filter(characters, 'blocked');
                     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
                     *
                     * // using "_.where" callback shorthand
                     * _.filter(characters, { 'age': 36 });
                     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
                     */
                    function filter(collection, callback, thisArg) {
                        var result = [];
                        callback = lodash.createCallback(callback, thisArg, 3);

                        var index = -1,
                            length = collection ? collection.length : 0;

                        if (typeof length == 'number') {
                            while (++index < length) {
                                var value = collection[index];
                                if (callback(value, index, collection)) {
                                    result.push(value);
                                }
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                if (callback(value, index, collection)) {
                                    result.push(value);
                                }
                            });
                        }
                        return result;
                    }

                    /**
                     * Iterates over elements of a collection, returning the first element that
                     * the callback returns truey for. The callback is bound to `thisArg` and
                     * invoked with three arguments; (value, index|key, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias detect, findWhere
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the found element, else `undefined`.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'barney',  'age': 36, 'blocked': false },
                     *   { 'name': 'fred',    'age': 40, 'blocked': true },
                     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
                     * ];
                     *
                     * _.find(characters, function(chr) {
                     *   return chr.age < 40;
                     * });
                     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
                     *
                     * // using "_.where" callback shorthand
                     * _.find(characters, { 'age': 1 });
                     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
                     *
                     * // using "_.pluck" callback shorthand
                     * _.find(characters, 'blocked');
                     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
                     */
                    function find(collection, callback, thisArg) {
                        callback = lodash.createCallback(callback, thisArg, 3);

                        var index = -1,
                            length = collection ? collection.length : 0;

                        if (typeof length == 'number') {
                            while (++index < length) {
                                var value = collection[index];
                                if (callback(value, index, collection)) {
                                    return value;
                                }
                            }
                        } else {
                            var result;
                            forOwn(collection, function(value, index, collection) {
                                if (callback(value, index, collection)) {
                                    result = value;
                                    return false;
                                }
                            });
                            return result;
                        }
                    }

                    /**
                     * This method is like `_.find` except that it iterates over elements
                     * of a `collection` from right to left.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the found element, else `undefined`.
                     * @example
                     *
                     * _.findLast([1, 2, 3, 4], function(num) {
                     *   return num % 2 == 1;
                     * });
                     * // => 3
                     */
                    function findLast(collection, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forEachRight(collection, function(value, index, collection) {
                            if (callback(value, index, collection)) {
                                result = value;
                                return false;
                            }
                        });
                        return result;
                    }

                    /**
                     * Iterates over elements of a collection, executing the callback for each
                     * element. The callback is bound to `thisArg` and invoked with three arguments;
                     * (value, index|key, collection). Callbacks may exit iteration early by
                     * explicitly returning `false`.
                     *
                     * Note: As with other "Collections" methods, objects with a `length` property
                     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
                     * may be used for object iteration.
                     *
                     * @static
                     * @memberOf _
                     * @alias each
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} [callback=identity] The function called per iteration.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array|Object|string} Returns `collection`.
                     * @example
                     *
                     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
                     * // => logs each number and returns '1,2,3'
                     *
                     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
                     * // => logs each number and returns the object (property order is not guaranteed across environments)
                     */
                    function forEach(collection, callback, thisArg) {
                        var index = -1,
                            length = collection ? collection.length : 0;

                        callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
                        if (typeof length == 'number') {
                            while (++index < length) {
                                if (callback(collection[index], index, collection) === false) {
                                    break;
                                }
                            }
                        } else {
                            forOwn(collection, callback);
                        }
                        return collection;
                    }

                    /**
                     * This method is like `_.forEach` except that it iterates over elements
                     * of a `collection` from right to left.
                     *
                     * @static
                     * @memberOf _
                     * @alias eachRight
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} [callback=identity] The function called per iteration.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array|Object|string} Returns `collection`.
                     * @example
                     *
                     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
                     * // => logs each number from right to left and returns '3,2,1'
                     */
                    function forEachRight(collection, callback, thisArg) {
                        var length = collection ? collection.length : 0;
                        callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
                        if (typeof length == 'number') {
                            while (length--) {
                                if (callback(collection[length], length, collection) === false) {
                                    break;
                                }
                            }
                        } else {
                            var props = keys(collection);
                            length = props.length;
                            forOwn(collection, function(value, key, collection) {
                                key = props ? props[--length] : --length;
                                return callback(collection[key], key, collection);
                            });
                        }
                        return collection;
                    }

                    /**
                     * Creates an object composed of keys generated from the results of running
                     * each element of a collection through the callback. The corresponding value
                     * of each key is an array of the elements responsible for generating the key.
                     * The callback is bound to `thisArg` and invoked with three arguments;
                     * (value, index|key, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns the composed aggregate object.
                     * @example
                     *
                     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
                     * // => { '4': [4.2], '6': [6.1, 6.4] }
                     *
                     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
                     * // => { '4': [4.2], '6': [6.1, 6.4] }
                     *
                     * // using "_.pluck" callback shorthand
                     * _.groupBy(['one', 'two', 'three'], 'length');
                     * // => { '3': ['one', 'two'], '5': ['three'] }
                     */
                    var groupBy = createAggregator(function(result, value, key) {
                        (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
                    });

                    /**
                     * Creates an object composed of keys generated from the results of running
                     * each element of the collection through the given callback. The corresponding
                     * value of each key is the last element responsible for generating the key.
                     * The callback is bound to `thisArg` and invoked with three arguments;
                     * (value, index|key, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Object} Returns the composed aggregate object.
                     * @example
                     *
                     * var keys = [
                     *   { 'dir': 'left', 'code': 97 },
                     *   { 'dir': 'right', 'code': 100 }
                     * ];
                     *
                     * _.indexBy(keys, 'dir');
                     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
                     *
                     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
                     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
                     *
                     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
                     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
                     */
                    var indexBy = createAggregator(function(result, value, key) {
                        result[key] = value;
                    });

                    /**
                     * Invokes the method named by `methodName` on each element in the `collection`
                     * returning an array of the results of each invoked method. Additional arguments
                     * will be provided to each invoked method. If `methodName` is a function it
                     * will be invoked for, and `this` bound to, each element in the `collection`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|string} methodName The name of the method to invoke or
                     *  the function invoked per iteration.
                     * @param {...*} [arg] Arguments to invoke the method with.
                     * @returns {Array} Returns a new array of the results of each invoked method.
                     * @example
                     *
                     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
                     * // => [[1, 5, 7], [1, 2, 3]]
                     *
                     * _.invoke([123, 456], String.prototype.split, '');
                     * // => [['1', '2', '3'], ['4', '5', '6']]
                     */
                    function invoke(collection, methodName) {
                        var args = slice(arguments, 2),
                            index = -1,
                            isFunc = typeof methodName == 'function',
                            length = collection ? collection.length : 0,
                            result = Array(typeof length == 'number' ? length : 0);

                        forEach(collection, function(value) {
                            result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
                        });
                        return result;
                    }

                    /**
                     * Creates an array of values by running each element in the collection
                     * through the callback. The callback is bound to `thisArg` and invoked with
                     * three arguments; (value, index|key, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias collect
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns a new array of the results of each `callback` execution.
                     * @example
                     *
                     * _.map([1, 2, 3], function(num) { return num * 3; });
                     * // => [3, 6, 9]
                     *
                     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
                     * // => [3, 6, 9] (property order is not guaranteed across environments)
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36 },
                     *   { 'name': 'fred',   'age': 40 }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.map(characters, 'name');
                     * // => ['barney', 'fred']
                     */
                    function map(collection, callback, thisArg) {
                        var index = -1,
                            length = collection ? collection.length : 0;

                        callback = lodash.createCallback(callback, thisArg, 3);
                        if (typeof length == 'number') {
                            var result = Array(length);
                            while (++index < length) {
                                result[index] = callback(collection[index], index, collection);
                            }
                        } else {
                            result = [];
                            forOwn(collection, function(value, key, collection) {
                                result[++index] = callback(value, key, collection);
                            });
                        }
                        return result;
                    }

                    /**
                     * Retrieves the maximum value of a collection. If the collection is empty or
                     * falsey `-Infinity` is returned. If a callback is provided it will be executed
                     * for each value in the collection to generate the criterion by which the value
                     * is ranked. The callback is bound to `thisArg` and invoked with three
                     * arguments; (value, index, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the maximum value.
                     * @example
                     *
                     * _.max([4, 2, 8, 6]);
                     * // => 8
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36 },
                     *   { 'name': 'fred',   'age': 40 }
                     * ];
                     *
                     * _.max(characters, function(chr) { return chr.age; });
                     * // => { 'name': 'fred', 'age': 40 };
                     *
                     * // using "_.pluck" callback shorthand
                     * _.max(characters, 'age');
                     * // => { 'name': 'fred', 'age': 40 };
                     */
                    function max(collection, callback, thisArg) {
                        var computed = -Infinity,
                            result = computed;

                        // allows working with functions like `_.map` without using
                        // their `index` argument as a callback
                        if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
                            callback = null;
                        }
                        if (callback == null && isArray(collection)) {
                            var index = -1,
                                length = collection.length;

                            while (++index < length) {
                                var value = collection[index];
                                if (value > result) {
                                    result = value;
                                }
                            }
                        } else {
                            callback = (callback == null && isString(collection)) ?
                                charAtCallback :
                                lodash.createCallback(callback, thisArg, 3);

                            forEach(collection, function(value, index, collection) {
                                var current = callback(value, index, collection);
                                if (current > computed) {
                                    computed = current;
                                    result = value;
                                }
                            });
                        }
                        return result;
                    }

                    /**
                     * Retrieves the minimum value of a collection. If the collection is empty or
                     * falsey `Infinity` is returned. If a callback is provided it will be executed
                     * for each value in the collection to generate the criterion by which the value
                     * is ranked. The callback is bound to `thisArg` and invoked with three
                     * arguments; (value, index, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the minimum value.
                     * @example
                     *
                     * _.min([4, 2, 8, 6]);
                     * // => 2
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36 },
                     *   { 'name': 'fred',   'age': 40 }
                     * ];
                     *
                     * _.min(characters, function(chr) { return chr.age; });
                     * // => { 'name': 'barney', 'age': 36 };
                     *
                     * // using "_.pluck" callback shorthand
                     * _.min(characters, 'age');
                     * // => { 'name': 'barney', 'age': 36 };
                     */
                    function min(collection, callback, thisArg) {
                        var computed = Infinity,
                            result = computed;

                        // allows working with functions like `_.map` without using
                        // their `index` argument as a callback
                        if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
                            callback = null;
                        }
                        if (callback == null && isArray(collection)) {
                            var index = -1,
                                length = collection.length;

                            while (++index < length) {
                                var value = collection[index];
                                if (value < result) {
                                    result = value;
                                }
                            }
                        } else {
                            callback = (callback == null && isString(collection)) ?
                                charAtCallback :
                                lodash.createCallback(callback, thisArg, 3);

                            forEach(collection, function(value, index, collection) {
                                var current = callback(value, index, collection);
                                if (current < computed) {
                                    computed = current;
                                    result = value;
                                }
                            });
                        }
                        return result;
                    }

                    /**
                     * Retrieves the value of a specified property from all elements in the collection.
                     *
                     * @static
                     * @memberOf _
                     * @type Function
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {string} property The name of the property to pluck.
                     * @returns {Array} Returns a new array of property values.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36 },
                     *   { 'name': 'fred',   'age': 40 }
                     * ];
                     *
                     * _.pluck(characters, 'name');
                     * // => ['barney', 'fred']
                     */
                    var pluck = map;

                    /**
                     * Reduces a collection to a value which is the accumulated result of running
                     * each element in the collection through the callback, where each successive
                     * callback execution consumes the return value of the previous execution. If
                     * `accumulator` is not provided the first element of the collection will be
                     * used as the initial `accumulator` value. The callback is bound to `thisArg`
                     * and invoked with four arguments; (accumulator, value, index|key, collection).
                     *
                     * @static
                     * @memberOf _
                     * @alias foldl, inject
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} [callback=identity] The function called per iteration.
                     * @param {*} [accumulator] Initial value of the accumulator.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the accumulated value.
                     * @example
                     *
                     * var sum = _.reduce([1, 2, 3], function(sum, num) {
                     *   return sum + num;
                     * });
                     * // => 6
                     *
                     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
                     *   result[key] = num * 3;
                     *   return result;
                     * }, {});
                     * // => { 'a': 3, 'b': 6, 'c': 9 }
                     */
                    function reduce(collection, callback, accumulator, thisArg) {
                        if (!collection) return accumulator;
                        var noaccum = arguments.length < 3;
                        callback = lodash.createCallback(callback, thisArg, 4);

                        var index = -1,
                            length = collection.length;

                        if (typeof length == 'number') {
                            if (noaccum) {
                                accumulator = collection[++index];
                            }
                            while (++index < length) {
                                accumulator = callback(accumulator, collection[index], index, collection);
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                accumulator = noaccum ?
                                    (noaccum = false, value) :
                                    callback(accumulator, value, index, collection)
                            });
                        }
                        return accumulator;
                    }

                    /**
                     * This method is like `_.reduce` except that it iterates over elements
                     * of a `collection` from right to left.
                     *
                     * @static
                     * @memberOf _
                     * @alias foldr
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} [callback=identity] The function called per iteration.
                     * @param {*} [accumulator] Initial value of the accumulator.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the accumulated value.
                     * @example
                     *
                     * var list = [[0, 1], [2, 3], [4, 5]];
                     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
                     * // => [4, 5, 2, 3, 0, 1]
                     */
                    function reduceRight(collection, callback, accumulator, thisArg) {
                        var noaccum = arguments.length < 3;
                        callback = lodash.createCallback(callback, thisArg, 4);
                        forEachRight(collection, function(value, index, collection) {
                            accumulator = noaccum ?
                                (noaccum = false, value) :
                                callback(accumulator, value, index, collection);
                        });
                        return accumulator;
                    }

                    /**
                     * The opposite of `_.filter` this method returns the elements of a
                     * collection that the callback does **not** return truey for.
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns a new array of elements that failed the callback check.
                     * @example
                     *
                     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
                     * // => [1, 3, 5]
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36, 'blocked': false },
                     *   { 'name': 'fred',   'age': 40, 'blocked': true }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.reject(characters, 'blocked');
                     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
                     *
                     * // using "_.where" callback shorthand
                     * _.reject(characters, { 'age': 36 });
                     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
                     */
                    function reject(collection, callback, thisArg) {
                        callback = lodash.createCallback(callback, thisArg, 3);
                        return filter(collection, function(value, index, collection) {
                            return !callback(value, index, collection);
                        });
                    }

                    /**
                     * Retrieves a random element or `n` random elements from a collection.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to sample.
                     * @param {number} [n] The number of elements to sample.
                     * @param- {Object} [guard] Allows working with functions like `_.map`
                     *  without using their `index` arguments as `n`.
                     * @returns {Array} Returns the random sample(s) of `collection`.
                     * @example
                     *
                     * _.sample([1, 2, 3, 4]);
                     * // => 2
                     *
                     * _.sample([1, 2, 3, 4], 2);
                     * // => [3, 1]
                     */
                    function sample(collection, n, guard) {
                        if (collection && typeof collection.length != 'number') {
                            collection = values(collection);
                        }
                        if (n == null || guard) {
                            return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
                        }
                        var result = shuffle(collection);
                        result.length = nativeMin(nativeMax(0, n), result.length);
                        return result;
                    }

                    /**
                     * Creates an array of shuffled values, using a version of the Fisher-Yates
                     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to shuffle.
                     * @returns {Array} Returns a new shuffled collection.
                     * @example
                     *
                     * _.shuffle([1, 2, 3, 4, 5, 6]);
                     * // => [4, 1, 6, 3, 5, 2]
                     */
                    function shuffle(collection) {
                        var index = -1,
                            length = collection ? collection.length : 0,
                            result = Array(typeof length == 'number' ? length : 0);

                        forEach(collection, function(value) {
                            var rand = baseRandom(0, ++index);
                            result[index] = result[rand];
                            result[rand] = value;
                        });
                        return result;
                    }

                    /**
                     * Gets the size of the `collection` by returning `collection.length` for arrays
                     * and array-like objects or the number of own enumerable properties for objects.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to inspect.
                     * @returns {number} Returns `collection.length` or number of own enumerable properties.
                     * @example
                     *
                     * _.size([1, 2]);
                     * // => 2
                     *
                     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
                     * // => 3
                     *
                     * _.size('pebbles');
                     * // => 7
                     */
                    function size(collection) {
                        var length = collection ? collection.length : 0;
                        return typeof length == 'number' ? length : keys(collection).length;
                    }

                    /**
                     * Checks if the callback returns a truey value for **any** element of a
                     * collection. The function returns as soon as it finds a passing value and
                     * does not iterate over the entire collection. The callback is bound to
                     * `thisArg` and invoked with three arguments; (value, index|key, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias any
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {boolean} Returns `true` if any element passed the callback check,
                     *  else `false`.
                     * @example
                     *
                     * _.some([null, 0, 'yes', false], Boolean);
                     * // => true
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36, 'blocked': false },
                     *   { 'name': 'fred',   'age': 40, 'blocked': true }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.some(characters, 'blocked');
                     * // => true
                     *
                     * // using "_.where" callback shorthand
                     * _.some(characters, { 'age': 1 });
                     * // => false
                     */
                    function some(collection, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);

                        var index = -1,
                            length = collection ? collection.length : 0;

                        if (typeof length == 'number') {
                            while (++index < length) {
                                if ((result = callback(collection[index], index, collection))) {
                                    break;
                                }
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                return !(result = callback(value, index, collection));
                            });
                        }
                        return !!result;
                    }

                    /**
                     * Creates an array of elements, sorted in ascending order by the results of
                     * running each element in a collection through the callback. This method
                     * performs a stable sort, that is, it will preserve the original sort order
                     * of equal elements. The callback is bound to `thisArg` and invoked with
                     * three arguments; (value, index|key, collection).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an array of property names is provided for `callback` the collection
                     * will be sorted by each property value.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Array|Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns a new array of sorted elements.
                     * @example
                     *
                     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
                     * // => [3, 1, 2]
                     *
                     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
                     * // => [3, 1, 2]
                     *
                     * var characters = [
                     *   { 'name': 'barney',  'age': 36 },
                     *   { 'name': 'fred',    'age': 40 },
                     *   { 'name': 'barney',  'age': 26 },
                     *   { 'name': 'fred',    'age': 30 }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.map(_.sortBy(characters, 'age'), _.values);
                     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
                     *
                     * // sorting by multiple properties
                     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
                     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
                     */
                    function sortBy(collection, callback, thisArg) {
                        var index = -1,
                            isArr = isArray(callback),
                            length = collection ? collection.length : 0,
                            result = Array(typeof length == 'number' ? length : 0);

                        if (!isArr) {
                            callback = lodash.createCallback(callback, thisArg, 3);
                        }
                        forEach(collection, function(value, key, collection) {
                            var object = result[++index] = getObject();
                            if (isArr) {
                                object.criteria = map(callback, function(key) {
                                    return value[key];
                                });
                            } else {
                                (object.criteria = getArray())[0] = callback(value, key, collection);
                            }
                            object.index = index;
                            object.value = value;
                        });

                        length = result.length;
                        result.sort(compareAscending);
                        while (length--) {
                            var object = result[length];
                            result[length] = object.value;
                            if (!isArr) {
                                releaseArray(object.criteria);
                            }
                            releaseObject(object);
                        }
                        return result;
                    }

                    /**
                     * Converts the `collection` to an array.
                     *
                     * @static
                     * @memberOf _
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to convert.
                     * @returns {Array} Returns the new converted array.
                     * @example
                     *
                     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
                     * // => [2, 3, 4]
                     */
                    function toArray(collection) {
                        if (collection && typeof collection.length == 'number') {
                            return slice(collection);
                        }
                        return values(collection);
                    }

                    /**
                     * Performs a deep comparison of each element in a `collection` to the given
                     * `properties` object, returning an array of all elements that have equivalent
                     * property values.
                     *
                     * @static
                     * @memberOf _
                     * @type Function
                     * @category Collections
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Object} props The object of property values to filter by.
                     * @returns {Array} Returns a new array of elements that have the given properties.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
                     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
                     * ];
                     *
                     * _.where(characters, { 'age': 36 });
                     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
                     *
                     * _.where(characters, { 'pets': ['dino'] });
                     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
                     */
                    var where = filter;

                    /*--------------------------------------------------------------------------*/

                    /**
                     * Creates an array with all falsey values removed. The values `false`, `null`,
                     * `0`, `""`, `undefined`, and `NaN` are all falsey.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to compact.
                     * @returns {Array} Returns a new array of filtered values.
                     * @example
                     *
                     * _.compact([0, 1, false, 2, '', 3]);
                     * // => [1, 2, 3]
                     */
                    function compact(array) {
                        var index = -1,
                            length = array ? array.length : 0,
                            result = [];

                        while (++index < length) {
                            var value = array[index];
                            if (value) {
                                result.push(value);
                            }
                        }
                        return result;
                    }

                    /**
                     * Creates an array excluding all values of the provided arrays using strict
                     * equality for comparisons, i.e. `===`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to process.
                     * @param {...Array} [values] The arrays of values to exclude.
                     * @returns {Array} Returns a new array of filtered values.
                     * @example
                     *
                     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
                     * // => [1, 3, 4]
                     */
                    function difference(array) {
                        return baseDifference(array, baseFlatten(arguments, true, true, 1));
                    }

                    /**
                     * This method is like `_.find` except that it returns the index of the first
                     * element that passes the callback check, instead of the element itself.
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to search.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {number} Returns the index of the found element, else `-1`.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'barney',  'age': 36, 'blocked': false },
                     *   { 'name': 'fred',    'age': 40, 'blocked': true },
                     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
                     * ];
                     *
                     * _.findIndex(characters, function(chr) {
                     *   return chr.age < 20;
                     * });
                     * // => 2
                     *
                     * // using "_.where" callback shorthand
                     * _.findIndex(characters, { 'age': 36 });
                     * // => 0
                     *
                     * // using "_.pluck" callback shorthand
                     * _.findIndex(characters, 'blocked');
                     * // => 1
                     */
                    function findIndex(array, callback, thisArg) {
                        var index = -1,
                            length = array ? array.length : 0;

                        callback = lodash.createCallback(callback, thisArg, 3);
                        while (++index < length) {
                            if (callback(array[index], index, array)) {
                                return index;
                            }
                        }
                        return -1;
                    }

                    /**
                     * This method is like `_.findIndex` except that it iterates over elements
                     * of a `collection` from right to left.
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to search.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {number} Returns the index of the found element, else `-1`.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'barney',  'age': 36, 'blocked': true },
                     *   { 'name': 'fred',    'age': 40, 'blocked': false },
                     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
                     * ];
                     *
                     * _.findLastIndex(characters, function(chr) {
                     *   return chr.age > 30;
                     * });
                     * // => 1
                     *
                     * // using "_.where" callback shorthand
                     * _.findLastIndex(characters, { 'age': 36 });
                     * // => 0
                     *
                     * // using "_.pluck" callback shorthand
                     * _.findLastIndex(characters, 'blocked');
                     * // => 2
                     */
                    function findLastIndex(array, callback, thisArg) {
                        var length = array ? array.length : 0;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        while (length--) {
                            if (callback(array[length], length, array)) {
                                return length;
                            }
                        }
                        return -1;
                    }

                    /**
                     * Gets the first element or first `n` elements of an array. If a callback
                     * is provided elements at the beginning of the array are returned as long
                     * as the callback returns truey. The callback is bound to `thisArg` and
                     * invoked with three arguments; (value, index, array).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias head, take
                     * @category Arrays
                     * @param {Array} array The array to query.
                     * @param {Function|Object|number|string} [callback] The function called
                     *  per element or the number of elements to return. If a property name or
                     *  object is provided it will be used to create a "_.pluck" or "_.where"
                     *  style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the first element(s) of `array`.
                     * @example
                     *
                     * _.first([1, 2, 3]);
                     * // => 1
                     *
                     * _.first([1, 2, 3], 2);
                     * // => [1, 2]
                     *
                     * _.first([1, 2, 3], function(num) {
                     *   return num < 3;
                     * });
                     * // => [1, 2]
                     *
                     * var characters = [
                     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
                     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
                     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.first(characters, 'blocked');
                     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
                     *
                     * // using "_.where" callback shorthand
                     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
                     * // => ['barney', 'fred']
                     */
                    function first(array, callback, thisArg) {
                        var n = 0,
                            length = array ? array.length : 0;

                        if (typeof callback != 'number' && callback != null) {
                            var index = -1;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (++index < length && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback;
                            if (n == null || thisArg) {
                                return array ? array[0] : undefined;
                            }
                        }
                        return slice(array, 0, nativeMin(nativeMax(0, n), length));
                    }

                    /**
                     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
                     * is truey, the array will only be flattened a single level. If a callback
                     * is provided each element of the array is passed through the callback before
                     * flattening. The callback is bound to `thisArg` and invoked with three
                     * arguments; (value, index, array).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to flatten.
                     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns a new flattened array.
                     * @example
                     *
                     * _.flatten([1, [2], [3, [[4]]]]);
                     * // => [1, 2, 3, 4];
                     *
                     * _.flatten([1, [2], [3, [[4]]]], true);
                     * // => [1, 2, 3, [[4]]];
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
                     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.flatten(characters, 'pets');
                     * // => ['hoppy', 'baby puss', 'dino']
                     */
                    function flatten(array, isShallow, callback, thisArg) {
                        // juggle arguments
                        if (typeof isShallow != 'boolean' && isShallow != null) {
                            thisArg = callback;
                            callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
                            isShallow = false;
                        }
                        if (callback != null) {
                            array = map(array, callback, thisArg);
                        }
                        return baseFlatten(array, isShallow);
                    }

                    /**
                     * Gets the index at which the first occurrence of `value` is found using
                     * strict equality for comparisons, i.e. `===`. If the array is already sorted
                     * providing `true` for `fromIndex` will run a faster binary search.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to search.
                     * @param {*} value The value to search for.
                     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
                     *  to perform a binary search on a sorted array.
                     * @returns {number} Returns the index of the matched value or `-1`.
                     * @example
                     *
                     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
                     * // => 1
                     *
                     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
                     * // => 4
                     *
                     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
                     * // => 2
                     */
                    function indexOf(array, value, fromIndex) {
                        if (typeof fromIndex == 'number') {
                            var length = array ? array.length : 0;
                            fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
                        } else if (fromIndex) {
                            var index = sortedIndex(array, value);
                            return array[index] === value ? index : -1;
                        }
                        return baseIndexOf(array, value, fromIndex);
                    }

                    /**
                     * Gets all but the last element or last `n` elements of an array. If a
                     * callback is provided elements at the end of the array are excluded from
                     * the result as long as the callback returns truey. The callback is bound
                     * to `thisArg` and invoked with three arguments; (value, index, array).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to query.
                     * @param {Function|Object|number|string} [callback=1] The function called
                     *  per element or the number of elements to exclude. If a property name or
                     *  object is provided it will be used to create a "_.pluck" or "_.where"
                     *  style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns a slice of `array`.
                     * @example
                     *
                     * _.initial([1, 2, 3]);
                     * // => [1, 2]
                     *
                     * _.initial([1, 2, 3], 2);
                     * // => [1]
                     *
                     * _.initial([1, 2, 3], function(num) {
                     *   return num > 1;
                     * });
                     * // => [1]
                     *
                     * var characters = [
                     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
                     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
                     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.initial(characters, 'blocked');
                     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
                     *
                     * // using "_.where" callback shorthand
                     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
                     * // => ['barney', 'fred']
                     */
                    function initial(array, callback, thisArg) {
                        var n = 0,
                            length = array ? array.length : 0;

                        if (typeof callback != 'number' && callback != null) {
                            var index = length;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (index-- && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = (callback == null || thisArg) ? 1 : callback || n;
                        }
                        return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
                    }

                    /**
                     * Creates an array of unique values present in all provided arrays using
                     * strict equality for comparisons, i.e. `===`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {...Array} [array] The arrays to inspect.
                     * @returns {Array} Returns an array of shared values.
                     * @example
                     *
                     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
                     * // => [1, 2]
                     */
                    function intersection() {
                        var args = [],
                            argsIndex = -1,
                            argsLength = arguments.length,
                            caches = getArray(),
                            indexOf = getIndexOf(),
                            trustIndexOf = indexOf === baseIndexOf,
                            seen = getArray();

                        while (++argsIndex < argsLength) {
                            var value = arguments[argsIndex];
                            if (isArray(value) || isArguments(value)) {
                                args.push(value);
                                caches.push(trustIndexOf && value.length >= largeArraySize &&
                                    createCache(argsIndex ? args[argsIndex] : seen));
                            }
                        }
                        var array = args[0],
                            index = -1,
                            length = array ? array.length : 0,
                            result = [];

                        outer:
                            while (++index < length) {
                                var cache = caches[0];
                                value = array[index];

                                if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
                                    argsIndex = argsLength;
                                    (cache || seen).push(value);
                                    while (--argsIndex) {
                                        cache = caches[argsIndex];
                                        if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
                                            continue outer;
                                        }
                                    }
                                    result.push(value);
                                }
                            }
                        while (argsLength--) {
                            cache = caches[argsLength];
                            if (cache) {
                                releaseObject(cache);
                            }
                        }
                        releaseArray(caches);
                        releaseArray(seen);
                        return result;
                    }

                    /**
                     * Gets the last element or last `n` elements of an array. If a callback is
                     * provided elements at the end of the array are returned as long as the
                     * callback returns truey. The callback is bound to `thisArg` and invoked
                     * with three arguments; (value, index, array).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to query.
                     * @param {Function|Object|number|string} [callback] The function called
                     *  per element or the number of elements to return. If a property name or
                     *  object is provided it will be used to create a "_.pluck" or "_.where"
                     *  style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {*} Returns the last element(s) of `array`.
                     * @example
                     *
                     * _.last([1, 2, 3]);
                     * // => 3
                     *
                     * _.last([1, 2, 3], 2);
                     * // => [2, 3]
                     *
                     * _.last([1, 2, 3], function(num) {
                     *   return num > 1;
                     * });
                     * // => [2, 3]
                     *
                     * var characters = [
                     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
                     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
                     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.pluck(_.last(characters, 'blocked'), 'name');
                     * // => ['fred', 'pebbles']
                     *
                     * // using "_.where" callback shorthand
                     * _.last(characters, { 'employer': 'na' });
                     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
                     */
                    function last(array, callback, thisArg) {
                        var n = 0,
                            length = array ? array.length : 0;

                        if (typeof callback != 'number' && callback != null) {
                            var index = length;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (index-- && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback;
                            if (n == null || thisArg) {
                                return array ? array[length - 1] : undefined;
                            }
                        }
                        return slice(array, nativeMax(0, length - n));
                    }

                    /**
                     * Gets the index at which the last occurrence of `value` is found using strict
                     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
                     * as the offset from the end of the collection.
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to search.
                     * @param {*} value The value to search for.
                     * @param {number} [fromIndex=array.length-1] The index to search from.
                     * @returns {number} Returns the index of the matched value or `-1`.
                     * @example
                     *
                     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
                     * // => 4
                     *
                     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
                     * // => 1
                     */
                    function lastIndexOf(array, value, fromIndex) {
                        var index = array ? array.length : 0;
                        if (typeof fromIndex == 'number') {
                            index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
                        }
                        while (index--) {
                            if (array[index] === value) {
                                return index;
                            }
                        }
                        return -1;
                    }

                    /**
                     * Removes all provided values from the given array using strict equality for
                     * comparisons, i.e. `===`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to modify.
                     * @param {...*} [value] The values to remove.
                     * @returns {Array} Returns `array`.
                     * @example
                     *
                     * var array = [1, 2, 3, 1, 2, 3];
                     * _.pull(array, 2, 3);
                     * console.log(array);
                     * // => [1, 1]
                     */
                    function pull(array) {
                        var args = arguments,
                            argsIndex = 0,
                            argsLength = args.length,
                            length = array ? array.length : 0;

                        while (++argsIndex < argsLength) {
                            var index = -1,
                                value = args[argsIndex];
                            while (++index < length) {
                                if (array[index] === value) {
                                    splice.call(array, index--, 1);
                                    length--;
                                }
                            }
                        }
                        return array;
                    }

                    /**
                     * Creates an array of numbers (positive and/or negative) progressing from
                     * `start` up to but not including `end`. If `start` is less than `stop` a
                     * zero-length range is created unless a negative `step` is specified.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {number} [start=0] The start of the range.
                     * @param {number} end The end of the range.
                     * @param {number} [step=1] The value to increment or decrement by.
                     * @returns {Array} Returns a new range array.
                     * @example
                     *
                     * _.range(4);
                     * // => [0, 1, 2, 3]
                     *
                     * _.range(1, 5);
                     * // => [1, 2, 3, 4]
                     *
                     * _.range(0, 20, 5);
                     * // => [0, 5, 10, 15]
                     *
                     * _.range(0, -4, -1);
                     * // => [0, -1, -2, -3]
                     *
                     * _.range(1, 4, 0);
                     * // => [1, 1, 1]
                     *
                     * _.range(0);
                     * // => []
                     */
                    function range(start, end, step) {
                        start = +start || 0;
                        step = typeof step == 'number' ? step : (+step || 1);

                        if (end == null) {
                            end = start;
                            start = 0;
                        }
                        // use `Array(length)` so engines like Chakra and V8 avoid slower modes
                        // http://youtu.be/XAqIpGU8ZZk#t=17m25s
                        var index = -1,
                            length = nativeMax(0, ceil((end - start) / (step || 1))),
                            result = Array(length);

                        while (++index < length) {
                            result[index] = start;
                            start += step;
                        }
                        return result;
                    }

                    /**
                     * Removes all elements from an array that the callback returns truey for
                     * and returns an array of removed elements. The callback is bound to `thisArg`
                     * and invoked with three arguments; (value, index, array).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to modify.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns a new array of removed elements.
                     * @example
                     *
                     * var array = [1, 2, 3, 4, 5, 6];
                     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
                     *
                     * console.log(array);
                     * // => [1, 3, 5]
                     *
                     * console.log(evens);
                     * // => [2, 4, 6]
                     */
                    function remove(array, callback, thisArg) {
                        var index = -1,
                            length = array ? array.length : 0,
                            result = [];

                        callback = lodash.createCallback(callback, thisArg, 3);
                        while (++index < length) {
                            var value = array[index];
                            if (callback(value, index, array)) {
                                result.push(value);
                                splice.call(array, index--, 1);
                                length--;
                            }
                        }
                        return result;
                    }

                    /**
                     * The opposite of `_.initial` this method gets all but the first element or
                     * first `n` elements of an array. If a callback function is provided elements
                     * at the beginning of the array are excluded from the result as long as the
                     * callback returns truey. The callback is bound to `thisArg` and invoked
                     * with three arguments; (value, index, array).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias drop, tail
                     * @category Arrays
                     * @param {Array} array The array to query.
                     * @param {Function|Object|number|string} [callback=1] The function called
                     *  per element or the number of elements to exclude. If a property name or
                     *  object is provided it will be used to create a "_.pluck" or "_.where"
                     *  style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns a slice of `array`.
                     * @example
                     *
                     * _.rest([1, 2, 3]);
                     * // => [2, 3]
                     *
                     * _.rest([1, 2, 3], 2);
                     * // => [3]
                     *
                     * _.rest([1, 2, 3], function(num) {
                     *   return num < 3;
                     * });
                     * // => [3]
                     *
                     * var characters = [
                     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
                     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
                     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
                     * ];
                     *
                     * // using "_.pluck" callback shorthand
                     * _.pluck(_.rest(characters, 'blocked'), 'name');
                     * // => ['fred', 'pebbles']
                     *
                     * // using "_.where" callback shorthand
                     * _.rest(characters, { 'employer': 'slate' });
                     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
                     */
                    function rest(array, callback, thisArg) {
                        if (typeof callback != 'number' && callback != null) {
                            var n = 0,
                                index = -1,
                                length = array ? array.length : 0;

                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (++index < length && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
                        }
                        return slice(array, n);
                    }

                    /**
                     * Uses a binary search to determine the smallest index at which a value
                     * should be inserted into a given sorted array in order to maintain the sort
                     * order of the array. If a callback is provided it will be executed for
                     * `value` and each element of `array` to compute their sort ranking. The
                     * callback is bound to `thisArg` and invoked with one argument; (value).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to inspect.
                     * @param {*} value The value to evaluate.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {number} Returns the index at which `value` should be inserted
                     *  into `array`.
                     * @example
                     *
                     * _.sortedIndex([20, 30, 50], 40);
                     * // => 2
                     *
                     * // using "_.pluck" callback shorthand
                     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
                     * // => 2
                     *
                     * var dict = {
                     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
                     * };
                     *
                     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
                     *   return dict.wordToNumber[word];
                     * });
                     * // => 2
                     *
                     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
                     *   return this.wordToNumber[word];
                     * }, dict);
                     * // => 2
                     */
                    function sortedIndex(array, value, callback, thisArg) {
                        var low = 0,
                            high = array ? array.length : low;

                        // explicitly reference `identity` for better inlining in Firefox
                        callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
                        value = callback(value);

                        while (low < high) {
                            var mid = (low + high) >>> 1;
                            (callback(array[mid]) < value) ?
                            low = mid + 1: high = mid;
                        }
                        return low;
                    }

                    /**
                     * Creates an array of unique values, in order, of the provided arrays using
                     * strict equality for comparisons, i.e. `===`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {...Array} [array] The arrays to inspect.
                     * @returns {Array} Returns an array of combined values.
                     * @example
                     *
                     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
                     * // => [1, 2, 3, 5, 4]
                     */
                    function union() {
                        return baseUniq(baseFlatten(arguments, true, true));
                    }

                    /**
                     * Creates a duplicate-value-free version of an array using strict equality
                     * for comparisons, i.e. `===`. If the array is sorted, providing
                     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
                     * each element of `array` is passed through the callback before uniqueness
                     * is computed. The callback is bound to `thisArg` and invoked with three
                     * arguments; (value, index, array).
                     *
                     * If a property name is provided for `callback` the created "_.pluck" style
                     * callback will return the property value of the given element.
                     *
                     * If an object is provided for `callback` the created "_.where" style callback
                     * will return `true` for elements that have the properties of the given object,
                     * else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias unique
                     * @category Arrays
                     * @param {Array} array The array to process.
                     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
                     * @param {Function|Object|string} [callback=identity] The function called
                     *  per iteration. If a property name or object is provided it will be used
                     *  to create a "_.pluck" or "_.where" style callback, respectively.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns a duplicate-value-free array.
                     * @example
                     *
                     * _.uniq([1, 2, 1, 3, 1]);
                     * // => [1, 2, 3]
                     *
                     * _.uniq([1, 1, 2, 2, 3], true);
                     * // => [1, 2, 3]
                     *
                     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
                     * // => ['A', 'b', 'C']
                     *
                     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
                     * // => [1, 2.5, 3]
                     *
                     * // using "_.pluck" callback shorthand
                     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
                     * // => [{ 'x': 1 }, { 'x': 2 }]
                     */
                    function uniq(array, isSorted, callback, thisArg) {
                        // juggle arguments
                        if (typeof isSorted != 'boolean' && isSorted != null) {
                            thisArg = callback;
                            callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
                            isSorted = false;
                        }
                        if (callback != null) {
                            callback = lodash.createCallback(callback, thisArg, 3);
                        }
                        return baseUniq(array, isSorted, callback);
                    }

                    /**
                     * Creates an array excluding all provided values using strict equality for
                     * comparisons, i.e. `===`.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {Array} array The array to filter.
                     * @param {...*} [value] The values to exclude.
                     * @returns {Array} Returns a new array of filtered values.
                     * @example
                     *
                     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
                     * // => [2, 3, 4]
                     */
                    function without(array) {
                        return baseDifference(array, slice(arguments, 1));
                    }

                    /**
                     * Creates an array that is the symmetric difference of the provided arrays.
                     * See http://en.wikipedia.org/wiki/Symmetric_difference.
                     *
                     * @static
                     * @memberOf _
                     * @category Arrays
                     * @param {...Array} [array] The arrays to inspect.
                     * @returns {Array} Returns an array of values.
                     * @example
                     *
                     * _.xor([1, 2, 3], [5, 2, 1, 4]);
                     * // => [3, 5, 4]
                     *
                     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
                     * // => [1, 4, 5]
                     */
                    function xor() {
                        var index = -1,
                            length = arguments.length;

                        while (++index < length) {
                            var array = arguments[index];
                            if (isArray(array) || isArguments(array)) {
                                var result = result ?
                                    baseUniq(baseDifference(result, array).concat(baseDifference(array, result))) :
                                    array;
                            }
                        }
                        return result || [];
                    }

                    /**
                     * Creates an array of grouped elements, the first of which contains the first
                     * elements of the given arrays, the second of which contains the second
                     * elements of the given arrays, and so on.
                     *
                     * @static
                     * @memberOf _
                     * @alias unzip
                     * @category Arrays
                     * @param {...Array} [array] Arrays to process.
                     * @returns {Array} Returns a new array of grouped elements.
                     * @example
                     *
                     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
                     * // => [['fred', 30, true], ['barney', 40, false]]
                     */
                    function zip() {
                        var array = arguments.length > 1 ? arguments : arguments[0],
                            index = -1,
                            length = array ? max(pluck(array, 'length')) : 0,
                            result = Array(length < 0 ? 0 : length);

                        while (++index < length) {
                            result[index] = pluck(array, index);
                        }
                        return result;
                    }

                    /**
                     * Creates an object composed from arrays of `keys` and `values`. Provide
                     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
                     * or two arrays, one of `keys` and one of corresponding `values`.
                     *
                     * @static
                     * @memberOf _
                     * @alias object
                     * @category Arrays
                     * @param {Array} keys The array of keys.
                     * @param {Array} [values=[]] The array of values.
                     * @returns {Object} Returns an object composed of the given keys and
                     *  corresponding values.
                     * @example
                     *
                     * _.zipObject(['fred', 'barney'], [30, 40]);
                     * // => { 'fred': 30, 'barney': 40 }
                     */
                    function zipObject(keys, values) {
                        var index = -1,
                            length = keys ? keys.length : 0,
                            result = {};

                        if (!values && length && !isArray(keys[0])) {
                            values = [];
                        }
                        while (++index < length) {
                            var key = keys[index];
                            if (values) {
                                result[key] = values[index];
                            } else if (key) {
                                result[key[0]] = key[1];
                            }
                        }
                        return result;
                    }

                    /*--------------------------------------------------------------------------*/

                    /**
                     * Creates a function that executes `func`, with  the `this` binding and
                     * arguments of the created function, only after being called `n` times.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {number} n The number of times the function must be called before
                     *  `func` is executed.
                     * @param {Function} func The function to restrict.
                     * @returns {Function} Returns the new restricted function.
                     * @example
                     *
                     * var saves = ['profile', 'settings'];
                     *
                     * var done = _.after(saves.length, function() {
                     *   console.log('Done saving!');
                     * });
                     *
                     * _.forEach(saves, function(type) {
                     *   asyncSave({ 'type': type, 'complete': done });
                     * });
                     * // => logs 'Done saving!', after all saves have completed
                     */
                    function after(n, func) {
                        if (!isFunction(func)) {
                            throw new TypeError;
                        }
                        return function() {
                            if (--n < 1) {
                                return func.apply(this, arguments);
                            }
                        };
                    }

                    /**
                     * Creates a function that, when called, invokes `func` with the `this`
                     * binding of `thisArg` and prepends any additional `bind` arguments to those
                     * provided to the bound function.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Function} func The function to bind.
                     * @param {*} [thisArg] The `this` binding of `func`.
                     * @param {...*} [arg] Arguments to be partially applied.
                     * @returns {Function} Returns the new bound function.
                     * @example
                     *
                     * var func = function(greeting) {
                     *   return greeting + ' ' + this.name;
                     * };
                     *
                     * func = _.bind(func, { 'name': 'fred' }, 'hi');
                     * func();
                     * // => 'hi fred'
                     */
                    function bind(func, thisArg) {
                        return arguments.length > 2 ?
                            createWrapper(func, 17, slice(arguments, 2), null, thisArg) :
                            createWrapper(func, 1, null, null, thisArg);
                    }

                    /**
                     * Binds methods of an object to the object itself, overwriting the existing
                     * method. Method names may be specified as individual arguments or as arrays
                     * of method names. If no method names are provided all the function properties
                     * of `object` will be bound.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Object} object The object to bind and assign the bound methods to.
                     * @param {...string} [methodName] The object method names to
                     *  bind, specified as individual method names or arrays of method names.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * var view = {
                     *   'label': 'docs',
                     *   'onClick': function() { console.log('clicked ' + this.label); }
                     * };
                     *
                     * _.bindAll(view);
                     * jQuery('#docs').on('click', view.onClick);
                     * // => logs 'clicked docs', when the button is clicked
                     */
                    function bindAll(object) {
                        var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
                            index = -1,
                            length = funcs.length;

                        while (++index < length) {
                            var key = funcs[index];
                            object[key] = createWrapper(object[key], 1, null, null, object);
                        }
                        return object;
                    }

                    /**
                     * Creates a function that, when called, invokes the method at `object[key]`
                     * and prepends any additional `bindKey` arguments to those provided to the bound
                     * function. This method differs from `_.bind` by allowing bound functions to
                     * reference methods that will be redefined or don't yet exist.
                     * See http://michaux.ca/articles/lazy-function-definition-pattern.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Object} object The object the method belongs to.
                     * @param {string} key The key of the method.
                     * @param {...*} [arg] Arguments to be partially applied.
                     * @returns {Function} Returns the new bound function.
                     * @example
                     *
                     * var object = {
                     *   'name': 'fred',
                     *   'greet': function(greeting) {
                     *     return greeting + ' ' + this.name;
                     *   }
                     * };
                     *
                     * var func = _.bindKey(object, 'greet', 'hi');
                     * func();
                     * // => 'hi fred'
                     *
                     * object.greet = function(greeting) {
                     *   return greeting + 'ya ' + this.name + '!';
                     * };
                     *
                     * func();
                     * // => 'hiya fred!'
                     */
                    function bindKey(object, key) {
                        return arguments.length > 2 ?
                            createWrapper(key, 19, slice(arguments, 2), null, object) :
                            createWrapper(key, 3, null, null, object);
                    }

                    /**
                     * Creates a function that is the composition of the provided functions,
                     * where each function consumes the return value of the function that follows.
                     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
                     * Each function is executed with the `this` binding of the composed function.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {...Function} [func] Functions to compose.
                     * @returns {Function} Returns the new composed function.
                     * @example
                     *
                     * var realNameMap = {
                     *   'pebbles': 'penelope'
                     * };
                     *
                     * var format = function(name) {
                     *   name = realNameMap[name.toLowerCase()] || name;
                     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
                     * };
                     *
                     * var greet = function(formatted) {
                     *   return 'Hiya ' + formatted + '!';
                     * };
                     *
                     * var welcome = _.compose(greet, format);
                     * welcome('pebbles');
                     * // => 'Hiya Penelope!'
                     */
                    function compose() {
                        var funcs = arguments,
                            length = funcs.length;

                        while (length--) {
                            if (!isFunction(funcs[length])) {
                                throw new TypeError;
                            }
                        }
                        return function() {
                            var args = arguments,
                                length = funcs.length;

                            while (length--) {
                                args = [funcs[length].apply(this, args)];
                            }
                            return args[0];
                        };
                    }

                    /**
                     * Creates a function which accepts one or more arguments of `func` that when
                     * invoked either executes `func` returning its result, if all `func` arguments
                     * have been provided, or returns a function that accepts one or more of the
                     * remaining `func` arguments, and so on. The arity of `func` can be specified
                     * if `func.length` is not sufficient.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Function} func The function to curry.
                     * @param {number} [arity=func.length] The arity of `func`.
                     * @returns {Function} Returns the new curried function.
                     * @example
                     *
                     * var curried = _.curry(function(a, b, c) {
                     *   console.log(a + b + c);
                     * });
                     *
                     * curried(1)(2)(3);
                     * // => 6
                     *
                     * curried(1, 2)(3);
                     * // => 6
                     *
                     * curried(1, 2, 3);
                     * // => 6
                     */
                    function curry(func, arity) {
                        arity = typeof arity == 'number' ? arity : (+arity || func.length);
                        return createWrapper(func, 4, null, null, null, arity);
                    }

                    /**
                     * Creates a function that will delay the execution of `func` until after
                     * `wait` milliseconds have elapsed since the last time it was invoked.
                     * Provide an options object to indicate that `func` should be invoked on
                     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
                     * to the debounced function will return the result of the last `func` call.
                     *
                     * Note: If `leading` and `trailing` options are `true` `func` will be called
                     * on the trailing edge of the timeout only if the the debounced function is
                     * invoked more than once during the `wait` timeout.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Function} func The function to debounce.
                     * @param {number} wait The number of milliseconds to delay.
                     * @param {Object} [options] The options object.
                     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
                     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
                     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
                     * @returns {Function} Returns the new debounced function.
                     * @example
                     *
                     * // avoid costly calculations while the window size is in flux
                     * var lazyLayout = _.debounce(calculateLayout, 150);
                     * jQuery(window).on('resize', lazyLayout);
                     *
                     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
                     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
                     *   'leading': true,
                     *   'trailing': false
                     * });
                     *
                     * // ensure `batchLog` is executed once after 1 second of debounced calls
                     * var source = new EventSource('/stream');
                     * source.addEventListener('message', _.debounce(batchLog, 250, {
                     *   'maxWait': 1000
                     * }, false);
                     */
                    function debounce(func, wait, options) {
                        var args,
                            maxTimeoutId,
                            result,
                            stamp,
                            thisArg,
                            timeoutId,
                            trailingCall,
                            lastCalled = 0,
                            maxWait = false,
                            trailing = true;

                        if (!isFunction(func)) {
                            throw new TypeError;
                        }
                        wait = nativeMax(0, wait) || 0;
                        if (options === true) {
                            var leading = true;
                            trailing = false;
                        } else if (isObject(options)) {
                            leading = options.leading;
                            maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
                            trailing = 'trailing' in options ? options.trailing : trailing;
                        }
                        var delayed = function() {
                            var remaining = wait - (now() - stamp);
                            if (remaining <= 0) {
                                if (maxTimeoutId) {
                                    clearTimeout(maxTimeoutId);
                                }
                                var isCalled = trailingCall;
                                maxTimeoutId = timeoutId = trailingCall = undefined;
                                if (isCalled) {
                                    lastCalled = now();
                                    result = func.apply(thisArg, args);
                                    if (!timeoutId && !maxTimeoutId) {
                                        args = thisArg = null;
                                    }
                                }
                            } else {
                                timeoutId = setTimeout(delayed, remaining);
                            }
                        };

                        var maxDelayed = function() {
                            if (timeoutId) {
                                clearTimeout(timeoutId);
                            }
                            maxTimeoutId = timeoutId = trailingCall = undefined;
                            if (trailing || (maxWait !== wait)) {
                                lastCalled = now();
                                result = func.apply(thisArg, args);
                                if (!timeoutId && !maxTimeoutId) {
                                    args = thisArg = null;
                                }
                            }
                        };

                        return function() {
                            args = arguments;
                            stamp = now();
                            thisArg = this;
                            trailingCall = trailing && (timeoutId || !leading);

                            if (maxWait === false) {
                                var leadingCall = leading && !timeoutId;
                            } else {
                                if (!maxTimeoutId && !leading) {
                                    lastCalled = stamp;
                                }
                                var remaining = maxWait - (stamp - lastCalled),
                                    isCalled = remaining <= 0;

                                if (isCalled) {
                                    if (maxTimeoutId) {
                                        maxTimeoutId = clearTimeout(maxTimeoutId);
                                    }
                                    lastCalled = stamp;
                                    result = func.apply(thisArg, args);
                                } else if (!maxTimeoutId) {
                                    maxTimeoutId = setTimeout(maxDelayed, remaining);
                                }
                            }
                            if (isCalled && timeoutId) {
                                timeoutId = clearTimeout(timeoutId);
                            } else if (!timeoutId && wait !== maxWait) {
                                timeoutId = setTimeout(delayed, wait);
                            }
                            if (leadingCall) {
                                isCalled = true;
                                result = func.apply(thisArg, args);
                            }
                            if (isCalled && !timeoutId && !maxTimeoutId) {
                                args = thisArg = null;
                            }
                            return result;
                        };
                    }

                    /**
                     * Defers executing the `func` function until the current call stack has cleared.
                     * Additional arguments will be provided to `func` when it is invoked.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Function} func The function to defer.
                     * @param {...*} [arg] Arguments to invoke the function with.
                     * @returns {number} Returns the timer id.
                     * @example
                     *
                     * _.defer(function(text) { console.log(text); }, 'deferred');
                     * // logs 'deferred' after one or more milliseconds
                     */
                    function defer(func) {
                        if (!isFunction(func)) {
                            throw new TypeError;
                        }
                        var args = slice(arguments, 1);
                        return setTimeout(function() {
                            func.apply(undefined, args);
                        }, 1);
                    }

                    /**
                     * Executes the `func` function after `wait` milliseconds. Additional arguments
                     * will be provided to `func` when it is invoked.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Function} func The function to delay.
                     * @param {number} wait The number of milliseconds to delay execution.
                     * @param {...*} [arg] Arguments to invoke the function with.
                     * @returns {number} Returns the timer id.
                     * @example
                     *
                     * _.delay(function(text) { console.log(text); }, 1000, 'later');
                     * // => logs 'later' after one second
                     */
                    function delay(func, wait) {
                        if (!isFunction(func)) {
                            throw new TypeError;
                        }
                        var args = slice(arguments, 2);
                        return setTimeout(function() {
                            func.apply(undefined, args);
                        }, wait);
                    }

                    /**
                     * Creates a function that memoizes the result of `func`. If `resolver` is
                     * provided it will be used to determine the cache key for storing the result
                     * based on the arguments provided to the memoized function. By default, the
                     * first argument provided to the memoized function is used as the cache key.
                     * The `func` is executed with the `this` binding of the memoized function.
                     * The result cache is exposed as the `cache` property on the memoized function.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Function} func The function to have its output memoized.
                     * @param {Function} [resolver] A function used to resolve the cache key.
                     * @returns {Function} Returns the new memoizing function.
                     * @example
                     *
                     * var fibonacci = _.memoize(function(n) {
                     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
                     * });
                     *
                     * fibonacci(9)
                     * // => 34
                     *
                     * var data = {
                     *   'fred': { 'name': 'fred', 'age': 40 },
                     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
                     * };
                     *
                     * // modifying the result cache
                     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
                     * get('pebbles');
                     * // => { 'name': 'pebbles', 'age': 1 }
                     *
                     * get.cache.pebbles.name = 'penelope';
                     * get('pebbles');
                     * // => { 'name': 'penelope', 'age': 1 }
                     */
                    function memoize(func, resolver) {
                        if (!isFunction(func)) {
                            throw new TypeError;
                        }
                        var memoized = function() {
                            var cache = memoized.cache,
                                key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];

                            return hasOwnProperty.call(cache, key) ?
                                cache[key] :
                                (cache[key] = func.apply(this, arguments));
                        }
                        memoized.cache = {};
                        return memoized;
                    }

                    /**
                     * Creates a function that is restricted to execute `func` once. Repeat calls to
                     * the function will return the value of the first call. The `func` is executed
                     * with the `this` binding of the created function.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Function} func The function to restrict.
                     * @returns {Function} Returns the new restricted function.
                     * @example
                     *
                     * var initialize = _.once(createApplication);
                     * initialize();
                     * initialize();
                     * // `initialize` executes `createApplication` once
                     */
                    function once(func) {
                        var ran,
                            result;

                        if (!isFunction(func)) {
                            throw new TypeError;
                        }
                        return function() {
                            if (ran) {
                                return result;
                            }
                            ran = true;
                            result = func.apply(this, arguments);

                            // clear the `func` variable so the function may be garbage collected
                            func = null;
                            return result;
                        };
                    }

                    /**
                     * Creates a function that, when called, invokes `func` with any additional
                     * `partial` arguments prepended to those provided to the new function. This
                     * method is similar to `_.bind` except it does **not** alter the `this` binding.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Function} func The function to partially apply arguments to.
                     * @param {...*} [arg] Arguments to be partially applied.
                     * @returns {Function} Returns the new partially applied function.
                     * @example
                     *
                     * var greet = function(greeting, name) { return greeting + ' ' + name; };
                     * var hi = _.partial(greet, 'hi');
                     * hi('fred');
                     * // => 'hi fred'
                     */
                    function partial(func) {
                        return createWrapper(func, 16, slice(arguments, 1));
                    }

                    /**
                     * This method is like `_.partial` except that `partial` arguments are
                     * appended to those provided to the new function.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Function} func The function to partially apply arguments to.
                     * @param {...*} [arg] Arguments to be partially applied.
                     * @returns {Function} Returns the new partially applied function.
                     * @example
                     *
                     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
                     *
                     * var options = {
                     *   'variable': 'data',
                     *   'imports': { 'jq': $ }
                     * };
                     *
                     * defaultsDeep(options, _.templateSettings);
                     *
                     * options.variable
                     * // => 'data'
                     *
                     * options.imports
                     * // => { '_': _, 'jq': $ }
                     */
                    function partialRight(func) {
                        return createWrapper(func, 32, null, slice(arguments, 1));
                    }

                    /**
                     * Creates a function that, when executed, will only call the `func` function
                     * at most once per every `wait` milliseconds. Provide an options object to
                     * indicate that `func` should be invoked on the leading and/or trailing edge
                     * of the `wait` timeout. Subsequent calls to the throttled function will
                     * return the result of the last `func` call.
                     *
                     * Note: If `leading` and `trailing` options are `true` `func` will be called
                     * on the trailing edge of the timeout only if the the throttled function is
                     * invoked more than once during the `wait` timeout.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {Function} func The function to throttle.
                     * @param {number} wait The number of milliseconds to throttle executions to.
                     * @param {Object} [options] The options object.
                     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
                     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
                     * @returns {Function} Returns the new throttled function.
                     * @example
                     *
                     * // avoid excessively updating the position while scrolling
                     * var throttled = _.throttle(updatePosition, 100);
                     * jQuery(window).on('scroll', throttled);
                     *
                     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
                     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
                     *   'trailing': false
                     * }));
                     */
                    function throttle(func, wait, options) {
                        var leading = true,
                            trailing = true;

                        if (!isFunction(func)) {
                            throw new TypeError;
                        }
                        if (options === false) {
                            leading = false;
                        } else if (isObject(options)) {
                            leading = 'leading' in options ? options.leading : leading;
                            trailing = 'trailing' in options ? options.trailing : trailing;
                        }
                        debounceOptions.leading = leading;
                        debounceOptions.maxWait = wait;
                        debounceOptions.trailing = trailing;

                        return debounce(func, wait, debounceOptions);
                    }

                    /**
                     * Creates a function that provides `value` to the wrapper function as its
                     * first argument. Additional arguments provided to the function are appended
                     * to those provided to the wrapper function. The wrapper is executed with
                     * the `this` binding of the created function.
                     *
                     * @static
                     * @memberOf _
                     * @category Functions
                     * @param {*} value The value to wrap.
                     * @param {Function} wrapper The wrapper function.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var p = _.wrap(_.escape, function(func, text) {
                     *   return '<p>' + func(text) + '</p>';
                     * });
                     *
                     * p('Fred, Wilma, & Pebbles');
                     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
                     */
                    function wrap(value, wrapper) {
                        return createWrapper(wrapper, 16, [value]);
                    }

                    /*--------------------------------------------------------------------------*/

                    /**
                     * Creates a function that returns `value`.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {*} value The value to return from the new function.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var object = { 'name': 'fred' };
                     * var getter = _.constant(object);
                     * getter() === object;
                     * // => true
                     */
                    function constant(value) {
                        return function() {
                            return value;
                        };
                    }

                    /**
                     * Produces a callback bound to an optional `thisArg`. If `func` is a property
                     * name the created callback will return the property value for a given element.
                     * If `func` is an object the created callback will return `true` for elements
                     * that contain the equivalent object properties, otherwise it will return `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {*} [func=identity] The value to convert to a callback.
                     * @param {*} [thisArg] The `this` binding of the created callback.
                     * @param {number} [argCount] The number of arguments the callback accepts.
                     * @returns {Function} Returns a callback function.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36 },
                     *   { 'name': 'fred',   'age': 40 }
                     * ];
                     *
                     * // wrap to create custom callback shorthands
                     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
                     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
                     *   return !match ? func(callback, thisArg) : function(object) {
                     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
                     *   };
                     * });
                     *
                     * _.filter(characters, 'age__gt38');
                     * // => [{ 'name': 'fred', 'age': 40 }]
                     */
                    function createCallback(func, thisArg, argCount) {
                        var type = typeof func;
                        if (func == null || type == 'function') {
                            return baseCreateCallback(func, thisArg, argCount);
                        }
                        // handle "_.pluck" style callback shorthands
                        if (type != 'object') {
                            return property(func);
                        }
                        var props = keys(func),
                            key = props[0],
                            a = func[key];

                        // handle "_.where" style callback shorthands
                        if (props.length == 1 && a === a && !isObject(a)) {
                            // fast path the common case of providing an object with a single
                            // property containing a primitive value
                            return function(object) {
                                var b = object[key];
                                return a === b && (a !== 0 || (1 / a == 1 / b));
                            };
                        }
                        return function(object) {
                            var length = props.length,
                                result = false;

                            while (length--) {
                                if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
                                    break;
                                }
                            }
                            return result;
                        };
                    }

                    /**
                     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
                     * corresponding HTML entities.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {string} string The string to escape.
                     * @returns {string} Returns the escaped string.
                     * @example
                     *
                     * _.escape('Fred, Wilma, & Pebbles');
                     * // => 'Fred, Wilma, &amp; Pebbles'
                     */
                    function escape(string) {
                        return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
                    }

                    /**
                     * This method returns the first argument provided to it.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {*} value Any value.
                     * @returns {*} Returns `value`.
                     * @example
                     *
                     * var object = { 'name': 'fred' };
                     * _.identity(object) === object;
                     * // => true
                     */
                    function identity(value) {
                        return value;
                    }

                    /**
                     * Adds function properties of a source object to the destination object.
                     * If `object` is a function methods will be added to its prototype as well.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {Function|Object} [object=lodash] object The destination object.
                     * @param {Object} source The object of functions to add.
                     * @param {Object} [options] The options object.
                     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
                     * @example
                     *
                     * function capitalize(string) {
                     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
                     * }
                     *
                     * _.mixin({ 'capitalize': capitalize });
                     * _.capitalize('fred');
                     * // => 'Fred'
                     *
                     * _('fred').capitalize().value();
                     * // => 'Fred'
                     *
                     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
                     * _('fred').capitalize();
                     * // => 'Fred'
                     */
                    function mixin(object, source, options) {
                        var chain = true,
                            methodNames = source && functions(source);

                        if (!source || (!options && !methodNames.length)) {
                            if (options == null) {
                                options = source;
                            }
                            ctor = lodashWrapper;
                            source = object;
                            object = lodash;
                            methodNames = functions(source);
                        }
                        if (options === false) {
                            chain = false;
                        } else if (isObject(options) && 'chain' in options) {
                            chain = options.chain;
                        }
                        var ctor = object,
                            isFunc = isFunction(ctor);

                        forEach(methodNames, function(methodName) {
                            var func = object[methodName] = source[methodName];
                            if (isFunc) {
                                ctor.prototype[methodName] = function() {
                                    var chainAll = this.__chain__,
                                        value = this.__wrapped__,
                                        args = [value];

                                    push.apply(args, arguments);
                                    var result = func.apply(object, args);
                                    if (chain || chainAll) {
                                        if (value === result && isObject(result)) {
                                            return this;
                                        }
                                        result = new ctor(result);
                                        result.__chain__ = chainAll;
                                    }
                                    return result;
                                };
                            }
                        });
                    }

                    /**
                     * Reverts the '_' variable to its previous value and returns a reference to
                     * the `lodash` function.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @returns {Function} Returns the `lodash` function.
                     * @example
                     *
                     * var lodash = _.noConflict();
                     */
                    function noConflict() {
                        context._ = oldDash;
                        return this;
                    }

                    /**
                     * A no-operation function.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @example
                     *
                     * var object = { 'name': 'fred' };
                     * _.noop(object) === undefined;
                     * // => true
                     */
                    function noop() {
                        // no operation performed
                    }

                    /**
                     * Gets the number of milliseconds that have elapsed since the Unix epoch
                     * (1 January 1970 00:00:00 UTC).
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @example
                     *
                     * var stamp = _.now();
                     * _.defer(function() { console.log(_.now() - stamp); });
                     * // => logs the number of milliseconds it took for the deferred function to be called
                     */
                    var now = isNative(now = Date.now) && now || function() {
                        return new Date().getTime();
                    };

                    /**
                     * Converts the given value into an integer of the specified radix.
                     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
                     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
                     *
                     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
                     * implementations. See http://es5.github.io/#E.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {string} value The value to parse.
                     * @param {number} [radix] The radix used to interpret the value to parse.
                     * @returns {number} Returns the new integer value.
                     * @example
                     *
                     * _.parseInt('08');
                     * // => 8
                     */
                    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
                        // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
                        return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
                    };

                    /**
                     * Creates a "_.pluck" style function, which returns the `key` value of a
                     * given object.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {string} key The name of the property to retrieve.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'fred',   'age': 40 },
                     *   { 'name': 'barney', 'age': 36 }
                     * ];
                     *
                     * var getName = _.property('name');
                     *
                     * _.map(characters, getName);
                     * // => ['barney', 'fred']
                     *
                     * _.sortBy(characters, getName);
                     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
                     */
                    function property(key) {
                        return function(object) {
                            return object[key];
                        };
                    }

                    /**
                     * Produces a random number between `min` and `max` (inclusive). If only one
                     * argument is provided a number between `0` and the given number will be
                     * returned. If `floating` is truey or either `min` or `max` are floats a
                     * floating-point number will be returned instead of an integer.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {number} [min=0] The minimum possible value.
                     * @param {number} [max=1] The maximum possible value.
                     * @param {boolean} [floating=false] Specify returning a floating-point number.
                     * @returns {number} Returns a random number.
                     * @example
                     *
                     * _.random(0, 5);
                     * // => an integer between 0 and 5
                     *
                     * _.random(5);
                     * // => also an integer between 0 and 5
                     *
                     * _.random(5, true);
                     * // => a floating-point number between 0 and 5
                     *
                     * _.random(1.2, 5.2);
                     * // => a floating-point number between 1.2 and 5.2
                     */
                    function random(min, max, floating) {
                        var noMin = min == null,
                            noMax = max == null;

                        if (floating == null) {
                            if (typeof min == 'boolean' && noMax) {
                                floating = min;
                                min = 1;
                            } else if (!noMax && typeof max == 'boolean') {
                                floating = max;
                                noMax = true;
                            }
                        }
                        if (noMin && noMax) {
                            max = 1;
                        }
                        min = +min || 0;
                        if (noMax) {
                            max = min;
                            min = 0;
                        } else {
                            max = +max || 0;
                        }
                        if (floating || min % 1 || max % 1) {
                            var rand = nativeRandom();
                            return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
                        }
                        return baseRandom(min, max);
                    }

                    /**
                     * Resolves the value of property `key` on `object`. If `key` is a function
                     * it will be invoked with the `this` binding of `object` and its result returned,
                     * else the property value is returned. If `object` is falsey then `undefined`
                     * is returned.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {Object} object The object to inspect.
                     * @param {string} key The name of the property to resolve.
                     * @returns {*} Returns the resolved value.
                     * @example
                     *
                     * var object = {
                     *   'cheese': 'crumpets',
                     *   'stuff': function() {
                     *     return 'nonsense';
                     *   }
                     * };
                     *
                     * _.result(object, 'cheese');
                     * // => 'crumpets'
                     *
                     * _.result(object, 'stuff');
                     * // => 'nonsense'
                     */
                    function result(object, key) {
                        if (object) {
                            var value = object[key];
                            return isFunction(value) ? object[key]() : value;
                        }
                    }

                    /**
                     * A micro-templating method that handles arbitrary delimiters, preserves
                     * whitespace, and correctly escapes quotes within interpolated code.
                     *
                     * Note: In the development build, `_.template` utilizes sourceURLs for easier
                     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
                     *
                     * For more information on precompiling templates see:
                     * https://lodash.com/custom-builds
                     *
                     * For more information on Chrome extension sandboxes see:
                     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {string} text The template text.
                     * @param {Object} data The data object used to populate the text.
                     * @param {Object} [options] The options object.
                     * @param {RegExp} [options.escape] The "escape" delimiter.
                     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
                     * @param {Object} [options.imports] An object to import into the template as local variables.
                     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
                     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
                     * @param {string} [variable] The data object variable name.
                     * @returns {Function|string} Returns a compiled function when no `data` object
                     *  is given, else it returns the interpolated text.
                     * @example
                     *
                     * // using the "interpolate" delimiter to create a compiled template
                     * var compiled = _.template('hello <%= name %>');
                     * compiled({ 'name': 'fred' });
                     * // => 'hello fred'
                     *
                     * // using the "escape" delimiter to escape HTML in data property values
                     * _.template('<b><%- value %></b>', { 'value': '<script>' });
                     * // => '<b>&lt;script&gt;</b>'
                     *
                     * // using the "evaluate" delimiter to generate HTML
                     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
                     * _.template(list, { 'people': ['fred', 'barney'] });
                     * // => '<li>fred</li><li>barney</li>'
                     *
                     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
                     * _.template('hello ${ name }', { 'name': 'pebbles' });
                     * // => 'hello pebbles'
                     *
                     * // using the internal `print` function in "evaluate" delimiters
                     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
                     * // => 'hello barney!'
                     *
                     * // using a custom template delimiters
                     * _.templateSettings = {
                     *   'interpolate': /{{([\s\S]+?)}}/g
                     * };
                     *
                     * _.template('hello {{ name }}!', { 'name': 'mustache' });
                     * // => 'hello mustache!'
                     *
                     * // using the `imports` option to import jQuery
                     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
                     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
                     * // => '<li>fred</li><li>barney</li>'
                     *
                     * // using the `sourceURL` option to specify a custom sourceURL for the template
                     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
                     * compiled(data);
                     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
                     *
                     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
                     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
                     * compiled.source;
                     * // => function(data) {
                     *   var __t, __p = '', __e = _.escape;
                     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
                     *   return __p;
                     * }
                     *
                     * // using the `source` property to inline compiled templates for meaningful
                     * // line numbers in error messages and a stack trace
                     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
                     *   var JST = {\
                     *     "main": ' + _.template(mainText).source + '\
                     *   };\
                     * ');
                     */
                    function template(text, data, options) {
                        // based on John Resig's `tmpl` implementation
                        // http://ejohn.org/blog/javascript-micro-templating/
                        // and Laura Doktorova's doT.js
                        // https://github.com/olado/doT
                        var settings = lodash.templateSettings;
                        text = String(text || '');

                        // avoid missing dependencies when `iteratorTemplate` is not defined
                        options = defaults({}, options, settings);

                        var imports = defaults({}, options.imports, settings.imports),
                            importsKeys = keys(imports),
                            importsValues = values(imports);

                        var isEvaluating,
                            index = 0,
                            interpolate = options.interpolate || reNoMatch,
                            source = "__p += '";

                        // compile the regexp to match each delimiter
                        var reDelimiters = RegExp(
                            (options.escape || reNoMatch).source + '|' +
                            interpolate.source + '|' +
                            (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
                            (options.evaluate || reNoMatch).source + '|$', 'g');

                        text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                            interpolateValue || (interpolateValue = esTemplateValue);

                            // escape characters that cannot be included in string literals
                            source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

                            // replace delimiters with snippets
                            if (escapeValue) {
                                source += "' +\n__e(" + escapeValue + ") +\n'";
                            }
                            if (evaluateValue) {
                                isEvaluating = true;
                                source += "';\n" + evaluateValue + ";\n__p += '";
                            }
                            if (interpolateValue) {
                                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                            }
                            index = offset + match.length;

                            // the JS engine embedded in Adobe products requires returning the `match`
                            // string in order to produce the correct `offset` value
                            return match;
                        });

                        source += "';\n";

                        // if `variable` is not specified, wrap a with-statement around the generated
                        // code to add the data object to the top of the scope chain
                        var variable = options.variable,
                            hasVariable = variable;

                        if (!hasVariable) {
                            variable = 'obj';
                            source = 'with (' + variable + ') {\n' + source + '\n}\n';
                        }
                        // cleanup code by stripping empty strings
                        source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
                            .replace(reEmptyStringMiddle, '$1')
                            .replace(reEmptyStringTrailing, '$1;');

                        // frame code as the function body
                        source = 'function(' + variable + ') {\n' +
                            (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
                            "var __t, __p = '', __e = _.escape" +
                            (isEvaluating ?
                                ', __j = Array.prototype.join;\n' +
                                "function print() { __p += __j.call(arguments, '') }\n" :
                                ';\n'
                            ) +
                            source +
                            'return __p\n}';

                        // Use a sourceURL for easier debugging.
                        // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
                        var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';

                        try {
                            var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
                        } catch (e) {
                            e.source = source;
                            throw e;
                        }
                        if (data) {
                            return result(data);
                        }
                        // provide the compiled function's source by its `toString` method, in
                        // supported environments, or the `source` property as a convenience for
                        // inlining compiled templates during the build process
                        result.source = source;
                        return result;
                    }

                    /**
                     * Executes the callback `n` times, returning an array of the results
                     * of each callback execution. The callback is bound to `thisArg` and invoked
                     * with one argument; (index).
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {number} n The number of times to execute the callback.
                     * @param {Function} callback The function called per iteration.
                     * @param {*} [thisArg] The `this` binding of `callback`.
                     * @returns {Array} Returns an array of the results of each `callback` execution.
                     * @example
                     *
                     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
                     * // => [3, 6, 4]
                     *
                     * _.times(3, function(n) { mage.castSpell(n); });
                     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
                     *
                     * _.times(3, function(n) { this.cast(n); }, mage);
                     * // => also calls `mage.castSpell(n)` three times
                     */
                    function times(n, callback, thisArg) {
                        n = (n = +n) > -1 ? n : 0;
                        var index = -1,
                            result = Array(n);

                        callback = baseCreateCallback(callback, thisArg, 1);
                        while (++index < n) {
                            result[index] = callback(index);
                        }
                        return result;
                    }

                    /**
                     * The inverse of `_.escape` this method converts the HTML entities
                     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
                     * corresponding characters.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {string} string The string to unescape.
                     * @returns {string} Returns the unescaped string.
                     * @example
                     *
                     * _.unescape('Fred, Barney &amp; Pebbles');
                     * // => 'Fred, Barney & Pebbles'
                     */
                    function unescape(string) {
                        return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
                    }

                    /**
                     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
                     *
                     * @static
                     * @memberOf _
                     * @category Utilities
                     * @param {string} [prefix] The value to prefix the ID with.
                     * @returns {string} Returns the unique ID.
                     * @example
                     *
                     * _.uniqueId('contact_');
                     * // => 'contact_104'
                     *
                     * _.uniqueId();
                     * // => '105'
                     */
                    function uniqueId(prefix) {
                        var id = ++idCounter;
                        return String(prefix == null ? '' : prefix) + id;
                    }

                    /*--------------------------------------------------------------------------*/

                    /**
                     * Creates a `lodash` object that wraps the given value with explicit
                     * method chaining enabled.
                     *
                     * @static
                     * @memberOf _
                     * @category Chaining
                     * @param {*} value The value to wrap.
                     * @returns {Object} Returns the wrapper object.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'barney',  'age': 36 },
                     *   { 'name': 'fred',    'age': 40 },
                     *   { 'name': 'pebbles', 'age': 1 }
                     * ];
                     *
                     * var youngest = _.chain(characters)
                     *     .sortBy('age')
                     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
                     *     .first()
                     *     .value();
                     * // => 'pebbles is 1'
                     */
                    function chain(value) {
                        value = new lodashWrapper(value);
                        value.__chain__ = true;
                        return value;
                    }

                    /**
                     * Invokes `interceptor` with the `value` as the first argument and then
                     * returns `value`. The purpose of this method is to "tap into" a method
                     * chain in order to perform operations on intermediate results within
                     * the chain.
                     *
                     * @static
                     * @memberOf _
                     * @category Chaining
                     * @param {*} value The value to provide to `interceptor`.
                     * @param {Function} interceptor The function to invoke.
                     * @returns {*} Returns `value`.
                     * @example
                     *
                     * _([1, 2, 3, 4])
                     *  .tap(function(array) { array.pop(); })
                     *  .reverse()
                     *  .value();
                     * // => [3, 2, 1]
                     */
                    function tap(value, interceptor) {
                        interceptor(value);
                        return value;
                    }

                    /**
                     * Enables explicit method chaining on the wrapper object.
                     *
                     * @name chain
                     * @memberOf _
                     * @category Chaining
                     * @returns {*} Returns the wrapper object.
                     * @example
                     *
                     * var characters = [
                     *   { 'name': 'barney', 'age': 36 },
                     *   { 'name': 'fred',   'age': 40 }
                     * ];
                     *
                     * // without explicit chaining
                     * _(characters).first();
                     * // => { 'name': 'barney', 'age': 36 }
                     *
                     * // with explicit chaining
                     * _(characters).chain()
                     *   .first()
                     *   .pick('age')
                     *   .value();
                     * // => { 'age': 36 }
                     */
                    function wrapperChain() {
                        this.__chain__ = true;
                        return this;
                    }

                    /**
                     * Produces the `toString` result of the wrapped value.
                     *
                     * @name toString
                     * @memberOf _
                     * @category Chaining
                     * @returns {string} Returns the string result.
                     * @example
                     *
                     * _([1, 2, 3]).toString();
                     * // => '1,2,3'
                     */
                    function wrapperToString() {
                        return String(this.__wrapped__);
                    }

                    /**
                     * Extracts the wrapped value.
                     *
                     * @name valueOf
                     * @memberOf _
                     * @alias value
                     * @category Chaining
                     * @returns {*} Returns the wrapped value.
                     * @example
                     *
                     * _([1, 2, 3]).valueOf();
                     * // => [1, 2, 3]
                     */
                    function wrapperValueOf() {
                        return this.__wrapped__;
                    }

                    /*--------------------------------------------------------------------------*/

                    // add functions that return wrapped values when chaining
                    lodash.after = after;
                    lodash.assign = assign;
                    lodash.at = at;
                    lodash.bind = bind;
                    lodash.bindAll = bindAll;
                    lodash.bindKey = bindKey;
                    lodash.chain = chain;
                    lodash.compact = compact;
                    lodash.compose = compose;
                    lodash.constant = constant;
                    lodash.countBy = countBy;
                    lodash.create = create;
                    lodash.createCallback = createCallback;
                    lodash.curry = curry;
                    lodash.debounce = debounce;
                    lodash.defaults = defaults;
                    lodash.defer = defer;
                    lodash.delay = delay;
                    lodash.difference = difference;
                    lodash.filter = filter;
                    lodash.flatten = flatten;
                    lodash.forEach = forEach;
                    lodash.forEachRight = forEachRight;
                    lodash.forIn = forIn;
                    lodash.forInRight = forInRight;
                    lodash.forOwn = forOwn;
                    lodash.forOwnRight = forOwnRight;
                    lodash.functions = functions;
                    lodash.groupBy = groupBy;
                    lodash.indexBy = indexBy;
                    lodash.initial = initial;
                    lodash.intersection = intersection;
                    lodash.invert = invert;
                    lodash.invoke = invoke;
                    lodash.keys = keys;
                    lodash.map = map;
                    lodash.mapValues = mapValues;
                    lodash.max = max;
                    lodash.memoize = memoize;
                    lodash.merge = merge;
                    lodash.min = min;
                    lodash.omit = omit;
                    lodash.once = once;
                    lodash.pairs = pairs;
                    lodash.partial = partial;
                    lodash.partialRight = partialRight;
                    lodash.pick = pick;
                    lodash.pluck = pluck;
                    lodash.property = property;
                    lodash.pull = pull;
                    lodash.range = range;
                    lodash.reject = reject;
                    lodash.remove = remove;
                    lodash.rest = rest;
                    lodash.shuffle = shuffle;
                    lodash.sortBy = sortBy;
                    lodash.tap = tap;
                    lodash.throttle = throttle;
                    lodash.times = times;
                    lodash.toArray = toArray;
                    lodash.transform = transform;
                    lodash.union = union;
                    lodash.uniq = uniq;
                    lodash.values = values;
                    lodash.where = where;
                    lodash.without = without;
                    lodash.wrap = wrap;
                    lodash.xor = xor;
                    lodash.zip = zip;
                    lodash.zipObject = zipObject;

                    // add aliases
                    lodash.collect = map;
                    lodash.drop = rest;
                    lodash.each = forEach;
                    lodash.eachRight = forEachRight;
                    lodash.extend = assign;
                    lodash.methods = functions;
                    lodash.object = zipObject;
                    lodash.select = filter;
                    lodash.tail = rest;
                    lodash.unique = uniq;
                    lodash.unzip = zip;

                    // add functions to `lodash.prototype`
                    mixin(lodash);

                    /*--------------------------------------------------------------------------*/

                    // add functions that return unwrapped values when chaining
                    lodash.clone = clone;
                    lodash.cloneDeep = cloneDeep;
                    lodash.contains = contains;
                    lodash.escape = escape;
                    lodash.every = every;
                    lodash.find = find;
                    lodash.findIndex = findIndex;
                    lodash.findKey = findKey;
                    lodash.findLast = findLast;
                    lodash.findLastIndex = findLastIndex;
                    lodash.findLastKey = findLastKey;
                    lodash.has = has;
                    lodash.identity = identity;
                    lodash.indexOf = indexOf;
                    lodash.isArguments = isArguments;
                    lodash.isArray = isArray;
                    lodash.isBoolean = isBoolean;
                    lodash.isDate = isDate;
                    lodash.isElement = isElement;
                    lodash.isEmpty = isEmpty;
                    lodash.isEqual = isEqual;
                    lodash.isFinite = isFinite;
                    lodash.isFunction = isFunction;
                    lodash.isNaN = isNaN;
                    lodash.isNull = isNull;
                    lodash.isNumber = isNumber;
                    lodash.isObject = isObject;
                    lodash.isPlainObject = isPlainObject;
                    lodash.isRegExp = isRegExp;
                    lodash.isString = isString;
                    lodash.isUndefined = isUndefined;
                    lodash.lastIndexOf = lastIndexOf;
                    lodash.mixin = mixin;
                    lodash.noConflict = noConflict;
                    lodash.noop = noop;
                    lodash.now = now;
                    lodash.parseInt = parseInt;
                    lodash.random = random;
                    lodash.reduce = reduce;
                    lodash.reduceRight = reduceRight;
                    lodash.result = result;
                    lodash.runInContext = runInContext;
                    lodash.size = size;
                    lodash.some = some;
                    lodash.sortedIndex = sortedIndex;
                    lodash.template = template;
                    lodash.unescape = unescape;
                    lodash.uniqueId = uniqueId;

                    // add aliases
                    lodash.all = every;
                    lodash.any = some;
                    lodash.detect = find;
                    lodash.findWhere = find;
                    lodash.foldl = reduce;
                    lodash.foldr = reduceRight;
                    lodash.include = contains;
                    lodash.inject = reduce;

                    mixin(function() {
                        var source = {}
                        forOwn(lodash, function(func, methodName) {
                            if (!lodash.prototype[methodName]) {
                                source[methodName] = func;
                            }
                        });
                        return source;
                    }(), false);

                    /*--------------------------------------------------------------------------*/

                    // add functions capable of returning wrapped and unwrapped values when chaining
                    lodash.first = first;
                    lodash.last = last;
                    lodash.sample = sample;

                    // add aliases
                    lodash.take = first;
                    lodash.head = first;

                    forOwn(lodash, function(func, methodName) {
                        var callbackable = methodName !== 'sample';
                        if (!lodash.prototype[methodName]) {
                            lodash.prototype[methodName] = function(n, guard) {
                                var chainAll = this.__chain__,
                                    result = func(this.__wrapped__, n, guard);

                                return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function'))) ?
                                    result :
                                    new lodashWrapper(result, chainAll);
                            };
                        }
                    });

                    /*--------------------------------------------------------------------------*/

                    /**
                     * The semantic version number.
                     *
                     * @static
                     * @memberOf _
                     * @type string
                     */
                    lodash.VERSION = '2.4.2';

                    // add "Chaining" functions to the wrapper
                    lodash.prototype.chain = wrapperChain;
                    lodash.prototype.toString = wrapperToString;
                    lodash.prototype.value = wrapperValueOf;
                    lodash.prototype.valueOf = wrapperValueOf;

                    // add `Array` functions that return unwrapped values
                    forEach(['join', 'pop', 'shift'], function(methodName) {
                        var func = arrayRef[methodName];
                        lodash.prototype[methodName] = function() {
                            var chainAll = this.__chain__,
                                result = func.apply(this.__wrapped__, arguments);

                            return chainAll ?
                                new lodashWrapper(result, chainAll) :
                                result;
                        };
                    });

                    // add `Array` functions that return the existing wrapped value
                    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
                        var func = arrayRef[methodName];
                        lodash.prototype[methodName] = function() {
                            func.apply(this.__wrapped__, arguments);
                            return this;
                        };
                    });

                    // add `Array` functions that return new wrapped values
                    forEach(['concat', 'slice', 'splice'], function(methodName) {
                        var func = arrayRef[methodName];
                        lodash.prototype[methodName] = function() {
                            return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
                        };
                    });

                    return lodash;
                }

                /*--------------------------------------------------------------------------*/

                // expose Lo-Dash
                var _ = runInContext();

                // some AMD build optimizers like r.js check for condition patterns like the following:
                if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
                    // Expose Lo-Dash to the global object even when an AMD loader is present in
                    // case Lo-Dash is loaded with a RequireJS shim config.
                    // See http://requirejs.org/docs/api.html#config-shim
                    root._ = _;

                    // define as an anonymous module so, through path mapping, it can be
                    // referenced as the "underscore" module
                    define(function() {
                        return _;
                    });
                }
                // check for `exports` after `define` in case a build optimizer adds an `exports` object
                else if (freeExports && freeModule) {
                    // in Node.js or RingoJS
                    if (moduleExports) {
                        (freeModule.exports = _)._ = _;
                    }
                    // in Narwhal or Rhino -require
                    else {
                        freeExports._ = _;
                    }
                } else {
                    // in a browser or Rhino
                    root._ = _;
                }
            }.call(this));

        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

    }, {}],
    31: [function(require, module, exports) {
        /**
         * Copyright (c) 2014, Chris Pettitt
         * All rights reserved.
         *
         * Redistribution and use in source and binary forms, with or without
         * modification, are permitted provided that the following conditions are met:
         *
         * 1. Redistributions of source code must retain the above copyright notice, this
         * list of conditions and the following disclaimer.
         *
         * 2. Redistributions in binary form must reproduce the above copyright notice,
         * this list of conditions and the following disclaimer in the documentation
         * and/or other materials provided with the distribution.
         *
         * 3. Neither the name of the copyright holder nor the names of its contributors
         * may be used to endorse or promote products derived from this software without
         * specific prior written permission.
         *
         * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
         * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
         * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
         * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
         * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
         * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
         * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
         * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
         * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
         * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
         */

        var lib = require("./lib");

        module.exports = {
            Graph: lib.Graph,
            json: require("./lib/json"),
            alg: require("./lib/alg"),
            version: lib.version
        };

    }, {
        "./lib": 47,
        "./lib/alg": 38,
        "./lib/json": 48
    }],
    32: [function(require, module, exports) {
        var _ = require("../lodash");

        module.exports = components;

        function components(g) {
            var visited = {},
                cmpts = [],
                cmpt;

            function dfs(v) {
                if (_.has(visited, v)) return;
                visited[v] = true;
                cmpt.push(v);
                _.each(g.successors(v), dfs);
                _.each(g.predecessors(v), dfs);
            }

            _.each(g.nodes(), function(v) {
                cmpt = [];
                dfs(v);
                if (cmpt.length) {
                    cmpts.push(cmpt);
                }
            });

            return cmpts;
        }

    }, {
        "../lodash": 49
    }],
    33: [function(require, module, exports) {
        var _ = require("../lodash");

        module.exports = dfs;

        /*
         * A helper that preforms a pre- or post-order traversal on the input graph
         * and returns the nodes in the order they were visited. This algorithm treats
         * the input as undirected.
         *
         * Order must be one of "pre" or "post".
         */
        function dfs(g, vs, order) {
            if (!_.isArray(vs)) {
                vs = [vs];
            }

            var acc = [],
                visited = {};
            _.each(vs, function(v) {
                if (!g.hasNode(v)) {
                    throw new Error("Graph does not have node: " + v);
                }

                doDfs(g, v, order === "post", visited, acc);
            });
            return acc;
        }

        function doDfs(g, v, postorder, visited, acc) {
            if (!_.has(visited, v)) {
                visited[v] = true;

                if (!postorder) {
                    acc.push(v);
                }
                _.each(g.neighbors(v), function(w) {
                    doDfs(g, w, postorder, visited, acc);
                });
                if (postorder) {
                    acc.push(v);
                }
            }
        }

    }, {
        "../lodash": 49
    }],
    34: [function(require, module, exports) {
        var dijkstra = require("./dijkstra"),
            _ = require("../lodash");

        module.exports = dijkstraAll;

        function dijkstraAll(g, weightFunc, edgeFunc) {
            return _.transform(g.nodes(), function(acc, v) {
                acc[v] = dijkstra(g, v, weightFunc, edgeFunc);
            }, {});
        }

    }, {
        "../lodash": 49,
        "./dijkstra": 35
    }],
    35: [function(require, module, exports) {
        var _ = require("../lodash"),
            PriorityQueue = require("../data/priority-queue");

        module.exports = dijkstra;

        var DEFAULT_WEIGHT_FUNC = _.constant(1);

        function dijkstra(g, source, weightFn, edgeFn) {
            return runDijkstra(g, String(source),
                weightFn || DEFAULT_WEIGHT_FUNC,
                edgeFn || function(v) {
                    return g.outEdges(v);
                });
        }

        function runDijkstra(g, source, weightFn, edgeFn) {
            var results = {},
                pq = new PriorityQueue(),
                v, vEntry;

            var updateNeighbors = function(edge) {
                var w = edge.v !== v ? edge.v : edge.w,
                    wEntry = results[w],
                    weight = weightFn(edge),
                    distance = vEntry.distance + weight;

                if (weight < 0) {
                    throw new Error("dijkstra does not allow negative edge weights. " +
                        "Bad edge: " + edge + " Weight: " + weight);
                }

                if (distance < wEntry.distance) {
                    wEntry.distance = distance;
                    wEntry.predecessor = v;
                    pq.decrease(w, distance);
                }
            };

            g.nodes().forEach(function(v) {
                var distance = v === source ? 0 : Number.POSITIVE_INFINITY;
                results[v] = {
                    distance: distance
                };
                pq.add(v, distance);
            });

            while (pq.size() > 0) {
                v = pq.removeMin();
                vEntry = results[v];
                if (vEntry.distance === Number.POSITIVE_INFINITY) {
                    break;
                }

                edgeFn(v).forEach(updateNeighbors);
            }

            return results;
        }

    }, {
        "../data/priority-queue": 45,
        "../lodash": 49
    }],
    36: [function(require, module, exports) {
        var _ = require("../lodash"),
            tarjan = require("./tarjan");

        module.exports = findCycles;

        function findCycles(g) {
            return _.filter(tarjan(g), function(cmpt) {
                return cmpt.length > 1 || (cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]));
            });
        }

    }, {
        "../lodash": 49,
        "./tarjan": 43
    }],
    37: [function(require, module, exports) {
        var _ = require("../lodash");

        module.exports = floydWarshall;

        var DEFAULT_WEIGHT_FUNC = _.constant(1);

        function floydWarshall(g, weightFn, edgeFn) {
            return runFloydWarshall(g,
                weightFn || DEFAULT_WEIGHT_FUNC,
                edgeFn || function(v) {
                    return g.outEdges(v);
                });
        }

        function runFloydWarshall(g, weightFn, edgeFn) {
            var results = {},
                nodes = g.nodes();

            nodes.forEach(function(v) {
                results[v] = {};
                results[v][v] = {
                    distance: 0
                };
                nodes.forEach(function(w) {
                    if (v !== w) {
                        results[v][w] = {
                            distance: Number.POSITIVE_INFINITY
                        };
                    }
                });
                edgeFn(v).forEach(function(edge) {
                    var w = edge.v === v ? edge.w : edge.v,
                        d = weightFn(edge);
                    results[v][w] = {
                        distance: d,
                        predecessor: v
                    };
                });
            });

            nodes.forEach(function(k) {
                var rowK = results[k];
                nodes.forEach(function(i) {
                    var rowI = results[i];
                    nodes.forEach(function(j) {
                        var ik = rowI[k];
                        var kj = rowK[j];
                        var ij = rowI[j];
                        var altDistance = ik.distance + kj.distance;
                        if (altDistance < ij.distance) {
                            ij.distance = altDistance;
                            ij.predecessor = kj.predecessor;
                        }
                    });
                });
            });

            return results;
        }

    }, {
        "../lodash": 49
    }],
    38: [function(require, module, exports) {
        module.exports = {
            components: require("./components"),
            dijkstra: require("./dijkstra"),
            dijkstraAll: require("./dijkstra-all"),
            findCycles: require("./find-cycles"),
            floydWarshall: require("./floyd-warshall"),
            isAcyclic: require("./is-acyclic"),
            postorder: require("./postorder"),
            preorder: require("./preorder"),
            prim: require("./prim"),
            tarjan: require("./tarjan"),
            topsort: require("./topsort")
        };

    }, {
        "./components": 32,
        "./dijkstra": 35,
        "./dijkstra-all": 34,
        "./find-cycles": 36,
        "./floyd-warshall": 37,
        "./is-acyclic": 39,
        "./postorder": 40,
        "./preorder": 41,
        "./prim": 42,
        "./tarjan": 43,
        "./topsort": 44
    }],
    39: [function(require, module, exports) {
        var topsort = require("./topsort");

        module.exports = isAcyclic;

        function isAcyclic(g) {
            try {
                topsort(g);
            } catch (e) {
                if (e instanceof topsort.CycleException) {
                    return false;
                }
                throw e;
            }
            return true;
        }

    }, {
        "./topsort": 44
    }],
    40: [function(require, module, exports) {
        var dfs = require("./dfs");

        module.exports = postorder;

        function postorder(g, vs) {
            return dfs(g, vs, "post");
        }

    }, {
        "./dfs": 33
    }],
    41: [function(require, module, exports) {
        var dfs = require("./dfs");

        module.exports = preorder;

        function preorder(g, vs) {
            return dfs(g, vs, "pre");
        }

    }, {
        "./dfs": 33
    }],
    42: [function(require, module, exports) {
        var _ = require("../lodash"),
            Graph = require("../graph"),
            PriorityQueue = require("../data/priority-queue");

        module.exports = prim;

        function prim(g, weightFunc) {
            var result = new Graph(),
                parents = {},
                pq = new PriorityQueue(),
                v;

            function updateNeighbors(edge) {
                var w = edge.v === v ? edge.w : edge.v,
                    pri = pq.priority(w);
                if (pri !== undefined) {
                    var edgeWeight = weightFunc(edge);
                    if (edgeWeight < pri) {
                        parents[w] = v;
                        pq.decrease(w, edgeWeight);
                    }
                }
            }

            if (g.nodeCount() === 0) {
                return result;
            }

            _.each(g.nodes(), function(v) {
                pq.add(v, Number.POSITIVE_INFINITY);
                result.setNode(v);
            });

            // Start from an arbitrary node
            pq.decrease(g.nodes()[0], 0);

            var init = false;
            while (pq.size() > 0) {
                v = pq.removeMin();
                if (_.has(parents, v)) {
                    result.setEdge(v, parents[v]);
                } else if (init) {
                    throw new Error("Input graph is not connected: " + g);
                } else {
                    init = true;
                }

                g.nodeEdges(v).forEach(updateNeighbors);
            }

            return result;
        }

    }, {
        "../data/priority-queue": 45,
        "../graph": 46,
        "../lodash": 49
    }],
    43: [function(require, module, exports) {
        var _ = require("../lodash");

        module.exports = tarjan;

        function tarjan(g) {
            var index = 0,
                stack = [],
                visited = {}, // node id -> { onStack, lowlink, index }
                results = [];

            function dfs(v) {
                var entry = visited[v] = {
                    onStack: true,
                    lowlink: index,
                    index: index++
                };
                stack.push(v);

                g.successors(v).forEach(function(w) {
                    if (!_.has(visited, w)) {
                        dfs(w);
                        entry.lowlink = Math.min(entry.lowlink, visited[w].lowlink);
                    } else if (visited[w].onStack) {
                        entry.lowlink = Math.min(entry.lowlink, visited[w].index);
                    }
                });

                if (entry.lowlink === entry.index) {
                    var cmpt = [],
                        w;
                    do {
                        w = stack.pop();
                        visited[w].onStack = false;
                        cmpt.push(w);
                    } while (v !== w);
                    results.push(cmpt);
                }
            }

            g.nodes().forEach(function(v) {
                if (!_.has(visited, v)) {
                    dfs(v);
                }
            });

            return results;
        }

    }, {
        "../lodash": 49
    }],
    44: [function(require, module, exports) {
        var _ = require("../lodash");

        module.exports = topsort;
        topsort.CycleException = CycleException;

        function topsort(g) {
            var visited = {},
                stack = {},
                results = [];

            function visit(node) {
                if (_.has(stack, node)) {
                    throw new CycleException();
                }

                if (!_.has(visited, node)) {
                    stack[node] = true;
                    visited[node] = true;
                    _.each(g.predecessors(node), visit);
                    delete stack[node];
                    results.push(node);
                }
            }

            _.each(g.sinks(), visit);

            if (_.size(visited) !== g.nodeCount()) {
                throw new CycleException();
            }

            return results;
        }

        function CycleException() {}

    }, {
        "../lodash": 49
    }],
    45: [function(require, module, exports) {
        var _ = require("../lodash");

        module.exports = PriorityQueue;

        /**
         * A min-priority queue data structure. This algorithm is derived from Cormen,
         * et al., "Introduction to Algorithms". The basic idea of a min-priority
         * queue is that you can efficiently (in O(1) time) get the smallest key in
         * the queue. Adding and removing elements takes O(log n) time. A key can
         * have its priority decreased in O(log n) time.
         */
        function PriorityQueue() {
            this._arr = [];
            this._keyIndices = {};
        }

        /**
         * Returns the number of elements in the queue. Takes `O(1)` time.
         */
        PriorityQueue.prototype.size = function() {
            return this._arr.length;
        };

        /**
         * Returns the keys that are in the queue. Takes `O(n)` time.
         */
        PriorityQueue.prototype.keys = function() {
            return this._arr.map(function(x) {
                return x.key;
            });
        };

        /**
         * Returns `true` if **key** is in the queue and `false` if not.
         */
        PriorityQueue.prototype.has = function(key) {
            return _.has(this._keyIndices, key);
        };

        /**
         * Returns the priority for **key**. If **key** is not present in the queue
         * then this function returns `undefined`. Takes `O(1)` time.
         *
         * @param {Object} key
         */
        PriorityQueue.prototype.priority = function(key) {
            var index = this._keyIndices[key];
            if (index !== undefined) {
                return this._arr[index].priority;
            }
        };

        /**
         * Returns the key for the minimum element in this queue. If the queue is
         * empty this function throws an Error. Takes `O(1)` time.
         */
        PriorityQueue.prototype.min = function() {
            if (this.size() === 0) {
                throw new Error("Queue underflow");
            }
            return this._arr[0].key;
        };

        /**
         * Inserts a new key into the priority queue. If the key already exists in
         * the queue this function returns `false`; otherwise it will return `true`.
         * Takes `O(n)` time.
         *
         * @param {Object} key the key to add
         * @param {Number} priority the initial priority for the key
         */
        PriorityQueue.prototype.add = function(key, priority) {
            var keyIndices = this._keyIndices;
            key = String(key);
            if (!_.has(keyIndices, key)) {
                var arr = this._arr;
                var index = arr.length;
                keyIndices[key] = index;
                arr.push({
                    key: key,
                    priority: priority
                });
                this._decrease(index);
                return true;
            }
            return false;
        };

        /**
         * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
         */
        PriorityQueue.prototype.removeMin = function() {
            this._swap(0, this._arr.length - 1);
            var min = this._arr.pop();
            delete this._keyIndices[min.key];
            this._heapify(0);
            return min.key;
        };

        /**
         * Decreases the priority for **key** to **priority**. If the new priority is
         * greater than the previous priority, this function will throw an Error.
         *
         * @param {Object} key the key for which to raise priority
         * @param {Number} priority the new priority for the key
         */
        PriorityQueue.prototype.decrease = function(key, priority) {
            var index = this._keyIndices[key];
            if (priority > this._arr[index].priority) {
                throw new Error("New priority is greater than current priority. " +
                    "Key: " + key + " Old: " + this._arr[index].priority + " New: " + priority);
            }
            this._arr[index].priority = priority;
            this._decrease(index);
        };

        PriorityQueue.prototype._heapify = function(i) {
            var arr = this._arr;
            var l = 2 * i,
                r = l + 1,
                largest = i;
            if (l < arr.length) {
                largest = arr[l].priority < arr[largest].priority ? l : largest;
                if (r < arr.length) {
                    largest = arr[r].priority < arr[largest].priority ? r : largest;
                }
                if (largest !== i) {
                    this._swap(i, largest);
                    this._heapify(largest);
                }
            }
        };

        PriorityQueue.prototype._decrease = function(index) {
            var arr = this._arr;
            var priority = arr[index].priority;
            var parent;
            while (index !== 0) {
                parent = index >> 1;
                if (arr[parent].priority < priority) {
                    break;
                }
                this._swap(index, parent);
                index = parent;
            }
        };

        PriorityQueue.prototype._swap = function(i, j) {
            var arr = this._arr;
            var keyIndices = this._keyIndices;
            var origArrI = arr[i];
            var origArrJ = arr[j];
            arr[i] = origArrJ;
            arr[j] = origArrI;
            keyIndices[origArrJ.key] = i;
            keyIndices[origArrI.key] = j;
        };

    }, {
        "../lodash": 49
    }],
    46: [function(require, module, exports) {
        "use strict";

        var _ = require("./lodash");

        module.exports = Graph;

        var DEFAULT_EDGE_NAME = "\x00",
            GRAPH_NODE = "\x00",
            EDGE_KEY_DELIM = "\x01";

        // Implementation notes:
        //
        //  * Node id query functions should return string ids for the nodes
        //  * Edge id query functions should return an "edgeObj", edge object, that is
        //    composed of enough information to uniquely identify an edge: {v, w, name}.
        //  * Internally we use an "edgeId", a stringified form of the edgeObj, to
        //    reference edges. This is because we need a performant way to look these
        //    edges up and, object properties, which have string keys, are the closest
        //    we're going to get to a performant hashtable in JavaScript.

        function Graph(opts) {
            this._isDirected = _.has(opts, "directed") ? opts.directed : true;
            this._isMultigraph = _.has(opts, "multigraph") ? opts.multigraph : false;
            this._isCompound = _.has(opts, "compound") ? opts.compound : false;

            // Label for the graph itself
            this._label = undefined;

            // Defaults to be set when creating a new node
            this._defaultNodeLabelFn = _.constant(undefined);

            // Defaults to be set when creating a new edge
            this._defaultEdgeLabelFn = _.constant(undefined);

            // v -> label
            this._nodes = {};

            if (this._isCompound) {
                // v -> parent
                this._parent = {};

                // v -> children
                this._children = {};
                this._children[GRAPH_NODE] = {};
            }

            // v -> edgeObj
            this._in = {};

            // u -> v -> Number
            this._preds = {};

            // v -> edgeObj
            this._out = {};

            // v -> w -> Number
            this._sucs = {};

            // e -> edgeObj
            this._edgeObjs = {};

            // e -> label
            this._edgeLabels = {};
        }

        /* Number of nodes in the graph. Should only be changed by the implementation. */
        Graph.prototype._nodeCount = 0;

        /* Number of edges in the graph. Should only be changed by the implementation. */
        Graph.prototype._edgeCount = 0;


        /* === Graph functions ========= */

        Graph.prototype.isDirected = function() {
            return this._isDirected;
        };

        Graph.prototype.isMultigraph = function() {
            return this._isMultigraph;
        };

        Graph.prototype.isCompound = function() {
            return this._isCompound;
        };

        Graph.prototype.setGraph = function(label) {
            this._label = label;
            return this;
        };

        Graph.prototype.graph = function() {
            return this._label;
        };


        /* === Node functions ========== */

        Graph.prototype.setDefaultNodeLabel = function(newDefault) {
            if (!_.isFunction(newDefault)) {
                newDefault = _.constant(newDefault);
            }
            this._defaultNodeLabelFn = newDefault;
            return this;
        };

        Graph.prototype.nodeCount = function() {
            return this._nodeCount;
        };

        Graph.prototype.nodes = function() {
            return _.keys(this._nodes);
        };

        Graph.prototype.sources = function() {
            return _.filter(this.nodes(), function(v) {
                return _.isEmpty(this._in[v]);
            }, this);
        };

        Graph.prototype.sinks = function() {
            return _.filter(this.nodes(), function(v) {
                return _.isEmpty(this._out[v]);
            }, this);
        };

        Graph.prototype.setNodes = function(vs, value) {
            var args = arguments;
            _.each(vs, function(v) {
                if (args.length > 1) {
                    this.setNode(v, value);
                } else {
                    this.setNode(v);
                }
            }, this);
            return this;
        };

        Graph.prototype.setNode = function(v, value) {
            if (_.has(this._nodes, v)) {
                if (arguments.length > 1) {
                    this._nodes[v] = value;
                }
                return this;
            }

            this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v);
            if (this._isCompound) {
                this._parent[v] = GRAPH_NODE;
                this._children[v] = {};
                this._children[GRAPH_NODE][v] = true;
            }
            this._in[v] = {};
            this._preds[v] = {};
            this._out[v] = {};
            this._sucs[v] = {};
            ++this._nodeCount;
            return this;
        };

        Graph.prototype.node = function(v) {
            return this._nodes[v];
        };

        Graph.prototype.hasNode = function(v) {
            return _.has(this._nodes, v);
        };

        Graph.prototype.removeNode = function(v) {
            var self = this;
            if (_.has(this._nodes, v)) {
                var removeEdge = function(e) {
                    self.removeEdge(self._edgeObjs[e]);
                };
                delete this._nodes[v];
                if (this._isCompound) {
                    this._removeFromParentsChildList(v);
                    delete this._parent[v];
                    _.each(this.children(v), function(child) {
                        this.setParent(child);
                    }, this);
                    delete this._children[v];
                }
                _.each(_.keys(this._in[v]), removeEdge);
                delete this._in[v];
                delete this._preds[v];
                _.each(_.keys(this._out[v]), removeEdge);
                delete this._out[v];
                delete this._sucs[v];
                --this._nodeCount;
            }
            return this;
        };

        Graph.prototype.setParent = function(v, parent) {
            if (!this._isCompound) {
                throw new Error("Cannot set parent in a non-compound graph");
            }

            if (_.isUndefined(parent)) {
                parent = GRAPH_NODE;
            } else {
                // Coerce parent to string
                parent += "";
                for (var ancestor = parent; !_.isUndefined(ancestor); ancestor = this.parent(ancestor)) {
                    if (ancestor === v) {
                        throw new Error("Setting " + parent + " as parent of " + v +
                            " would create create a cycle");
                    }
                }

                this.setNode(parent);
            }

            this.setNode(v);
            this._removeFromParentsChildList(v);
            this._parent[v] = parent;
            this._children[parent][v] = true;
            return this;
        };

        Graph.prototype._removeFromParentsChildList = function(v) {
            delete this._children[this._parent[v]][v];
        };

        Graph.prototype.parent = function(v) {
            if (this._isCompound) {
                var parent = this._parent[v];
                if (parent !== GRAPH_NODE) {
                    return parent;
                }
            }
        };

        Graph.prototype.children = function(v) {
            if (_.isUndefined(v)) {
                v = GRAPH_NODE;
            }

            if (this._isCompound) {
                var children = this._children[v];
                if (children) {
                    return _.keys(children);
                }
            } else if (v === GRAPH_NODE) {
                return this.nodes();
            } else if (this.hasNode(v)) {
                return [];
            }
        };

        Graph.prototype.predecessors = function(v) {
            var predsV = this._preds[v];
            if (predsV) {
                return _.keys(predsV);
            }
        };

        Graph.prototype.successors = function(v) {
            var sucsV = this._sucs[v];
            if (sucsV) {
                return _.keys(sucsV);
            }
        };

        Graph.prototype.neighbors = function(v) {
            var preds = this.predecessors(v);
            if (preds) {
                return _.union(preds, this.successors(v));
            }
        };

        Graph.prototype.filterNodes = function(filter) {
            var copy = new this.constructor({
                directed: this._isDirected,
                multigraph: this._isMultigraph,
                compound: this._isCompound
            });

            copy.setGraph(this.graph());

            _.each(this._nodes, function(value, v) {
                if (filter(v)) {
                    copy.setNode(v, value);
                }
            }, this);

            _.each(this._edgeObjs, function(e) {
                if (copy.hasNode(e.v) && copy.hasNode(e.w)) {
                    copy.setEdge(e, this.edge(e));
                }
            }, this);

            var self = this;
            var parents = {};

            function findParent(v) {
                var parent = self.parent(v);
                if (parent === undefined || copy.hasNode(parent)) {
                    parents[v] = parent;
                    return parent;
                } else if (parent in parents) {
                    return parents[parent];
                } else {
                    return findParent(parent);
                }
            }

            if (this._isCompound) {
                _.each(copy.nodes(), function(v) {
                    copy.setParent(v, findParent(v));
                });
            }

            return copy;
        };

        /* === Edge functions ========== */

        Graph.prototype.setDefaultEdgeLabel = function(newDefault) {
            if (!_.isFunction(newDefault)) {
                newDefault = _.constant(newDefault);
            }
            this._defaultEdgeLabelFn = newDefault;
            return this;
        };

        Graph.prototype.edgeCount = function() {
            return this._edgeCount;
        };

        Graph.prototype.edges = function() {
            return _.values(this._edgeObjs);
        };

        Graph.prototype.setPath = function(vs, value) {
            var self = this,
                args = arguments;
            _.reduce(vs, function(v, w) {
                if (args.length > 1) {
                    self.setEdge(v, w, value);
                } else {
                    self.setEdge(v, w);
                }
                return w;
            });
            return this;
        };

        /*
         * setEdge(v, w, [value, [name]])
         * setEdge({ v, w, [name] }, [value])
         */
        Graph.prototype.setEdge = function() {
            var v, w, name, value,
                valueSpecified = false,
                arg0 = arguments[0];

            if (typeof arg0 === "object" && arg0 !== null && "v" in arg0) {
                v = arg0.v;
                w = arg0.w;
                name = arg0.name;
                if (arguments.length === 2) {
                    value = arguments[1];
                    valueSpecified = true;
                }
            } else {
                v = arg0;
                w = arguments[1];
                name = arguments[3];
                if (arguments.length > 2) {
                    value = arguments[2];
                    valueSpecified = true;
                }
            }

            v = "" + v;
            w = "" + w;
            if (!_.isUndefined(name)) {
                name = "" + name;
            }

            var e = edgeArgsToId(this._isDirected, v, w, name);
            if (_.has(this._edgeLabels, e)) {
                if (valueSpecified) {
                    this._edgeLabels[e] = value;
                }
                return this;
            }

            if (!_.isUndefined(name) && !this._isMultigraph) {
                throw new Error("Cannot set a named edge when isMultigraph = false");
            }

            // It didn't exist, so we need to create it.
            // First ensure the nodes exist.
            this.setNode(v);
            this.setNode(w);

            this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w, name);

            var edgeObj = edgeArgsToObj(this._isDirected, v, w, name);
            // Ensure we add undirected edges in a consistent way.
            v = edgeObj.v;
            w = edgeObj.w;

            Object.freeze(edgeObj);
            this._edgeObjs[e] = edgeObj;
            incrementOrInitEntry(this._preds[w], v);
            incrementOrInitEntry(this._sucs[v], w);
            this._in[w][e] = edgeObj;
            this._out[v][e] = edgeObj;
            this._edgeCount++;
            return this;
        };

        Graph.prototype.edge = function(v, w, name) {
            var e = (arguments.length === 1 ?
                edgeObjToId(this._isDirected, arguments[0]) :
                edgeArgsToId(this._isDirected, v, w, name));
            return this._edgeLabels[e];
        };

        Graph.prototype.hasEdge = function(v, w, name) {
            var e = (arguments.length === 1 ?
                edgeObjToId(this._isDirected, arguments[0]) :
                edgeArgsToId(this._isDirected, v, w, name));
            return _.has(this._edgeLabels, e);
        };

        Graph.prototype.removeEdge = function(v, w, name) {
            var e = (arguments.length === 1 ?
                    edgeObjToId(this._isDirected, arguments[0]) :
                    edgeArgsToId(this._isDirected, v, w, name)),
                edge = this._edgeObjs[e];
            if (edge) {
                v = edge.v;
                w = edge.w;
                delete this._edgeLabels[e];
                delete this._edgeObjs[e];
                decrementOrRemoveEntry(this._preds[w], v);
                decrementOrRemoveEntry(this._sucs[v], w);
                delete this._in[w][e];
                delete this._out[v][e];
                this._edgeCount--;
            }
            return this;
        };

        Graph.prototype.inEdges = function(v, u) {
            var inV = this._in[v];
            if (inV) {
                var edges = _.values(inV);
                if (!u) {
                    return edges;
                }
                return _.filter(edges, function(edge) {
                    return edge.v === u;
                });
            }
        };

        Graph.prototype.outEdges = function(v, w) {
            var outV = this._out[v];
            if (outV) {
                var edges = _.values(outV);
                if (!w) {
                    return edges;
                }
                return _.filter(edges, function(edge) {
                    return edge.w === w;
                });
            }
        };

        Graph.prototype.nodeEdges = function(v, w) {
            var inEdges = this.inEdges(v, w);
            if (inEdges) {
                return inEdges.concat(this.outEdges(v, w));
            }
        };

        function incrementOrInitEntry(map, k) {
            if (map[k]) {
                map[k]++;
            } else {
                map[k] = 1;
            }
        }

        function decrementOrRemoveEntry(map, k) {
            if (!--map[k]) {
                delete map[k];
            }
        }

        function edgeArgsToId(isDirected, v_, w_, name) {
            var v = "" + v_;
            var w = "" + w_;
            if (!isDirected && v > w) {
                var tmp = v;
                v = w;
                w = tmp;
            }
            return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM +
                (_.isUndefined(name) ? DEFAULT_EDGE_NAME : name);
        }

        function edgeArgsToObj(isDirected, v_, w_, name) {
            var v = "" + v_;
            var w = "" + w_;
            if (!isDirected && v > w) {
                var tmp = v;
                v = w;
                w = tmp;
            }
            var edgeObj = {
                v: v,
                w: w
            };
            if (name) {
                edgeObj.name = name;
            }
            return edgeObj;
        }

        function edgeObjToId(isDirected, edgeObj) {
            return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
        }

    }, {
        "./lodash": 49
    }],
    47: [function(require, module, exports) {
        // Includes only the "core" of graphlib
        module.exports = {
            Graph: require("./graph"),
            version: require("./version")
        };

    }, {
        "./graph": 46,
        "./version": 50
    }],
    48: [function(require, module, exports) {
        var _ = require("./lodash"),
            Graph = require("./graph");

        module.exports = {
            write: write,
            read: read
        };

        function write(g) {
            var json = {
                options: {
                    directed: g.isDirected(),
                    multigraph: g.isMultigraph(),
                    compound: g.isCompound()
                },
                nodes: writeNodes(g),
                edges: writeEdges(g)
            };
            if (!_.isUndefined(g.graph())) {
                json.value = _.clone(g.graph());
            }
            return json;
        }

        function writeNodes(g) {
            return _.map(g.nodes(), function(v) {
                var nodeValue = g.node(v),
                    parent = g.parent(v),
                    node = {
                        v: v
                    };
                if (!_.isUndefined(nodeValue)) {
                    node.value = nodeValue;
                }
                if (!_.isUndefined(parent)) {
                    node.parent = parent;
                }
                return node;
            });
        }

        function writeEdges(g) {
            return _.map(g.edges(), function(e) {
                var edgeValue = g.edge(e),
                    edge = {
                        v: e.v,
                        w: e.w
                    };
                if (!_.isUndefined(e.name)) {
                    edge.name = e.name;
                }
                if (!_.isUndefined(edgeValue)) {
                    edge.value = edgeValue;
                }
                return edge;
            });
        }

        function read(json) {
            var g = new Graph(json.options).setGraph(json.value);
            _.each(json.nodes, function(entry) {
                g.setNode(entry.v, entry.value);
                if (entry.parent) {
                    g.setParent(entry.v, entry.parent);
                }
            });
            _.each(json.edges, function(entry) {
                g.setEdge({
                    v: entry.v,
                    w: entry.w,
                    name: entry.name
                }, entry.value);
            });
            return g;
        }

    }, {
        "./graph": 46,
        "./lodash": 49
    }],
    49: [function(require, module, exports) {
        /* global window */

        var lodash;

        if (typeof require === "function") {
            try {
                lodash = require("lodash");
            } catch (e) {}
        }

        if (!lodash) {
            lodash = window._;
        }

        module.exports = lodash;

    }, {
        "lodash": 51
    }],
    50: [function(require, module, exports) {
        module.exports = '1.0.7';

    }, {}],
    51: [function(require, module, exports) {
        (function(global) {
            /**
             * @license
             * lodash 3.10.1 (Custom Build) <https://lodash.com/>
             * Build: `lodash modern -d -o ./index.js`
             * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
             * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
             * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
             * Available under MIT license <https://lodash.com/license>
             */
            ;
            (function() {

                /** Used as a safe reference for `undefined` in pre-ES5 environments. */
                var undefined;

                /** Used as the semantic version number. */
                var VERSION = '3.10.1';

                /** Used to compose bitmasks for wrapper metadata. */
                var BIND_FLAG = 1,
                    BIND_KEY_FLAG = 2,
                    CURRY_BOUND_FLAG = 4,
                    CURRY_FLAG = 8,
                    CURRY_RIGHT_FLAG = 16,
                    PARTIAL_FLAG = 32,
                    PARTIAL_RIGHT_FLAG = 64,
                    ARY_FLAG = 128,
                    REARG_FLAG = 256;

                /** Used as default options for `_.trunc`. */
                var DEFAULT_TRUNC_LENGTH = 30,
                    DEFAULT_TRUNC_OMISSION = '...';

                /** Used to detect when a function becomes hot. */
                var HOT_COUNT = 150,
                    HOT_SPAN = 16;

                /** Used as the size to enable large array optimizations. */
                var LARGE_ARRAY_SIZE = 200;

                /** Used to indicate the type of lazy iteratees. */
                var LAZY_FILTER_FLAG = 1,
                    LAZY_MAP_FLAG = 2;

                /** Used as the `TypeError` message for "Functions" methods. */
                var FUNC_ERROR_TEXT = 'Expected a function';

                /** Used as the internal argument placeholder. */
                var PLACEHOLDER = '__lodash_placeholder__';

                /** `Object#toString` result references. */
                var argsTag = '[object Arguments]',
                    arrayTag = '[object Array]',
                    boolTag = '[object Boolean]',
                    dateTag = '[object Date]',
                    errorTag = '[object Error]',
                    funcTag = '[object Function]',
                    mapTag = '[object Map]',
                    numberTag = '[object Number]',
                    objectTag = '[object Object]',
                    regexpTag = '[object RegExp]',
                    setTag = '[object Set]',
                    stringTag = '[object String]',
                    weakMapTag = '[object WeakMap]';

                var arrayBufferTag = '[object ArrayBuffer]',
                    float32Tag = '[object Float32Array]',
                    float64Tag = '[object Float64Array]',
                    int8Tag = '[object Int8Array]',
                    int16Tag = '[object Int16Array]',
                    int32Tag = '[object Int32Array]',
                    uint8Tag = '[object Uint8Array]',
                    uint8ClampedTag = '[object Uint8ClampedArray]',
                    uint16Tag = '[object Uint16Array]',
                    uint32Tag = '[object Uint32Array]';

                /** Used to match empty string literals in compiled template source. */
                var reEmptyStringLeading = /\b__p \+= '';/g,
                    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
                    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

                /** Used to match HTML entities and HTML characters. */
                var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
                    reUnescapedHtml = /[&<>"'`]/g,
                    reHasEscapedHtml = RegExp(reEscapedHtml.source),
                    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

                /** Used to match template delimiters. */
                var reEscape = /<%-([\s\S]+?)%>/g,
                    reEvaluate = /<%([\s\S]+?)%>/g,
                    reInterpolate = /<%=([\s\S]+?)%>/g;

                /** Used to match property names within property paths. */
                var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
                    reIsPlainProp = /^\w*$/,
                    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

                /**
                 * Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns)
                 * and those outlined by [`EscapeRegExpPattern`](http://ecma-international.org/ecma-262/6.0/#sec-escaperegexppattern).
                 */
                var reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,
                    reHasRegExpChars = RegExp(reRegExpChars.source);

                /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */
                var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;

                /** Used to match backslashes in property paths. */
                var reEscapeChar = /\\(\\)?/g;

                /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */
                var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

                /** Used to match `RegExp` flags from their coerced string values. */
                var reFlags = /\w*$/;

                /** Used to detect hexadecimal string values. */
                var reHasHexPrefix = /^0[xX]/;

                /** Used to detect host constructors (Safari > 5). */
                var reIsHostCtor = /^\[object .+?Constructor\]$/;

                /** Used to detect unsigned integer values. */
                var reIsUint = /^\d+$/;

                /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
                var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

                /** Used to ensure capturing order of template delimiters. */
                var reNoMatch = /($^)/;

                /** Used to match unescaped characters in compiled string literals. */
                var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

                /** Used to match words to create compound words. */
                var reWords = (function() {
                    var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
                        lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';

                    return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
                }());

                /** Used to assign default `context` object properties. */
                var contextProps = [
                    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
                    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
                    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite',
                    'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
                    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'
                ];

                /** Used to make template sourceURLs easier to identify. */
                var templateCounter = -1;

                /** Used to identify `toStringTag` values of typed arrays. */
                var typedArrayTags = {};
                typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
                    typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
                    typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
                    typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
                    typedArrayTags[uint32Tag] = true;
                typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
                    typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
                    typedArrayTags[dateTag] = typedArrayTags[errorTag] =
                    typedArrayTags[funcTag] = typedArrayTags[mapTag] =
                    typedArrayTags[numberTag] = typedArrayTags[objectTag] =
                    typedArrayTags[regexpTag] = typedArrayTags[setTag] =
                    typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

                /** Used to identify `toStringTag` values supported by `_.clone`. */
                var cloneableTags = {};
                cloneableTags[argsTag] = cloneableTags[arrayTag] =
                    cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
                    cloneableTags[dateTag] = cloneableTags[float32Tag] =
                    cloneableTags[float64Tag] = cloneableTags[int8Tag] =
                    cloneableTags[int16Tag] = cloneableTags[int32Tag] =
                    cloneableTags[numberTag] = cloneableTags[objectTag] =
                    cloneableTags[regexpTag] = cloneableTags[stringTag] =
                    cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
                    cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
                cloneableTags[errorTag] = cloneableTags[funcTag] =
                    cloneableTags[mapTag] = cloneableTags[setTag] =
                    cloneableTags[weakMapTag] = false;

                /** Used to map latin-1 supplementary letters to basic latin letters. */
                var deburredLetters = {
                    '\xc0': 'A',
                    '\xc1': 'A',
                    '\xc2': 'A',
                    '\xc3': 'A',
                    '\xc4': 'A',
                    '\xc5': 'A',
                    '\xe0': 'a',
                    '\xe1': 'a',
                    '\xe2': 'a',
                    '\xe3': 'a',
                    '\xe4': 'a',
                    '\xe5': 'a',
                    '\xc7': 'C',
                    '\xe7': 'c',
                    '\xd0': 'D',
                    '\xf0': 'd',
                    '\xc8': 'E',
                    '\xc9': 'E',
                    '\xca': 'E',
                    '\xcb': 'E',
                    '\xe8': 'e',
                    '\xe9': 'e',
                    '\xea': 'e',
                    '\xeb': 'e',
                    '\xcC': 'I',
                    '\xcd': 'I',
                    '\xce': 'I',
                    '\xcf': 'I',
                    '\xeC': 'i',
                    '\xed': 'i',
                    '\xee': 'i',
                    '\xef': 'i',
                    '\xd1': 'N',
                    '\xf1': 'n',
                    '\xd2': 'O',
                    '\xd3': 'O',
                    '\xd4': 'O',
                    '\xd5': 'O',
                    '\xd6': 'O',
                    '\xd8': 'O',
                    '\xf2': 'o',
                    '\xf3': 'o',
                    '\xf4': 'o',
                    '\xf5': 'o',
                    '\xf6': 'o',
                    '\xf8': 'o',
                    '\xd9': 'U',
                    '\xda': 'U',
                    '\xdb': 'U',
                    '\xdc': 'U',
                    '\xf9': 'u',
                    '\xfa': 'u',
                    '\xfb': 'u',
                    '\xfc': 'u',
                    '\xdd': 'Y',
                    '\xfd': 'y',
                    '\xff': 'y',
                    '\xc6': 'Ae',
                    '\xe6': 'ae',
                    '\xde': 'Th',
                    '\xfe': 'th',
                    '\xdf': 'ss'
                };

                /** Used to map characters to HTML entities. */
                var htmlEscapes = {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#39;',
                    '`': '&#96;'
                };

                /** Used to map HTML entities to characters. */
                var htmlUnescapes = {
                    '&amp;': '&',
                    '&lt;': '<',
                    '&gt;': '>',
                    '&quot;': '"',
                    '&#39;': "'",
                    '&#96;': '`'
                };

                /** Used to determine if values are of the language type `Object`. */
                var objectTypes = {
                    'function': true,
                    'object': true
                };

                /** Used to escape characters for inclusion in compiled regexes. */
                var regexpEscapes = {
                    '0': 'x30',
                    '1': 'x31',
                    '2': 'x32',
                    '3': 'x33',
                    '4': 'x34',
                    '5': 'x35',
                    '6': 'x36',
                    '7': 'x37',
                    '8': 'x38',
                    '9': 'x39',
                    'A': 'x41',
                    'B': 'x42',
                    'C': 'x43',
                    'D': 'x44',
                    'E': 'x45',
                    'F': 'x46',
                    'a': 'x61',
                    'b': 'x62',
                    'c': 'x63',
                    'd': 'x64',
                    'e': 'x65',
                    'f': 'x66',
                    'n': 'x6e',
                    'r': 'x72',
                    't': 'x74',
                    'u': 'x75',
                    'v': 'x76',
                    'x': 'x78'
                };

                /** Used to escape characters for inclusion in compiled string literals. */
                var stringEscapes = {
                    '\\': '\\',
                    "'": "'",
                    '\n': 'n',
                    '\r': 'r',
                    '\u2028': 'u2028',
                    '\u2029': 'u2029'
                };

                /** Detect free variable `exports`. */
                var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

                /** Detect free variable `module`. */
                var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

                /** Detect free variable `global` from Node.js. */
                var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;

                /** Detect free variable `self`. */
                var freeSelf = objectTypes[typeof self] && self && self.Object && self;

                /** Detect free variable `window`. */
                var freeWindow = objectTypes[typeof window] && window && window.Object && window;

                /** Detect the popular CommonJS extension `module.exports`. */
                var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

                /**
                 * Used as a reference to the global object.
                 *
                 * The `this` value is used if it's the global object to avoid Greasemonkey's
                 * restricted `window` object, otherwise the `window` object is used.
                 */
                var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;

                /*--------------------------------------------------------------------------*/

                /**
                 * The base implementation of `compareAscending` which compares values and
                 * sorts them in ascending order without guaranteeing a stable sort.
                 *
                 * @private
                 * @param {*} value The value to compare.
                 * @param {*} other The other value to compare.
                 * @returns {number} Returns the sort order indicator for `value`.
                 */
                function baseCompareAscending(value, other) {
                    if (value !== other) {
                        var valIsNull = value === null,
                            valIsUndef = value === undefined,
                            valIsReflexive = value === value;

                        var othIsNull = other === null,
                            othIsUndef = other === undefined,
                            othIsReflexive = other === other;

                        if ((value > other && !othIsNull) || !valIsReflexive ||
                            (valIsNull && !othIsUndef && othIsReflexive) ||
                            (valIsUndef && othIsReflexive)) {
                            return 1;
                        }
                        if ((value < other && !valIsNull) || !othIsReflexive ||
                            (othIsNull && !valIsUndef && valIsReflexive) ||
                            (othIsUndef && valIsReflexive)) {
                            return -1;
                        }
                    }
                    return 0;
                }

                /**
                 * The base implementation of `_.findIndex` and `_.findLastIndex` without
                 * support for callback shorthands and `this` binding.
                 *
                 * @private
                 * @param {Array} array The array to search.
                 * @param {Function} predicate The function invoked per iteration.
                 * @param {boolean} [fromRight] Specify iterating from right to left.
                 * @returns {number} Returns the index of the matched value, else `-1`.
                 */
                function baseFindIndex(array, predicate, fromRight) {
                    var length = array.length,
                        index = fromRight ? length : -1;

                    while ((fromRight ? index-- : ++index < length)) {
                        if (predicate(array[index], index, array)) {
                            return index;
                        }
                    }
                    return -1;
                }

                /**
                 * The base implementation of `_.indexOf` without support for binary searches.
                 *
                 * @private
                 * @param {Array} array The array to search.
                 * @param {*} value The value to search for.
                 * @param {number} fromIndex The index to search from.
                 * @returns {number} Returns the index of the matched value, else `-1`.
                 */
                function baseIndexOf(array, value, fromIndex) {
                    if (value !== value) {
                        return indexOfNaN(array, fromIndex);
                    }
                    var index = fromIndex - 1,
                        length = array.length;

                    while (++index < length) {
                        if (array[index] === value) {
                            return index;
                        }
                    }
                    return -1;
                }

                /**
                 * The base implementation of `_.isFunction` without support for environments
                 * with incorrect `typeof` results.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                 */
                function baseIsFunction(value) {
                    // Avoid a Chakra JIT bug in compatibility modes of IE 11.
                    // See https://github.com/jashkenas/underscore/issues/1621 for more details.
                    return typeof value == 'function' || false;
                }

                /**
                 * Converts `value` to a string if it's not one. An empty string is returned
                 * for `null` or `undefined` values.
                 *
                 * @private
                 * @param {*} value The value to process.
                 * @returns {string} Returns the string.
                 */
                function baseToString(value) {
                    return value == null ? '' : (value + '');
                }

                /**
                 * Used by `_.trim` and `_.trimLeft` to get the index of the first character
                 * of `string` that is not found in `chars`.
                 *
                 * @private
                 * @param {string} string The string to inspect.
                 * @param {string} chars The characters to find.
                 * @returns {number} Returns the index of the first character not found in `chars`.
                 */
                function charsLeftIndex(string, chars) {
                    var index = -1,
                        length = string.length;

                    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
                    return index;
                }

                /**
                 * Used by `_.trim` and `_.trimRight` to get the index of the last character
                 * of `string` that is not found in `chars`.
                 *
                 * @private
                 * @param {string} string The string to inspect.
                 * @param {string} chars The characters to find.
                 * @returns {number} Returns the index of the last character not found in `chars`.
                 */
                function charsRightIndex(string, chars) {
                    var index = string.length;

                    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
                    return index;
                }

                /**
                 * Used by `_.sortBy` to compare transformed elements of a collection and stable
                 * sort them in ascending order.
                 *
                 * @private
                 * @param {Object} object The object to compare.
                 * @param {Object} other The other object to compare.
                 * @returns {number} Returns the sort order indicator for `object`.
                 */
                function compareAscending(object, other) {
                    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
                }

                /**
                 * Used by `_.sortByOrder` to compare multiple properties of a value to another
                 * and stable sort them.
                 *
                 * If `orders` is unspecified, all valuess are sorted in ascending order. Otherwise,
                 * a value is sorted in ascending order if its corresponding order is "asc", and
                 * descending if "desc".
                 *
                 * @private
                 * @param {Object} object The object to compare.
                 * @param {Object} other The other object to compare.
                 * @param {boolean[]} orders The order to sort by for each property.
                 * @returns {number} Returns the sort order indicator for `object`.
                 */
                function compareMultiple(object, other, orders) {
                    var index = -1,
                        objCriteria = object.criteria,
                        othCriteria = other.criteria,
                        length = objCriteria.length,
                        ordersLength = orders.length;

                    while (++index < length) {
                        var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
                        if (result) {
                            if (index >= ordersLength) {
                                return result;
                            }
                            var order = orders[index];
                            return result * ((order === 'asc' || order === true) ? 1 : -1);
                        }
                    }
                    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
                    // that causes it, under certain circumstances, to provide the same value for
                    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
                    // for more details.
                    //
                    // This also ensures a stable sort in V8 and other engines.
                    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
                    return object.index - other.index;
                }

                /**
                 * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
                 *
                 * @private
                 * @param {string} letter The matched letter to deburr.
                 * @returns {string} Returns the deburred letter.
                 */
                function deburrLetter(letter) {
                    return deburredLetters[letter];
                }

                /**
                 * Used by `_.escape` to convert characters to HTML entities.
                 *
                 * @private
                 * @param {string} chr The matched character to escape.
                 * @returns {string} Returns the escaped character.
                 */
                function escapeHtmlChar(chr) {
                    return htmlEscapes[chr];
                }

                /**
                 * Used by `_.escapeRegExp` to escape characters for inclusion in compiled regexes.
                 *
                 * @private
                 * @param {string} chr The matched character to escape.
                 * @param {string} leadingChar The capture group for a leading character.
                 * @param {string} whitespaceChar The capture group for a whitespace character.
                 * @returns {string} Returns the escaped character.
                 */
                function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
                    if (leadingChar) {
                        chr = regexpEscapes[chr];
                    } else if (whitespaceChar) {
                        chr = stringEscapes[chr];
                    }
                    return '\\' + chr;
                }

                /**
                 * Used by `_.template` to escape characters for inclusion in compiled string literals.
                 *
                 * @private
                 * @param {string} chr The matched character to escape.
                 * @returns {string} Returns the escaped character.
                 */
                function escapeStringChar(chr) {
                    return '\\' + stringEscapes[chr];
                }

                /**
                 * Gets the index at which the first occurrence of `NaN` is found in `array`.
                 *
                 * @private
                 * @param {Array} array The array to search.
                 * @param {number} fromIndex The index to search from.
                 * @param {boolean} [fromRight] Specify iterating from right to left.
                 * @returns {number} Returns the index of the matched `NaN`, else `-1`.
                 */
                function indexOfNaN(array, fromIndex, fromRight) {
                    var length = array.length,
                        index = fromIndex + (fromRight ? 0 : -1);

                    while ((fromRight ? index-- : ++index < length)) {
                        var other = array[index];
                        if (other !== other) {
                            return index;
                        }
                    }
                    return -1;
                }

                /**
                 * Checks if `value` is object-like.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
                 */
                function isObjectLike(value) {
                    return !!value && typeof value == 'object';
                }

                /**
                 * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
                 * character code is whitespace.
                 *
                 * @private
                 * @param {number} charCode The character code to inspect.
                 * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
                 */
                function isSpace(charCode) {
                    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
                        (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
                }

                /**
                 * Replaces all `placeholder` elements in `array` with an internal placeholder
                 * and returns an array of their indexes.
                 *
                 * @private
                 * @param {Array} array The array to modify.
                 * @param {*} placeholder The placeholder to replace.
                 * @returns {Array} Returns the new array of placeholder indexes.
                 */
                function replaceHolders(array, placeholder) {
                    var index = -1,
                        length = array.length,
                        resIndex = -1,
                        result = [];

                    while (++index < length) {
                        if (array[index] === placeholder) {
                            array[index] = PLACEHOLDER;
                            result[++resIndex] = index;
                        }
                    }
                    return result;
                }

                /**
                 * An implementation of `_.uniq` optimized for sorted arrays without support
                 * for callback shorthands and `this` binding.
                 *
                 * @private
                 * @param {Array} array The array to inspect.
                 * @param {Function} [iteratee] The function invoked per iteration.
                 * @returns {Array} Returns the new duplicate-value-free array.
                 */
                function sortedUniq(array, iteratee) {
                    var seen,
                        index = -1,
                        length = array.length,
                        resIndex = -1,
                        result = [];

                    while (++index < length) {
                        var value = array[index],
                            computed = iteratee ? iteratee(value, index, array) : value;

                        if (!index || seen !== computed) {
                            seen = computed;
                            result[++resIndex] = value;
                        }
                    }
                    return result;
                }

                /**
                 * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
                 * character of `string`.
                 *
                 * @private
                 * @param {string} string The string to inspect.
                 * @returns {number} Returns the index of the first non-whitespace character.
                 */
                function trimmedLeftIndex(string) {
                    var index = -1,
                        length = string.length;

                    while (++index < length && isSpace(string.charCodeAt(index))) {}
                    return index;
                }

                /**
                 * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
                 * character of `string`.
                 *
                 * @private
                 * @param {string} string The string to inspect.
                 * @returns {number} Returns the index of the last non-whitespace character.
                 */
                function trimmedRightIndex(string) {
                    var index = string.length;

                    while (index-- && isSpace(string.charCodeAt(index))) {}
                    return index;
                }

                /**
                 * Used by `_.unescape` to convert HTML entities to characters.
                 *
                 * @private
                 * @param {string} chr The matched character to unescape.
                 * @returns {string} Returns the unescaped character.
                 */
                function unescapeHtmlChar(chr) {
                    return htmlUnescapes[chr];
                }

                /*--------------------------------------------------------------------------*/

                /**
                 * Create a new pristine `lodash` function using the given `context` object.
                 *
                 * @static
                 * @memberOf _
                 * @category Utility
                 * @param {Object} [context=root] The context object.
                 * @returns {Function} Returns a new `lodash` function.
                 * @example
                 *
                 * _.mixin({ 'foo': _.constant('foo') });
                 *
                 * var lodash = _.runInContext();
                 * lodash.mixin({ 'bar': lodash.constant('bar') });
                 *
                 * _.isFunction(_.foo);
                 * // => true
                 * _.isFunction(_.bar);
                 * // => false
                 *
                 * lodash.isFunction(lodash.foo);
                 * // => false
                 * lodash.isFunction(lodash.bar);
                 * // => true
                 *
                 * // using `context` to mock `Date#getTime` use in `_.now`
                 * var mock = _.runInContext({
                 *   'Date': function() {
                 *     return { 'getTime': getTimeMock };
                 *   }
                 * });
                 *
                 * // or creating a suped-up `defer` in Node.js
                 * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
                 */
                function runInContext(context) {
                    // Avoid issues with some ES3 environments that attempt to use values, named
                    // after built-in constructors like `Object`, for the creation of literals.
                    // ES5 clears this up by stating that literals must use built-in constructors.
                    // See https://es5.github.io/#x11.1.5 for more details.
                    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

                    /** Native constructor references. */
                    var Array = context.Array,
                        Date = context.Date,
                        Error = context.Error,
                        Function = context.Function,
                        Math = context.Math,
                        Number = context.Number,
                        Object = context.Object,
                        RegExp = context.RegExp,
                        String = context.String,
                        TypeError = context.TypeError;

                    /** Used for native method references. */
                    var arrayProto = Array.prototype,
                        objectProto = Object.prototype,
                        stringProto = String.prototype;

                    /** Used to resolve the decompiled source of functions. */
                    var fnToString = Function.prototype.toString;

                    /** Used to check objects for own properties. */
                    var hasOwnProperty = objectProto.hasOwnProperty;

                    /** Used to generate unique IDs. */
                    var idCounter = 0;

                    /**
                     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
                     * of values.
                     */
                    var objToString = objectProto.toString;

                    /** Used to restore the original `_` reference in `_.noConflict`. */
                    var oldDash = root._;

                    /** Used to detect if a method is native. */
                    var reIsNative = RegExp('^' +
                        fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
                        .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
                    );

                    /** Native method references. */
                    var ArrayBuffer = context.ArrayBuffer,
                        clearTimeout = context.clearTimeout,
                        parseFloat = context.parseFloat,
                        pow = Math.pow,
                        propertyIsEnumerable = objectProto.propertyIsEnumerable,
                        Set = getNative(context, 'Set'),
                        setTimeout = context.setTimeout,
                        splice = arrayProto.splice,
                        Uint8Array = context.Uint8Array,
                        WeakMap = getNative(context, 'WeakMap');

                    /* Native method references for those with the same name as other `lodash` methods. */
                    var nativeCeil = Math.ceil,
                        nativeCreate = getNative(Object, 'create'),
                        nativeFloor = Math.floor,
                        nativeIsArray = getNative(Array, 'isArray'),
                        nativeIsFinite = context.isFinite,
                        nativeKeys = getNative(Object, 'keys'),
                        nativeMax = Math.max,
                        nativeMin = Math.min,
                        nativeNow = getNative(Date, 'now'),
                        nativeParseInt = context.parseInt,
                        nativeRandom = Math.random;

                    /** Used as references for `-Infinity` and `Infinity`. */
                    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
                        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

                    /** Used as references for the maximum length and index of an array. */
                    var MAX_ARRAY_LENGTH = 4294967295,
                        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
                        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

                    /**
                     * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
                     * of an array-like value.
                     */
                    var MAX_SAFE_INTEGER = 9007199254740991;

                    /** Used to store function metadata. */
                    var metaMap = WeakMap && new WeakMap;

                    /** Used to lookup unminified function names. */
                    var realNames = {};

                    /*------------------------------------------------------------------------*/

                    /**
                     * Creates a `lodash` object which wraps `value` to enable implicit chaining.
                     * Methods that operate on and return arrays, collections, and functions can
                     * be chained together. Methods that retrieve a single value or may return a
                     * primitive value will automatically end the chain returning the unwrapped
                     * value. Explicit chaining may be enabled using `_.chain`. The execution of
                     * chained methods is lazy, that is, execution is deferred until `_#value`
                     * is implicitly or explicitly called.
                     *
                     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
                     * fusion is an optimization strategy which merge iteratee calls; this can help
                     * to avoid the creation of intermediate data structures and greatly reduce the
                     * number of iteratee executions.
                     *
                     * Chaining is supported in custom builds as long as the `_#value` method is
                     * directly or indirectly included in the build.
                     *
                     * In addition to lodash methods, wrappers have `Array` and `String` methods.
                     *
                     * The wrapper `Array` methods are:
                     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
                     * `splice`, and `unshift`
                     *
                     * The wrapper `String` methods are:
                     * `replace` and `split`
                     *
                     * The wrapper methods that support shortcut fusion are:
                     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
                     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
                     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
                     * and `where`
                     *
                     * The chainable wrapper methods are:
                     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
                     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
                     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,
                     * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,
                     * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,
                     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
                     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
                     * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,
                     * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,
                     * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
                     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
                     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,
                     * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,
                     * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,
                     * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,
                     * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,
                     * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`
                     *
                     * The wrapper methods that are **not** chainable by default are:
                     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,
                     * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,
                     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,
                     * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,
                     * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
                     * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,
                     * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,
                     * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,
                     * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,
                     * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,
                     * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,
                     * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,
                     * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,
                     * `unescape`, `uniqueId`, `value`, and `words`
                     *
                     * The wrapper method `sample` will return a wrapped value when `n` is provided,
                     * otherwise an unwrapped value is returned.
                     *
                     * @name _
                     * @constructor
                     * @category Chain
                     * @param {*} value The value to wrap in a `lodash` instance.
                     * @returns {Object} Returns the new `lodash` wrapper instance.
                     * @example
                     *
                     * var wrapped = _([1, 2, 3]);
                     *
                     * // returns an unwrapped value
                     * wrapped.reduce(function(total, n) {
                     *   return total + n;
                     * });
                     * // => 6
                     *
                     * // returns a wrapped value
                     * var squares = wrapped.map(function(n) {
                     *   return n * n;
                     * });
                     *
                     * _.isArray(squares);
                     * // => false
                     *
                     * _.isArray(squares.value());
                     * // => true
                     */
                    function lodash(value) {
                        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                            if (value instanceof LodashWrapper) {
                                return value;
                            }
                            if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
                                return wrapperClone(value);
                            }
                        }
                        return new LodashWrapper(value);
                    }

                    /**
                     * The function whose prototype all chaining wrappers inherit from.
                     *
                     * @private
                     */
                    function baseLodash() {
                        // No operation performed.
                    }

                    /**
                     * The base constructor for creating `lodash` wrapper objects.
                     *
                     * @private
                     * @param {*} value The value to wrap.
                     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
                     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
                     */
                    function LodashWrapper(value, chainAll, actions) {
                        this.__wrapped__ = value;
                        this.__actions__ = actions || [];
                        this.__chain__ = !!chainAll;
                    }

                    /**
                     * An object environment feature flags.
                     *
                     * @static
                     * @memberOf _
                     * @type Object
                     */
                    var support = lodash.support = {};

                    /**
                     * By default, the template delimiters used by lodash are like those in
                     * embedded Ruby (ERB). Change the following template settings to use
                     * alternative delimiters.
                     *
                     * @static
                     * @memberOf _
                     * @type Object
                     */
                    lodash.templateSettings = {

                        /**
                         * Used to detect `data` property values to be HTML-escaped.
                         *
                         * @memberOf _.templateSettings
                         * @type RegExp
                         */
                        'escape': reEscape,

                        /**
                         * Used to detect code to be evaluated.
                         *
                         * @memberOf _.templateSettings
                         * @type RegExp
                         */
                        'evaluate': reEvaluate,

                        /**
                         * Used to detect `data` property values to inject.
                         *
                         * @memberOf _.templateSettings
                         * @type RegExp
                         */
                        'interpolate': reInterpolate,

                        /**
                         * Used to reference the data object in the template text.
                         *
                         * @memberOf _.templateSettings
                         * @type string
                         */
                        'variable': '',

                        /**
                         * Used to import variables into the compiled template.
                         *
                         * @memberOf _.templateSettings
                         * @type Object
                         */
                        'imports': {

                            /**
                             * A reference to the `lodash` function.
                             *
                             * @memberOf _.templateSettings.imports
                             * @type Function
                             */
                            '_': lodash
                        }
                    };

                    /*------------------------------------------------------------------------*/

                    /**
                     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
                     *
                     * @private
                     * @param {*} value The value to wrap.
                     */
                    function LazyWrapper(value) {
                        this.__wrapped__ = value;
                        this.__actions__ = [];
                        this.__dir__ = 1;
                        this.__filtered__ = false;
                        this.__iteratees__ = [];
                        this.__takeCount__ = POSITIVE_INFINITY;
                        this.__views__ = [];
                    }

                    /**
                     * Creates a clone of the lazy wrapper object.
                     *
                     * @private
                     * @name clone
                     * @memberOf LazyWrapper
                     * @returns {Object} Returns the cloned `LazyWrapper` object.
                     */
                    function lazyClone() {
                        var result = new LazyWrapper(this.__wrapped__);
                        result.__actions__ = arrayCopy(this.__actions__);
                        result.__dir__ = this.__dir__;
                        result.__filtered__ = this.__filtered__;
                        result.__iteratees__ = arrayCopy(this.__iteratees__);
                        result.__takeCount__ = this.__takeCount__;
                        result.__views__ = arrayCopy(this.__views__);
                        return result;
                    }

                    /**
                     * Reverses the direction of lazy iteration.
                     *
                     * @private
                     * @name reverse
                     * @memberOf LazyWrapper
                     * @returns {Object} Returns the new reversed `LazyWrapper` object.
                     */
                    function lazyReverse() {
                        if (this.__filtered__) {
                            var result = new LazyWrapper(this);
                            result.__dir__ = -1;
                            result.__filtered__ = true;
                        } else {
                            result = this.clone();
                            result.__dir__ *= -1;
                        }
                        return result;
                    }

                    /**
                     * Extracts the unwrapped value from its lazy wrapper.
                     *
                     * @private
                     * @name value
                     * @memberOf LazyWrapper
                     * @returns {*} Returns the unwrapped value.
                     */
                    function lazyValue() {
                        var array = this.__wrapped__.value(),
                            dir = this.__dir__,
                            isArr = isArray(array),
                            isRight = dir < 0,
                            arrLength = isArr ? array.length : 0,
                            view = getView(0, arrLength, this.__views__),
                            start = view.start,
                            end = view.end,
                            length = end - start,
                            index = isRight ? end : (start - 1),
                            iteratees = this.__iteratees__,
                            iterLength = iteratees.length,
                            resIndex = 0,
                            takeCount = nativeMin(length, this.__takeCount__);

                        if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {
                            return baseWrapperValue((isRight && isArr) ? array.reverse() : array, this.__actions__);
                        }
                        var result = [];

                        outer:
                            while (length-- && resIndex < takeCount) {
                                index += dir;

                                var iterIndex = -1,
                                    value = array[index];

                                while (++iterIndex < iterLength) {
                                    var data = iteratees[iterIndex],
                                        iteratee = data.iteratee,
                                        type = data.type,
                                        computed = iteratee(value);

                                    if (type == LAZY_MAP_FLAG) {
                                        value = computed;
                                    } else if (!computed) {
                                        if (type == LAZY_FILTER_FLAG) {
                                            continue outer;
                                        } else {
                                            break outer;
                                        }
                                    }
                                }
                                result[resIndex++] = value;
                            }
                        return result;
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Creates a cache object to store key/value pairs.
                     *
                     * @private
                     * @static
                     * @name Cache
                     * @memberOf _.memoize
                     */
                    function MapCache() {
                        this.__data__ = {};
                    }

                    /**
                     * Removes `key` and its value from the cache.
                     *
                     * @private
                     * @name delete
                     * @memberOf _.memoize.Cache
                     * @param {string} key The key of the value to remove.
                     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
                     */
                    function mapDelete(key) {
                        return this.has(key) && delete this.__data__[key];
                    }

                    /**
                     * Gets the cached value for `key`.
                     *
                     * @private
                     * @name get
                     * @memberOf _.memoize.Cache
                     * @param {string} key The key of the value to get.
                     * @returns {*} Returns the cached value.
                     */
                    function mapGet(key) {
                        return key == '__proto__' ? undefined : this.__data__[key];
                    }

                    /**
                     * Checks if a cached value for `key` exists.
                     *
                     * @private
                     * @name has
                     * @memberOf _.memoize.Cache
                     * @param {string} key The key of the entry to check.
                     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                     */
                    function mapHas(key) {
                        return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
                    }

                    /**
                     * Sets `value` to `key` of the cache.
                     *
                     * @private
                     * @name set
                     * @memberOf _.memoize.Cache
                     * @param {string} key The key of the value to cache.
                     * @param {*} value The value to cache.
                     * @returns {Object} Returns the cache object.
                     */
                    function mapSet(key, value) {
                        if (key != '__proto__') {
                            this.__data__[key] = value;
                        }
                        return this;
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     *
                     * Creates a cache object to store unique values.
                     *
                     * @private
                     * @param {Array} [values] The values to cache.
                     */
                    function SetCache(values) {
                        var length = values ? values.length : 0;

                        this.data = {
                            'hash': nativeCreate(null),
                            'set': new Set
                        };
                        while (length--) {
                            this.push(values[length]);
                        }
                    }

                    /**
                     * Checks if `value` is in `cache` mimicking the return signature of
                     * `_.indexOf` by returning `0` if the value is found, else `-1`.
                     *
                     * @private
                     * @param {Object} cache The cache to search.
                     * @param {*} value The value to search for.
                     * @returns {number} Returns `0` if `value` is found, else `-1`.
                     */
                    function cacheIndexOf(cache, value) {
                        var data = cache.data,
                            result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

                        return result ? 0 : -1;
                    }

                    /**
                     * Adds `value` to the cache.
                     *
                     * @private
                     * @name push
                     * @memberOf SetCache
                     * @param {*} value The value to cache.
                     */
                    function cachePush(value) {
                        var data = this.data;
                        if (typeof value == 'string' || isObject(value)) {
                            data.set.add(value);
                        } else {
                            data.hash[value] = true;
                        }
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Creates a new array joining `array` with `other`.
                     *
                     * @private
                     * @param {Array} array The array to join.
                     * @param {Array} other The other array to join.
                     * @returns {Array} Returns the new concatenated array.
                     */
                    function arrayConcat(array, other) {
                        var index = -1,
                            length = array.length,
                            othIndex = -1,
                            othLength = other.length,
                            result = Array(length + othLength);

                        while (++index < length) {
                            result[index] = array[index];
                        }
                        while (++othIndex < othLength) {
                            result[index++] = other[othIndex];
                        }
                        return result;
                    }

                    /**
                     * Copies the values of `source` to `array`.
                     *
                     * @private
                     * @param {Array} source The array to copy values from.
                     * @param {Array} [array=[]] The array to copy values to.
                     * @returns {Array} Returns `array`.
                     */
                    function arrayCopy(source, array) {
                        var index = -1,
                            length = source.length;

                        array || (array = Array(length));
                        while (++index < length) {
                            array[index] = source[index];
                        }
                        return array;
                    }

                    /**
                     * A specialized version of `_.forEach` for arrays without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array} Returns `array`.
                     */
                    function arrayEach(array, iteratee) {
                        var index = -1,
                            length = array.length;

                        while (++index < length) {
                            if (iteratee(array[index], index, array) === false) {
                                break;
                            }
                        }
                        return array;
                    }

                    /**
                     * A specialized version of `_.forEachRight` for arrays without support for
                     * callback shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array} Returns `array`.
                     */
                    function arrayEachRight(array, iteratee) {
                        var length = array.length;

                        while (length--) {
                            if (iteratee(array[length], length, array) === false) {
                                break;
                            }
                        }
                        return array;
                    }

                    /**
                     * A specialized version of `_.every` for arrays without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} predicate The function invoked per iteration.
                     * @returns {boolean} Returns `true` if all elements pass the predicate check,
                     *  else `false`.
                     */
                    function arrayEvery(array, predicate) {
                        var index = -1,
                            length = array.length;

                        while (++index < length) {
                            if (!predicate(array[index], index, array)) {
                                return false;
                            }
                        }
                        return true;
                    }

                    /**
                     * A specialized version of `baseExtremum` for arrays which invokes `iteratee`
                     * with one argument: (value).
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {Function} comparator The function used to compare values.
                     * @param {*} exValue The initial extremum value.
                     * @returns {*} Returns the extremum value.
                     */
                    function arrayExtremum(array, iteratee, comparator, exValue) {
                        var index = -1,
                            length = array.length,
                            computed = exValue,
                            result = computed;

                        while (++index < length) {
                            var value = array[index],
                                current = +iteratee(value);

                            if (comparator(current, computed)) {
                                computed = current;
                                result = value;
                            }
                        }
                        return result;
                    }

                    /**
                     * A specialized version of `_.filter` for arrays without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} predicate The function invoked per iteration.
                     * @returns {Array} Returns the new filtered array.
                     */
                    function arrayFilter(array, predicate) {
                        var index = -1,
                            length = array.length,
                            resIndex = -1,
                            result = [];

                        while (++index < length) {
                            var value = array[index];
                            if (predicate(value, index, array)) {
                                result[++resIndex] = value;
                            }
                        }
                        return result;
                    }

                    /**
                     * A specialized version of `_.map` for arrays without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array} Returns the new mapped array.
                     */
                    function arrayMap(array, iteratee) {
                        var index = -1,
                            length = array.length,
                            result = Array(length);

                        while (++index < length) {
                            result[index] = iteratee(array[index], index, array);
                        }
                        return result;
                    }

                    /**
                     * Appends the elements of `values` to `array`.
                     *
                     * @private
                     * @param {Array} array The array to modify.
                     * @param {Array} values The values to append.
                     * @returns {Array} Returns `array`.
                     */
                    function arrayPush(array, values) {
                        var index = -1,
                            length = values.length,
                            offset = array.length;

                        while (++index < length) {
                            array[offset + index] = values[index];
                        }
                        return array;
                    }

                    /**
                     * A specialized version of `_.reduce` for arrays without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {*} [accumulator] The initial value.
                     * @param {boolean} [initFromArray] Specify using the first element of `array`
                     *  as the initial value.
                     * @returns {*} Returns the accumulated value.
                     */
                    function arrayReduce(array, iteratee, accumulator, initFromArray) {
                        var index = -1,
                            length = array.length;

                        if (initFromArray && length) {
                            accumulator = array[++index];
                        }
                        while (++index < length) {
                            accumulator = iteratee(accumulator, array[index], index, array);
                        }
                        return accumulator;
                    }

                    /**
                     * A specialized version of `_.reduceRight` for arrays without support for
                     * callback shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {*} [accumulator] The initial value.
                     * @param {boolean} [initFromArray] Specify using the last element of `array`
                     *  as the initial value.
                     * @returns {*} Returns the accumulated value.
                     */
                    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
                        var length = array.length;
                        if (initFromArray && length) {
                            accumulator = array[--length];
                        }
                        while (length--) {
                            accumulator = iteratee(accumulator, array[length], length, array);
                        }
                        return accumulator;
                    }

                    /**
                     * A specialized version of `_.some` for arrays without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} predicate The function invoked per iteration.
                     * @returns {boolean} Returns `true` if any element passes the predicate check,
                     *  else `false`.
                     */
                    function arraySome(array, predicate) {
                        var index = -1,
                            length = array.length;

                        while (++index < length) {
                            if (predicate(array[index], index, array)) {
                                return true;
                            }
                        }
                        return false;
                    }

                    /**
                     * A specialized version of `_.sum` for arrays without support for callback
                     * shorthands and `this` binding..
                     *
                     * @private
                     * @param {Array} array The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {number} Returns the sum.
                     */
                    function arraySum(array, iteratee) {
                        var length = array.length,
                            result = 0;

                        while (length--) {
                            result += +iteratee(array[length]) || 0;
                        }
                        return result;
                    }

                    /**
                     * Used by `_.defaults` to customize its `_.assign` use.
                     *
                     * @private
                     * @param {*} objectValue The destination object property value.
                     * @param {*} sourceValue The source object property value.
                     * @returns {*} Returns the value to assign to the destination object.
                     */
                    function assignDefaults(objectValue, sourceValue) {
                        return objectValue === undefined ? sourceValue : objectValue;
                    }

                    /**
                     * Used by `_.template` to customize its `_.assign` use.
                     *
                     * **Note:** This function is like `assignDefaults` except that it ignores
                     * inherited property values when checking if a property is `undefined`.
                     *
                     * @private
                     * @param {*} objectValue The destination object property value.
                     * @param {*} sourceValue The source object property value.
                     * @param {string} key The key associated with the object and source values.
                     * @param {Object} object The destination object.
                     * @returns {*} Returns the value to assign to the destination object.
                     */
                    function assignOwnDefaults(objectValue, sourceValue, key, object) {
                        return (objectValue === undefined || !hasOwnProperty.call(object, key)) ?
                            sourceValue :
                            objectValue;
                    }

                    /**
                     * A specialized version of `_.assign` for customizing assigned values without
                     * support for argument juggling, multiple sources, and `this` binding `customizer`
                     * functions.
                     *
                     * @private
                     * @param {Object} object The destination object.
                     * @param {Object} source The source object.
                     * @param {Function} customizer The function to customize assigned values.
                     * @returns {Object} Returns `object`.
                     */
                    function assignWith(object, source, customizer) {
                        var index = -1,
                            props = keys(source),
                            length = props.length;

                        while (++index < length) {
                            var key = props[index],
                                value = object[key],
                                result = customizer(value, source[key], key, object, source);

                            if ((result === result ? (result !== value) : (value === value)) ||
                                (value === undefined && !(key in object))) {
                                object[key] = result;
                            }
                        }
                        return object;
                    }

                    /**
                     * The base implementation of `_.assign` without support for argument juggling,
                     * multiple sources, and `customizer` functions.
                     *
                     * @private
                     * @param {Object} object The destination object.
                     * @param {Object} source The source object.
                     * @returns {Object} Returns `object`.
                     */
                    function baseAssign(object, source) {
                        return source == null ?
                            object :
                            baseCopy(source, keys(source), object);
                    }

                    /**
                     * The base implementation of `_.at` without support for string collections
                     * and individual key arguments.
                     *
                     * @private
                     * @param {Array|Object} collection The collection to iterate over.
                     * @param {number[]|string[]} props The property names or indexes of elements to pick.
                     * @returns {Array} Returns the new array of picked elements.
                     */
                    function baseAt(collection, props) {
                        var index = -1,
                            isNil = collection == null,
                            isArr = !isNil && isArrayLike(collection),
                            length = isArr ? collection.length : 0,
                            propsLength = props.length,
                            result = Array(propsLength);

                        while (++index < propsLength) {
                            var key = props[index];
                            if (isArr) {
                                result[index] = isIndex(key, length) ? collection[key] : undefined;
                            } else {
                                result[index] = isNil ? undefined : collection[key];
                            }
                        }
                        return result;
                    }

                    /**
                     * Copies properties of `source` to `object`.
                     *
                     * @private
                     * @param {Object} source The object to copy properties from.
                     * @param {Array} props The property names to copy.
                     * @param {Object} [object={}] The object to copy properties to.
                     * @returns {Object} Returns `object`.
                     */
                    function baseCopy(source, props, object) {
                        object || (object = {});

                        var index = -1,
                            length = props.length;

                        while (++index < length) {
                            var key = props[index];
                            object[key] = source[key];
                        }
                        return object;
                    }

                    /**
                     * The base implementation of `_.callback` which supports specifying the
                     * number of arguments to provide to `func`.
                     *
                     * @private
                     * @param {*} [func=_.identity] The value to convert to a callback.
                     * @param {*} [thisArg] The `this` binding of `func`.
                     * @param {number} [argCount] The number of arguments to provide to `func`.
                     * @returns {Function} Returns the callback.
                     */
                    function baseCallback(func, thisArg, argCount) {
                        var type = typeof func;
                        if (type == 'function') {
                            return thisArg === undefined ?
                                func :
                                bindCallback(func, thisArg, argCount);
                        }
                        if (func == null) {
                            return identity;
                        }
                        if (type == 'object') {
                            return baseMatches(func);
                        }
                        return thisArg === undefined ?
                            property(func) :
                            baseMatchesProperty(func, thisArg);
                    }

                    /**
                     * The base implementation of `_.clone` without support for argument juggling
                     * and `this` binding `customizer` functions.
                     *
                     * @private
                     * @param {*} value The value to clone.
                     * @param {boolean} [isDeep] Specify a deep clone.
                     * @param {Function} [customizer] The function to customize cloning values.
                     * @param {string} [key] The key of `value`.
                     * @param {Object} [object] The object `value` belongs to.
                     * @param {Array} [stackA=[]] Tracks traversed source objects.
                     * @param {Array} [stackB=[]] Associates clones with source counterparts.
                     * @returns {*} Returns the cloned value.
                     */
                    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
                        var result;
                        if (customizer) {
                            result = object ? customizer(value, key, object) : customizer(value);
                        }
                        if (result !== undefined) {
                            return result;
                        }
                        if (!isObject(value)) {
                            return value;
                        }
                        var isArr = isArray(value);
                        if (isArr) {
                            result = initCloneArray(value);
                            if (!isDeep) {
                                return arrayCopy(value, result);
                            }
                        } else {
                            var tag = objToString.call(value),
                                isFunc = tag == funcTag;

                            if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
                                result = initCloneObject(isFunc ? {} : value);
                                if (!isDeep) {
                                    return baseAssign(result, value);
                                }
                            } else {
                                return cloneableTags[tag] ?
                                    initCloneByTag(value, tag, isDeep) :
                                    (object ? value : {});
                            }
                        }
                        // Check for circular references and return its corresponding clone.
                        stackA || (stackA = []);
                        stackB || (stackB = []);

                        var length = stackA.length;
                        while (length--) {
                            if (stackA[length] == value) {
                                return stackB[length];
                            }
                        }
                        // Add the source value to the stack of traversed objects and associate it with its clone.
                        stackA.push(value);
                        stackB.push(result);

                        // Recursively populate clone (susceptible to call stack limits).
                        (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
                            result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
                        });
                        return result;
                    }

                    /**
                     * The base implementation of `_.create` without support for assigning
                     * properties to the created object.
                     *
                     * @private
                     * @param {Object} prototype The object to inherit from.
                     * @returns {Object} Returns the new object.
                     */
                    var baseCreate = (function() {
                        function object() {}
                        return function(prototype) {
                            if (isObject(prototype)) {
                                object.prototype = prototype;
                                var result = new object;
                                object.prototype = undefined;
                            }
                            return result || {};
                        };
                    }());

                    /**
                     * The base implementation of `_.delay` and `_.defer` which accepts an index
                     * of where to slice the arguments to provide to `func`.
                     *
                     * @private
                     * @param {Function} func The function to delay.
                     * @param {number} wait The number of milliseconds to delay invocation.
                     * @param {Object} args The arguments provide to `func`.
                     * @returns {number} Returns the timer id.
                     */
                    function baseDelay(func, wait, args) {
                        if (typeof func != 'function') {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        return setTimeout(function() {
                            func.apply(undefined, args);
                        }, wait);
                    }

                    /**
                     * The base implementation of `_.difference` which accepts a single array
                     * of values to exclude.
                     *
                     * @private
                     * @param {Array} array The array to inspect.
                     * @param {Array} values The values to exclude.
                     * @returns {Array} Returns the new array of filtered values.
                     */
                    function baseDifference(array, values) {
                        var length = array ? array.length : 0,
                            result = [];

                        if (!length) {
                            return result;
                        }
                        var index = -1,
                            indexOf = getIndexOf(),
                            isCommon = indexOf == baseIndexOf,
                            cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
                            valuesLength = values.length;

                        if (cache) {
                            indexOf = cacheIndexOf;
                            isCommon = false;
                            values = cache;
                        }
                        outer:
                            while (++index < length) {
                                var value = array[index];

                                if (isCommon && value === value) {
                                    var valuesIndex = valuesLength;
                                    while (valuesIndex--) {
                                        if (values[valuesIndex] === value) {
                                            continue outer;
                                        }
                                    }
                                    result.push(value);
                                } else if (indexOf(values, value, 0) < 0) {
                                    result.push(value);
                                }
                            }
                        return result;
                    }

                    /**
                     * The base implementation of `_.forEach` without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array|Object|string} Returns `collection`.
                     */
                    var baseEach = createBaseEach(baseForOwn);

                    /**
                     * The base implementation of `_.forEachRight` without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array|Object|string} Returns `collection`.
                     */
                    var baseEachRight = createBaseEach(baseForOwnRight, true);

                    /**
                     * The base implementation of `_.every` without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} predicate The function invoked per iteration.
                     * @returns {boolean} Returns `true` if all elements pass the predicate check,
                     *  else `false`
                     */
                    function baseEvery(collection, predicate) {
                        var result = true;
                        baseEach(collection, function(value, index, collection) {
                            result = !!predicate(value, index, collection);
                            return result;
                        });
                        return result;
                    }

                    /**
                     * Gets the extremum value of `collection` invoking `iteratee` for each value
                     * in `collection` to generate the criterion by which the value is ranked.
                     * The `iteratee` is invoked with three arguments: (value, index|key, collection).
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {Function} comparator The function used to compare values.
                     * @param {*} exValue The initial extremum value.
                     * @returns {*} Returns the extremum value.
                     */
                    function baseExtremum(collection, iteratee, comparator, exValue) {
                        var computed = exValue,
                            result = computed;

                        baseEach(collection, function(value, index, collection) {
                            var current = +iteratee(value, index, collection);
                            if (comparator(current, computed) || (current === exValue && current === result)) {
                                computed = current;
                                result = value;
                            }
                        });
                        return result;
                    }

                    /**
                     * The base implementation of `_.fill` without an iteratee call guard.
                     *
                     * @private
                     * @param {Array} array The array to fill.
                     * @param {*} value The value to fill `array` with.
                     * @param {number} [start=0] The start position.
                     * @param {number} [end=array.length] The end position.
                     * @returns {Array} Returns `array`.
                     */
                    function baseFill(array, value, start, end) {
                        var length = array.length;

                        start = start == null ? 0 : (+start || 0);
                        if (start < 0) {
                            start = -start > length ? 0 : (length + start);
                        }
                        end = (end === undefined || end > length) ? length : (+end || 0);
                        if (end < 0) {
                            end += length;
                        }
                        length = start > end ? 0 : (end >>> 0);
                        start >>>= 0;

                        while (start < length) {
                            array[start++] = value;
                        }
                        return array;
                    }

                    /**
                     * The base implementation of `_.filter` without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} predicate The function invoked per iteration.
                     * @returns {Array} Returns the new filtered array.
                     */
                    function baseFilter(collection, predicate) {
                        var result = [];
                        baseEach(collection, function(value, index, collection) {
                            if (predicate(value, index, collection)) {
                                result.push(value);
                            }
                        });
                        return result;
                    }

                    /**
                     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
                     * without support for callback shorthands and `this` binding, which iterates
                     * over `collection` using the provided `eachFunc`.
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to search.
                     * @param {Function} predicate The function invoked per iteration.
                     * @param {Function} eachFunc The function to iterate over `collection`.
                     * @param {boolean} [retKey] Specify returning the key of the found element
                     *  instead of the element itself.
                     * @returns {*} Returns the found element or its key, else `undefined`.
                     */
                    function baseFind(collection, predicate, eachFunc, retKey) {
                        var result;
                        eachFunc(collection, function(value, key, collection) {
                            if (predicate(value, key, collection)) {
                                result = retKey ? key : value;
                                return false;
                            }
                        });
                        return result;
                    }

                    /**
                     * The base implementation of `_.flatten` with added support for restricting
                     * flattening and specifying the start index.
                     *
                     * @private
                     * @param {Array} array The array to flatten.
                     * @param {boolean} [isDeep] Specify a deep flatten.
                     * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
                     * @param {Array} [result=[]] The initial result value.
                     * @returns {Array} Returns the new flattened array.
                     */
                    function baseFlatten(array, isDeep, isStrict, result) {
                        result || (result = []);

                        var index = -1,
                            length = array.length;

                        while (++index < length) {
                            var value = array[index];
                            if (isObjectLike(value) && isArrayLike(value) &&
                                (isStrict || isArray(value) || isArguments(value))) {
                                if (isDeep) {
                                    // Recursively flatten arrays (susceptible to call stack limits).
                                    baseFlatten(value, isDeep, isStrict, result);
                                } else {
                                    arrayPush(result, value);
                                }
                            } else if (!isStrict) {
                                result[result.length] = value;
                            }
                        }
                        return result;
                    }

                    /**
                     * The base implementation of `baseForIn` and `baseForOwn` which iterates
                     * over `object` properties returned by `keysFunc` invoking `iteratee` for
                     * each property. Iteratee functions may exit iteration early by explicitly
                     * returning `false`.
                     *
                     * @private
                     * @param {Object} object The object to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {Function} keysFunc The function to get the keys of `object`.
                     * @returns {Object} Returns `object`.
                     */
                    var baseFor = createBaseFor();

                    /**
                     * This function is like `baseFor` except that it iterates over properties
                     * in the opposite order.
                     *
                     * @private
                     * @param {Object} object The object to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {Function} keysFunc The function to get the keys of `object`.
                     * @returns {Object} Returns `object`.
                     */
                    var baseForRight = createBaseFor(true);

                    /**
                     * The base implementation of `_.forIn` without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Object} object The object to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Object} Returns `object`.
                     */
                    function baseForIn(object, iteratee) {
                        return baseFor(object, iteratee, keysIn);
                    }

                    /**
                     * The base implementation of `_.forOwn` without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Object} object The object to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Object} Returns `object`.
                     */
                    function baseForOwn(object, iteratee) {
                        return baseFor(object, iteratee, keys);
                    }

                    /**
                     * The base implementation of `_.forOwnRight` without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Object} object The object to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Object} Returns `object`.
                     */
                    function baseForOwnRight(object, iteratee) {
                        return baseForRight(object, iteratee, keys);
                    }

                    /**
                     * The base implementation of `_.functions` which creates an array of
                     * `object` function property names filtered from those provided.
                     *
                     * @private
                     * @param {Object} object The object to inspect.
                     * @param {Array} props The property names to filter.
                     * @returns {Array} Returns the new array of filtered property names.
                     */
                    function baseFunctions(object, props) {
                        var index = -1,
                            length = props.length,
                            resIndex = -1,
                            result = [];

                        while (++index < length) {
                            var key = props[index];
                            if (isFunction(object[key])) {
                                result[++resIndex] = key;
                            }
                        }
                        return result;
                    }

                    /**
                     * The base implementation of `get` without support for string paths
                     * and default values.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @param {Array} path The path of the property to get.
                     * @param {string} [pathKey] The key representation of path.
                     * @returns {*} Returns the resolved value.
                     */
                    function baseGet(object, path, pathKey) {
                        if (object == null) {
                            return;
                        }
                        if (pathKey !== undefined && pathKey in toObject(object)) {
                            path = [pathKey];
                        }
                        var index = 0,
                            length = path.length;

                        while (object != null && index < length) {
                            object = object[path[index++]];
                        }
                        return (index && index == length) ? object : undefined;
                    }

                    /**
                     * The base implementation of `_.isEqual` without support for `this` binding
                     * `customizer` functions.
                     *
                     * @private
                     * @param {*} value The value to compare.
                     * @param {*} other The other value to compare.
                     * @param {Function} [customizer] The function to customize comparing values.
                     * @param {boolean} [isLoose] Specify performing partial comparisons.
                     * @param {Array} [stackA] Tracks traversed `value` objects.
                     * @param {Array} [stackB] Tracks traversed `other` objects.
                     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                     */
                    function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
                        if (value === other) {
                            return true;
                        }
                        if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
                            return value !== value && other !== other;
                        }
                        return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
                    }

                    /**
                     * A specialized version of `baseIsEqual` for arrays and objects which performs
                     * deep comparisons and tracks traversed objects enabling objects with circular
                     * references to be compared.
                     *
                     * @private
                     * @param {Object} object The object to compare.
                     * @param {Object} other The other object to compare.
                     * @param {Function} equalFunc The function to determine equivalents of values.
                     * @param {Function} [customizer] The function to customize comparing objects.
                     * @param {boolean} [isLoose] Specify performing partial comparisons.
                     * @param {Array} [stackA=[]] Tracks traversed `value` objects.
                     * @param {Array} [stackB=[]] Tracks traversed `other` objects.
                     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                     */
                    function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
                        var objIsArr = isArray(object),
                            othIsArr = isArray(other),
                            objTag = arrayTag,
                            othTag = arrayTag;

                        if (!objIsArr) {
                            objTag = objToString.call(object);
                            if (objTag == argsTag) {
                                objTag = objectTag;
                            } else if (objTag != objectTag) {
                                objIsArr = isTypedArray(object);
                            }
                        }
                        if (!othIsArr) {
                            othTag = objToString.call(other);
                            if (othTag == argsTag) {
                                othTag = objectTag;
                            } else if (othTag != objectTag) {
                                othIsArr = isTypedArray(other);
                            }
                        }
                        var objIsObj = objTag == objectTag,
                            othIsObj = othTag == objectTag,
                            isSameTag = objTag == othTag;

                        if (isSameTag && !(objIsArr || objIsObj)) {
                            return equalByTag(object, other, objTag);
                        }
                        if (!isLoose) {
                            var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                                othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

                            if (objIsWrapped || othIsWrapped) {
                                return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
                            }
                        }
                        if (!isSameTag) {
                            return false;
                        }
                        // Assume cyclic values are equal.
                        // For more information on detecting circular references see https://es5.github.io/#JO.
                        stackA || (stackA = []);
                        stackB || (stackB = []);

                        var length = stackA.length;
                        while (length--) {
                            if (stackA[length] == object) {
                                return stackB[length] == other;
                            }
                        }
                        // Add `object` and `other` to the stack of traversed objects.
                        stackA.push(object);
                        stackB.push(other);

                        var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

                        stackA.pop();
                        stackB.pop();

                        return result;
                    }

                    /**
                     * The base implementation of `_.isMatch` without support for callback
                     * shorthands and `this` binding.
                     *
                     * @private
                     * @param {Object} object The object to inspect.
                     * @param {Array} matchData The propery names, values, and compare flags to match.
                     * @param {Function} [customizer] The function to customize comparing objects.
                     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
                     */
                    function baseIsMatch(object, matchData, customizer) {
                        var index = matchData.length,
                            length = index,
                            noCustomizer = !customizer;

                        if (object == null) {
                            return !length;
                        }
                        object = toObject(object);
                        while (index--) {
                            var data = matchData[index];
                            if ((noCustomizer && data[2]) ?
                                data[1] !== object[data[0]] :
                                !(data[0] in object)
                            ) {
                                return false;
                            }
                        }
                        while (++index < length) {
                            data = matchData[index];
                            var key = data[0],
                                objValue = object[key],
                                srcValue = data[1];

                            if (noCustomizer && data[2]) {
                                if (objValue === undefined && !(key in object)) {
                                    return false;
                                }
                            } else {
                                var result = customizer ? customizer(objValue, srcValue, key) : undefined;
                                if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }

                    /**
                     * The base implementation of `_.map` without support for callback shorthands
                     * and `this` binding.
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array} Returns the new mapped array.
                     */
                    function baseMap(collection, iteratee) {
                        var index = -1,
                            result = isArrayLike(collection) ? Array(collection.length) : [];

                        baseEach(collection, function(value, key, collection) {
                            result[++index] = iteratee(value, key, collection);
                        });
                        return result;
                    }

                    /**
                     * The base implementation of `_.matches` which does not clone `source`.
                     *
                     * @private
                     * @param {Object} source The object of property values to match.
                     * @returns {Function} Returns the new function.
                     */
                    function baseMatches(source) {
                        var matchData = getMatchData(source);
                        if (matchData.length == 1 && matchData[0][2]) {
                            var key = matchData[0][0],
                                value = matchData[0][1];

                            return function(object) {
                                if (object == null) {
                                    return false;
                                }
                                return object[key] === value && (value !== undefined || (key in toObject(object)));
                            };
                        }
                        return function(object) {
                            return baseIsMatch(object, matchData);
                        };
                    }

                    /**
                     * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
                     *
                     * @private
                     * @param {string} path The path of the property to get.
                     * @param {*} srcValue The value to compare.
                     * @returns {Function} Returns the new function.
                     */
                    function baseMatchesProperty(path, srcValue) {
                        var isArr = isArray(path),
                            isCommon = isKey(path) && isStrictComparable(srcValue),
                            pathKey = (path + '');

                        path = toPath(path);
                        return function(object) {
                            if (object == null) {
                                return false;
                            }
                            var key = pathKey;
                            object = toObject(object);
                            if ((isArr || !isCommon) && !(key in object)) {
                                object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                                if (object == null) {
                                    return false;
                                }
                                key = last(path);
                                object = toObject(object);
                            }
                            return object[key] === srcValue ?
                                (srcValue !== undefined || (key in object)) :
                                baseIsEqual(srcValue, object[key], undefined, true);
                        };
                    }

                    /**
                     * The base implementation of `_.merge` without support for argument juggling,
                     * multiple sources, and `this` binding `customizer` functions.
                     *
                     * @private
                     * @param {Object} object The destination object.
                     * @param {Object} source The source object.
                     * @param {Function} [customizer] The function to customize merged values.
                     * @param {Array} [stackA=[]] Tracks traversed source objects.
                     * @param {Array} [stackB=[]] Associates values with source counterparts.
                     * @returns {Object} Returns `object`.
                     */
                    function baseMerge(object, source, customizer, stackA, stackB) {
                        if (!isObject(object)) {
                            return object;
                        }
                        var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
                            props = isSrcArr ? undefined : keys(source);

                        arrayEach(props || source, function(srcValue, key) {
                            if (props) {
                                key = srcValue;
                                srcValue = source[key];
                            }
                            if (isObjectLike(srcValue)) {
                                stackA || (stackA = []);
                                stackB || (stackB = []);
                                baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
                            } else {
                                var value = object[key],
                                    result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
                                    isCommon = result === undefined;

                                if (isCommon) {
                                    result = srcValue;
                                }
                                if ((result !== undefined || (isSrcArr && !(key in object))) &&
                                    (isCommon || (result === result ? (result !== value) : (value === value)))) {
                                    object[key] = result;
                                }
                            }
                        });
                        return object;
                    }

                    /**
                     * A specialized version of `baseMerge` for arrays and objects which performs
                     * deep merges and tracks traversed objects enabling objects with circular
                     * references to be merged.
                     *
                     * @private
                     * @param {Object} object The destination object.
                     * @param {Object} source The source object.
                     * @param {string} key The key of the value to merge.
                     * @param {Function} mergeFunc The function to merge values.
                     * @param {Function} [customizer] The function to customize merged values.
                     * @param {Array} [stackA=[]] Tracks traversed source objects.
                     * @param {Array} [stackB=[]] Associates values with source counterparts.
                     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                     */
                    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
                        var length = stackA.length,
                            srcValue = source[key];

                        while (length--) {
                            if (stackA[length] == srcValue) {
                                object[key] = stackB[length];
                                return;
                            }
                        }
                        var value = object[key],
                            result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
                            isCommon = result === undefined;

                        if (isCommon) {
                            result = srcValue;
                            if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
                                result = isArray(value) ?
                                    value :
                                    (isArrayLike(value) ? arrayCopy(value) : []);
                            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                                result = isArguments(value) ?
                                    toPlainObject(value) :
                                    (isPlainObject(value) ? value : {});
                            } else {
                                isCommon = false;
                            }
                        }
                        // Add the source value to the stack of traversed objects and associate
                        // it with its merged value.
                        stackA.push(srcValue);
                        stackB.push(result);

                        if (isCommon) {
                            // Recursively merge objects and arrays (susceptible to call stack limits).
                            object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
                        } else if (result === result ? (result !== value) : (value === value)) {
                            object[key] = result;
                        }
                    }

                    /**
                     * The base implementation of `_.property` without support for deep paths.
                     *
                     * @private
                     * @param {string} key The key of the property to get.
                     * @returns {Function} Returns the new function.
                     */
                    function baseProperty(key) {
                        return function(object) {
                            return object == null ? undefined : object[key];
                        };
                    }

                    /**
                     * A specialized version of `baseProperty` which supports deep paths.
                     *
                     * @private
                     * @param {Array|string} path The path of the property to get.
                     * @returns {Function} Returns the new function.
                     */
                    function basePropertyDeep(path) {
                        var pathKey = (path + '');
                        path = toPath(path);
                        return function(object) {
                            return baseGet(object, path, pathKey);
                        };
                    }

                    /**
                     * The base implementation of `_.pullAt` without support for individual
                     * index arguments and capturing the removed elements.
                     *
                     * @private
                     * @param {Array} array The array to modify.
                     * @param {number[]} indexes The indexes of elements to remove.
                     * @returns {Array} Returns `array`.
                     */
                    function basePullAt(array, indexes) {
                        var length = array ? indexes.length : 0;
                        while (length--) {
                            var index = indexes[length];
                            if (index != previous && isIndex(index)) {
                                var previous = index;
                                splice.call(array, index, 1);
                            }
                        }
                        return array;
                    }

                    /**
                     * The base implementation of `_.random` without support for argument juggling
                     * and returning floating-point numbers.
                     *
                     * @private
                     * @param {number} min The minimum possible value.
                     * @param {number} max The maximum possible value.
                     * @returns {number} Returns the random number.
                     */
                    function baseRandom(min, max) {
                        return min + nativeFloor(nativeRandom() * (max - min + 1));
                    }

                    /**
                     * The base implementation of `_.reduce` and `_.reduceRight` without support
                     * for callback shorthands and `this` binding, which iterates over `collection`
                     * using the provided `eachFunc`.
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {*} accumulator The initial value.
                     * @param {boolean} initFromCollection Specify using the first or last element
                     *  of `collection` as the initial value.
                     * @param {Function} eachFunc The function to iterate over `collection`.
                     * @returns {*} Returns the accumulated value.
                     */
                    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
                        eachFunc(collection, function(value, index, collection) {
                            accumulator = initFromCollection ?
                                (initFromCollection = false, value) :
                                iteratee(accumulator, value, index, collection);
                        });
                        return accumulator;
                    }

                    /**
                     * The base implementation of `setData` without support for hot loop detection.
                     *
                     * @private
                     * @param {Function} func The function to associate metadata with.
                     * @param {*} data The metadata.
                     * @returns {Function} Returns `func`.
                     */
                    var baseSetData = !metaMap ? identity : function(func, data) {
                        metaMap.set(func, data);
                        return func;
                    };

                    /**
                     * The base implementation of `_.slice` without an iteratee call guard.
                     *
                     * @private
                     * @param {Array} array The array to slice.
                     * @param {number} [start=0] The start position.
                     * @param {number} [end=array.length] The end position.
                     * @returns {Array} Returns the slice of `array`.
                     */
                    function baseSlice(array, start, end) {
                        var index = -1,
                            length = array.length;

                        start = start == null ? 0 : (+start || 0);
                        if (start < 0) {
                            start = -start > length ? 0 : (length + start);
                        }
                        end = (end === undefined || end > length) ? length : (+end || 0);
                        if (end < 0) {
                            end += length;
                        }
                        length = start > end ? 0 : ((end - start) >>> 0);
                        start >>>= 0;

                        var result = Array(length);
                        while (++index < length) {
                            result[index] = array[index + start];
                        }
                        return result;
                    }

                    /**
                     * The base implementation of `_.some` without support for callback shorthands
                     * and `this` binding.
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} predicate The function invoked per iteration.
                     * @returns {boolean} Returns `true` if any element passes the predicate check,
                     *  else `false`.
                     */
                    function baseSome(collection, predicate) {
                        var result;

                        baseEach(collection, function(value, index, collection) {
                            result = predicate(value, index, collection);
                            return !result;
                        });
                        return !!result;
                    }

                    /**
                     * The base implementation of `_.sortBy` which uses `comparer` to define
                     * the sort order of `array` and replaces criteria objects with their
                     * corresponding values.
                     *
                     * @private
                     * @param {Array} array The array to sort.
                     * @param {Function} comparer The function to define sort order.
                     * @returns {Array} Returns `array`.
                     */
                    function baseSortBy(array, comparer) {
                        var length = array.length;

                        array.sort(comparer);
                        while (length--) {
                            array[length] = array[length].value;
                        }
                        return array;
                    }

                    /**
                     * The base implementation of `_.sortByOrder` without param guards.
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
                     * @param {boolean[]} orders The sort orders of `iteratees`.
                     * @returns {Array} Returns the new sorted array.
                     */
                    function baseSortByOrder(collection, iteratees, orders) {
                        var callback = getCallback(),
                            index = -1;

                        iteratees = arrayMap(iteratees, function(iteratee) {
                            return callback(iteratee);
                        });

                        var result = baseMap(collection, function(value) {
                            var criteria = arrayMap(iteratees, function(iteratee) {
                                return iteratee(value);
                            });
                            return {
                                'criteria': criteria,
                                'index': ++index,
                                'value': value
                            };
                        });

                        return baseSortBy(result, function(object, other) {
                            return compareMultiple(object, other, orders);
                        });
                    }

                    /**
                     * The base implementation of `_.sum` without support for callback shorthands
                     * and `this` binding.
                     *
                     * @private
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {number} Returns the sum.
                     */
                    function baseSum(collection, iteratee) {
                        var result = 0;
                        baseEach(collection, function(value, index, collection) {
                            result += +iteratee(value, index, collection) || 0;
                        });
                        return result;
                    }

                    /**
                     * The base implementation of `_.uniq` without support for callback shorthands
                     * and `this` binding.
                     *
                     * @private
                     * @param {Array} array The array to inspect.
                     * @param {Function} [iteratee] The function invoked per iteration.
                     * @returns {Array} Returns the new duplicate-value-free array.
                     */
                    function baseUniq(array, iteratee) {
                        var index = -1,
                            indexOf = getIndexOf(),
                            length = array.length,
                            isCommon = indexOf == baseIndexOf,
                            isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
                            seen = isLarge ? createCache() : null,
                            result = [];

                        if (seen) {
                            indexOf = cacheIndexOf;
                            isCommon = false;
                        } else {
                            isLarge = false;
                            seen = iteratee ? [] : result;
                        }
                        outer:
                            while (++index < length) {
                                var value = array[index],
                                    computed = iteratee ? iteratee(value, index, array) : value;

                                if (isCommon && value === value) {
                                    var seenIndex = seen.length;
                                    while (seenIndex--) {
                                        if (seen[seenIndex] === computed) {
                                            continue outer;
                                        }
                                    }
                                    if (iteratee) {
                                        seen.push(computed);
                                    }
                                    result.push(value);
                                } else if (indexOf(seen, computed, 0) < 0) {
                                    if (iteratee || isLarge) {
                                        seen.push(computed);
                                    }
                                    result.push(value);
                                }
                            }
                        return result;
                    }

                    /**
                     * The base implementation of `_.values` and `_.valuesIn` which creates an
                     * array of `object` property values corresponding to the property names
                     * of `props`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @param {Array} props The property names to get values for.
                     * @returns {Object} Returns the array of property values.
                     */
                    function baseValues(object, props) {
                        var index = -1,
                            length = props.length,
                            result = Array(length);

                        while (++index < length) {
                            result[index] = object[props[index]];
                        }
                        return result;
                    }

                    /**
                     * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,
                     * and `_.takeWhile` without support for callback shorthands and `this` binding.
                     *
                     * @private
                     * @param {Array} array The array to query.
                     * @param {Function} predicate The function invoked per iteration.
                     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
                     * @param {boolean} [fromRight] Specify iterating from right to left.
                     * @returns {Array} Returns the slice of `array`.
                     */
                    function baseWhile(array, predicate, isDrop, fromRight) {
                        var length = array.length,
                            index = fromRight ? length : -1;

                        while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
                        return isDrop ?
                            baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length)) :
                            baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
                    }

                    /**
                     * The base implementation of `wrapperValue` which returns the result of
                     * performing a sequence of actions on the unwrapped `value`, where each
                     * successive action is supplied the return value of the previous.
                     *
                     * @private
                     * @param {*} value The unwrapped value.
                     * @param {Array} actions Actions to peform to resolve the unwrapped value.
                     * @returns {*} Returns the resolved value.
                     */
                    function baseWrapperValue(value, actions) {
                        var result = value;
                        if (result instanceof LazyWrapper) {
                            result = result.value();
                        }
                        var index = -1,
                            length = actions.length;

                        while (++index < length) {
                            var action = actions[index];
                            result = action.func.apply(action.thisArg, arrayPush([result], action.args));
                        }
                        return result;
                    }

                    /**
                     * Performs a binary search of `array` to determine the index at which `value`
                     * should be inserted into `array` in order to maintain its sort order.
                     *
                     * @private
                     * @param {Array} array The sorted array to inspect.
                     * @param {*} value The value to evaluate.
                     * @param {boolean} [retHighest] Specify returning the highest qualified index.
                     * @returns {number} Returns the index at which `value` should be inserted
                     *  into `array`.
                     */
                    function binaryIndex(array, value, retHighest) {
                        var low = 0,
                            high = array ? array.length : low;

                        if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                            while (low < high) {
                                var mid = (low + high) >>> 1,
                                    computed = array[mid];

                                if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
                                    low = mid + 1;
                                } else {
                                    high = mid;
                                }
                            }
                            return high;
                        }
                        return binaryIndexBy(array, value, identity, retHighest);
                    }

                    /**
                     * This function is like `binaryIndex` except that it invokes `iteratee` for
                     * `value` and each element of `array` to compute their sort ranking. The
                     * iteratee is invoked with one argument; (value).
                     *
                     * @private
                     * @param {Array} array The sorted array to inspect.
                     * @param {*} value The value to evaluate.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @param {boolean} [retHighest] Specify returning the highest qualified index.
                     * @returns {number} Returns the index at which `value` should be inserted
                     *  into `array`.
                     */
                    function binaryIndexBy(array, value, iteratee, retHighest) {
                        value = iteratee(value);

                        var low = 0,
                            high = array ? array.length : 0,
                            valIsNaN = value !== value,
                            valIsNull = value === null,
                            valIsUndef = value === undefined;

                        while (low < high) {
                            var mid = nativeFloor((low + high) / 2),
                                computed = iteratee(array[mid]),
                                isDef = computed !== undefined,
                                isReflexive = computed === computed;

                            if (valIsNaN) {
                                var setLow = isReflexive || retHighest;
                            } else if (valIsNull) {
                                setLow = isReflexive && isDef && (retHighest || computed != null);
                            } else if (valIsUndef) {
                                setLow = isReflexive && (retHighest || isDef);
                            } else if (computed == null) {
                                setLow = false;
                            } else {
                                setLow = retHighest ? (computed <= value) : (computed < value);
                            }
                            if (setLow) {
                                low = mid + 1;
                            } else {
                                high = mid;
                            }
                        }
                        return nativeMin(high, MAX_ARRAY_INDEX);
                    }

                    /**
                     * A specialized version of `baseCallback` which only supports `this` binding
                     * and specifying the number of arguments to provide to `func`.
                     *
                     * @private
                     * @param {Function} func The function to bind.
                     * @param {*} thisArg The `this` binding of `func`.
                     * @param {number} [argCount] The number of arguments to provide to `func`.
                     * @returns {Function} Returns the callback.
                     */
                    function bindCallback(func, thisArg, argCount) {
                        if (typeof func != 'function') {
                            return identity;
                        }
                        if (thisArg === undefined) {
                            return func;
                        }
                        switch (argCount) {
                            case 1:
                                return function(value) {
                                    return func.call(thisArg, value);
                                };
                            case 3:
                                return function(value, index, collection) {
                                    return func.call(thisArg, value, index, collection);
                                };
                            case 4:
                                return function(accumulator, value, index, collection) {
                                    return func.call(thisArg, accumulator, value, index, collection);
                                };
                            case 5:
                                return function(value, other, key, object, source) {
                                    return func.call(thisArg, value, other, key, object, source);
                                };
                        }
                        return function() {
                            return func.apply(thisArg, arguments);
                        };
                    }

                    /**
                     * Creates a clone of the given array buffer.
                     *
                     * @private
                     * @param {ArrayBuffer} buffer The array buffer to clone.
                     * @returns {ArrayBuffer} Returns the cloned array buffer.
                     */
                    function bufferClone(buffer) {
                        var result = new ArrayBuffer(buffer.byteLength),
                            view = new Uint8Array(result);

                        view.set(new Uint8Array(buffer));
                        return result;
                    }

                    /**
                     * Creates an array that is the composition of partially applied arguments,
                     * placeholders, and provided arguments into a single array of arguments.
                     *
                     * @private
                     * @param {Array|Object} args The provided arguments.
                     * @param {Array} partials The arguments to prepend to those provided.
                     * @param {Array} holders The `partials` placeholder indexes.
                     * @returns {Array} Returns the new array of composed arguments.
                     */
                    function composeArgs(args, partials, holders) {
                        var holdersLength = holders.length,
                            argsIndex = -1,
                            argsLength = nativeMax(args.length - holdersLength, 0),
                            leftIndex = -1,
                            leftLength = partials.length,
                            result = Array(leftLength + argsLength);

                        while (++leftIndex < leftLength) {
                            result[leftIndex] = partials[leftIndex];
                        }
                        while (++argsIndex < holdersLength) {
                            result[holders[argsIndex]] = args[argsIndex];
                        }
                        while (argsLength--) {
                            result[leftIndex++] = args[argsIndex++];
                        }
                        return result;
                    }

                    /**
                     * This function is like `composeArgs` except that the arguments composition
                     * is tailored for `_.partialRight`.
                     *
                     * @private
                     * @param {Array|Object} args The provided arguments.
                     * @param {Array} partials The arguments to append to those provided.
                     * @param {Array} holders The `partials` placeholder indexes.
                     * @returns {Array} Returns the new array of composed arguments.
                     */
                    function composeArgsRight(args, partials, holders) {
                        var holdersIndex = -1,
                            holdersLength = holders.length,
                            argsIndex = -1,
                            argsLength = nativeMax(args.length - holdersLength, 0),
                            rightIndex = -1,
                            rightLength = partials.length,
                            result = Array(argsLength + rightLength);

                        while (++argsIndex < argsLength) {
                            result[argsIndex] = args[argsIndex];
                        }
                        var offset = argsIndex;
                        while (++rightIndex < rightLength) {
                            result[offset + rightIndex] = partials[rightIndex];
                        }
                        while (++holdersIndex < holdersLength) {
                            result[offset + holders[holdersIndex]] = args[argsIndex++];
                        }
                        return result;
                    }

                    /**
                     * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.
                     *
                     * @private
                     * @param {Function} setter The function to set keys and values of the accumulator object.
                     * @param {Function} [initializer] The function to initialize the accumulator object.
                     * @returns {Function} Returns the new aggregator function.
                     */
                    function createAggregator(setter, initializer) {
                        return function(collection, iteratee, thisArg) {
                            var result = initializer ? initializer() : {};
                            iteratee = getCallback(iteratee, thisArg, 3);

                            if (isArray(collection)) {
                                var index = -1,
                                    length = collection.length;

                                while (++index < length) {
                                    var value = collection[index];
                                    setter(result, value, iteratee(value, index, collection), collection);
                                }
                            } else {
                                baseEach(collection, function(value, key, collection) {
                                    setter(result, value, iteratee(value, key, collection), collection);
                                });
                            }
                            return result;
                        };
                    }

                    /**
                     * Creates a `_.assign`, `_.defaults`, or `_.merge` function.
                     *
                     * @private
                     * @param {Function} assigner The function to assign values.
                     * @returns {Function} Returns the new assigner function.
                     */
                    function createAssigner(assigner) {
                        return restParam(function(object, sources) {
                            var index = -1,
                                length = object == null ? 0 : sources.length,
                                customizer = length > 2 ? sources[length - 2] : undefined,
                                guard = length > 2 ? sources[2] : undefined,
                                thisArg = length > 1 ? sources[length - 1] : undefined;

                            if (typeof customizer == 'function') {
                                customizer = bindCallback(customizer, thisArg, 5);
                                length -= 2;
                            } else {
                                customizer = typeof thisArg == 'function' ? thisArg : undefined;
                                length -= (customizer ? 1 : 0);
                            }
                            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                                customizer = length < 3 ? undefined : customizer;
                                length = 1;
                            }
                            while (++index < length) {
                                var source = sources[index];
                                if (source) {
                                    assigner(object, source, customizer);
                                }
                            }
                            return object;
                        });
                    }

                    /**
                     * Creates a `baseEach` or `baseEachRight` function.
                     *
                     * @private
                     * @param {Function} eachFunc The function to iterate over a collection.
                     * @param {boolean} [fromRight] Specify iterating from right to left.
                     * @returns {Function} Returns the new base function.
                     */
                    function createBaseEach(eachFunc, fromRight) {
                        return function(collection, iteratee) {
                            var length = collection ? getLength(collection) : 0;
                            if (!isLength(length)) {
                                return eachFunc(collection, iteratee);
                            }
                            var index = fromRight ? length : -1,
                                iterable = toObject(collection);

                            while ((fromRight ? index-- : ++index < length)) {
                                if (iteratee(iterable[index], index, iterable) === false) {
                                    break;
                                }
                            }
                            return collection;
                        };
                    }

                    /**
                     * Creates a base function for `_.forIn` or `_.forInRight`.
                     *
                     * @private
                     * @param {boolean} [fromRight] Specify iterating from right to left.
                     * @returns {Function} Returns the new base function.
                     */
                    function createBaseFor(fromRight) {
                        return function(object, iteratee, keysFunc) {
                            var iterable = toObject(object),
                                props = keysFunc(object),
                                length = props.length,
                                index = fromRight ? length : -1;

                            while ((fromRight ? index-- : ++index < length)) {
                                var key = props[index];
                                if (iteratee(iterable[key], key, iterable) === false) {
                                    break;
                                }
                            }
                            return object;
                        };
                    }

                    /**
                     * Creates a function that wraps `func` and invokes it with the `this`
                     * binding of `thisArg`.
                     *
                     * @private
                     * @param {Function} func The function to bind.
                     * @param {*} [thisArg] The `this` binding of `func`.
                     * @returns {Function} Returns the new bound function.
                     */
                    function createBindWrapper(func, thisArg) {
                        var Ctor = createCtorWrapper(func);

                        function wrapper() {
                            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
                            return fn.apply(thisArg, arguments);
                        }
                        return wrapper;
                    }

                    /**
                     * Creates a `Set` cache object to optimize linear searches of large arrays.
                     *
                     * @private
                     * @param {Array} [values] The values to cache.
                     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
                     */
                    function createCache(values) {
                        return (nativeCreate && Set) ? new SetCache(values) : null;
                    }

                    /**
                     * Creates a function that produces compound words out of the words in a
                     * given string.
                     *
                     * @private
                     * @param {Function} callback The function to combine each word.
                     * @returns {Function} Returns the new compounder function.
                     */
                    function createCompounder(callback) {
                        return function(string) {
                            var index = -1,
                                array = words(deburr(string)),
                                length = array.length,
                                result = '';

                            while (++index < length) {
                                result = callback(result, array[index], index);
                            }
                            return result;
                        };
                    }

                    /**
                     * Creates a function that produces an instance of `Ctor` regardless of
                     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
                     *
                     * @private
                     * @param {Function} Ctor The constructor to wrap.
                     * @returns {Function} Returns the new wrapped function.
                     */
                    function createCtorWrapper(Ctor) {
                        return function() {
                            // Use a `switch` statement to work with class constructors.
                            // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
                            // for more details.
                            var args = arguments;
                            switch (args.length) {
                                case 0:
                                    return new Ctor;
                                case 1:
                                    return new Ctor(args[0]);
                                case 2:
                                    return new Ctor(args[0], args[1]);
                                case 3:
                                    return new Ctor(args[0], args[1], args[2]);
                                case 4:
                                    return new Ctor(args[0], args[1], args[2], args[3]);
                                case 5:
                                    return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                                case 6:
                                    return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                                case 7:
                                    return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                            }
                            var thisBinding = baseCreate(Ctor.prototype),
                                result = Ctor.apply(thisBinding, args);

                            // Mimic the constructor's `return` behavior.
                            // See https://es5.github.io/#x13.2.2 for more details.
                            return isObject(result) ? result : thisBinding;
                        };
                    }

                    /**
                     * Creates a `_.curry` or `_.curryRight` function.
                     *
                     * @private
                     * @param {boolean} flag The curry bit flag.
                     * @returns {Function} Returns the new curry function.
                     */
                    function createCurry(flag) {
                        function curryFunc(func, arity, guard) {
                            if (guard && isIterateeCall(func, arity, guard)) {
                                arity = undefined;
                            }
                            var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);
                            result.placeholder = curryFunc.placeholder;
                            return result;
                        }
                        return curryFunc;
                    }

                    /**
                     * Creates a `_.defaults` or `_.defaultsDeep` function.
                     *
                     * @private
                     * @param {Function} assigner The function to assign values.
                     * @param {Function} customizer The function to customize assigned values.
                     * @returns {Function} Returns the new defaults function.
                     */
                    function createDefaults(assigner, customizer) {
                        return restParam(function(args) {
                            var object = args[0];
                            if (object == null) {
                                return object;
                            }
                            args.push(customizer);
                            return assigner.apply(undefined, args);
                        });
                    }

                    /**
                     * Creates a `_.max` or `_.min` function.
                     *
                     * @private
                     * @param {Function} comparator The function used to compare values.
                     * @param {*} exValue The initial extremum value.
                     * @returns {Function} Returns the new extremum function.
                     */
                    function createExtremum(comparator, exValue) {
                        return function(collection, iteratee, thisArg) {
                            if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
                                iteratee = undefined;
                            }
                            iteratee = getCallback(iteratee, thisArg, 3);
                            if (iteratee.length == 1) {
                                collection = isArray(collection) ? collection : toIterable(collection);
                                var result = arrayExtremum(collection, iteratee, comparator, exValue);
                                if (!(collection.length && result === exValue)) {
                                    return result;
                                }
                            }
                            return baseExtremum(collection, iteratee, comparator, exValue);
                        };
                    }

                    /**
                     * Creates a `_.find` or `_.findLast` function.
                     *
                     * @private
                     * @param {Function} eachFunc The function to iterate over a collection.
                     * @param {boolean} [fromRight] Specify iterating from right to left.
                     * @returns {Function} Returns the new find function.
                     */
                    function createFind(eachFunc, fromRight) {
                        return function(collection, predicate, thisArg) {
                            predicate = getCallback(predicate, thisArg, 3);
                            if (isArray(collection)) {
                                var index = baseFindIndex(collection, predicate, fromRight);
                                return index > -1 ? collection[index] : undefined;
                            }
                            return baseFind(collection, predicate, eachFunc);
                        };
                    }

                    /**
                     * Creates a `_.findIndex` or `_.findLastIndex` function.
                     *
                     * @private
                     * @param {boolean} [fromRight] Specify iterating from right to left.
                     * @returns {Function} Returns the new find function.
                     */
                    function createFindIndex(fromRight) {
                        return function(array, predicate, thisArg) {
                            if (!(array && array.length)) {
                                return -1;
                            }
                            predicate = getCallback(predicate, thisArg, 3);
                            return baseFindIndex(array, predicate, fromRight);
                        };
                    }

                    /**
                     * Creates a `_.findKey` or `_.findLastKey` function.
                     *
                     * @private
                     * @param {Function} objectFunc The function to iterate over an object.
                     * @returns {Function} Returns the new find function.
                     */
                    function createFindKey(objectFunc) {
                        return function(object, predicate, thisArg) {
                            predicate = getCallback(predicate, thisArg, 3);
                            return baseFind(object, predicate, objectFunc, true);
                        };
                    }

                    /**
                     * Creates a `_.flow` or `_.flowRight` function.
                     *
                     * @private
                     * @param {boolean} [fromRight] Specify iterating from right to left.
                     * @returns {Function} Returns the new flow function.
                     */
                    function createFlow(fromRight) {
                        return function() {
                            var wrapper,
                                length = arguments.length,
                                index = fromRight ? length : -1,
                                leftIndex = 0,
                                funcs = Array(length);

                            while ((fromRight ? index-- : ++index < length)) {
                                var func = funcs[leftIndex++] = arguments[index];
                                if (typeof func != 'function') {
                                    throw new TypeError(FUNC_ERROR_TEXT);
                                }
                                if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
                                    wrapper = new LodashWrapper([], true);
                                }
                            }
                            index = wrapper ? -1 : length;
                            while (++index < length) {
                                func = funcs[index];

                                var funcName = getFuncName(func),
                                    data = funcName == 'wrapper' ? getData(func) : undefined;

                                if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
                                    wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                                } else {
                                    wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
                                }
                            }
                            return function() {
                                var args = arguments,
                                    value = args[0];

                                if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
                                    return wrapper.plant(value).value();
                                }
                                var index = 0,
                                    result = length ? funcs[index].apply(this, args) : value;

                                while (++index < length) {
                                    result = funcs[index].call(this, result);
                                }
                                return result;
                            };
                        };
                    }

                    /**
                     * Creates a function for `_.forEach` or `_.forEachRight`.
                     *
                     * @private
                     * @param {Function} arrayFunc The function to iterate over an array.
                     * @param {Function} eachFunc The function to iterate over a collection.
                     * @returns {Function} Returns the new each function.
                     */
                    function createForEach(arrayFunc, eachFunc) {
                        return function(collection, iteratee, thisArg) {
                            return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection)) ?
                                arrayFunc(collection, iteratee) :
                                eachFunc(collection, bindCallback(iteratee, thisArg, 3));
                        };
                    }

                    /**
                     * Creates a function for `_.forIn` or `_.forInRight`.
                     *
                     * @private
                     * @param {Function} objectFunc The function to iterate over an object.
                     * @returns {Function} Returns the new each function.
                     */
                    function createForIn(objectFunc) {
                        return function(object, iteratee, thisArg) {
                            if (typeof iteratee != 'function' || thisArg !== undefined) {
                                iteratee = bindCallback(iteratee, thisArg, 3);
                            }
                            return objectFunc(object, iteratee, keysIn);
                        };
                    }

                    /**
                     * Creates a function for `_.forOwn` or `_.forOwnRight`.
                     *
                     * @private
                     * @param {Function} objectFunc The function to iterate over an object.
                     * @returns {Function} Returns the new each function.
                     */
                    function createForOwn(objectFunc) {
                        return function(object, iteratee, thisArg) {
                            if (typeof iteratee != 'function' || thisArg !== undefined) {
                                iteratee = bindCallback(iteratee, thisArg, 3);
                            }
                            return objectFunc(object, iteratee);
                        };
                    }

                    /**
                     * Creates a function for `_.mapKeys` or `_.mapValues`.
                     *
                     * @private
                     * @param {boolean} [isMapKeys] Specify mapping keys instead of values.
                     * @returns {Function} Returns the new map function.
                     */
                    function createObjectMapper(isMapKeys) {
                        return function(object, iteratee, thisArg) {
                            var result = {};
                            iteratee = getCallback(iteratee, thisArg, 3);

                            baseForOwn(object, function(value, key, object) {
                                var mapped = iteratee(value, key, object);
                                key = isMapKeys ? mapped : key;
                                value = isMapKeys ? value : mapped;
                                result[key] = value;
                            });
                            return result;
                        };
                    }

                    /**
                     * Creates a function for `_.padLeft` or `_.padRight`.
                     *
                     * @private
                     * @param {boolean} [fromRight] Specify padding from the right.
                     * @returns {Function} Returns the new pad function.
                     */
                    function createPadDir(fromRight) {
                        return function(string, length, chars) {
                            string = baseToString(string);
                            return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
                        };
                    }

                    /**
                     * Creates a `_.partial` or `_.partialRight` function.
                     *
                     * @private
                     * @param {boolean} flag The partial bit flag.
                     * @returns {Function} Returns the new partial function.
                     */
                    function createPartial(flag) {
                        var partialFunc = restParam(function(func, partials) {
                            var holders = replaceHolders(partials, partialFunc.placeholder);
                            return createWrapper(func, flag, undefined, partials, holders);
                        });
                        return partialFunc;
                    }

                    /**
                     * Creates a function for `_.reduce` or `_.reduceRight`.
                     *
                     * @private
                     * @param {Function} arrayFunc The function to iterate over an array.
                     * @param {Function} eachFunc The function to iterate over a collection.
                     * @returns {Function} Returns the new each function.
                     */
                    function createReduce(arrayFunc, eachFunc) {
                        return function(collection, iteratee, accumulator, thisArg) {
                            var initFromArray = arguments.length < 3;
                            return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection)) ?
                                arrayFunc(collection, iteratee, accumulator, initFromArray) :
                                baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
                        };
                    }

                    /**
                     * Creates a function that wraps `func` and invokes it with optional `this`
                     * binding of, partial application, and currying.
                     *
                     * @private
                     * @param {Function|string} func The function or method name to reference.
                     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
                     * @param {*} [thisArg] The `this` binding of `func`.
                     * @param {Array} [partials] The arguments to prepend to those provided to the new function.
                     * @param {Array} [holders] The `partials` placeholder indexes.
                     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
                     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
                     * @param {Array} [argPos] The argument positions of the new function.
                     * @param {number} [ary] The arity cap of `func`.
                     * @param {number} [arity] The arity of `func`.
                     * @returns {Function} Returns the new wrapped function.
                     */
                    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
                        var isAry = bitmask & ARY_FLAG,
                            isBind = bitmask & BIND_FLAG,
                            isBindKey = bitmask & BIND_KEY_FLAG,
                            isCurry = bitmask & CURRY_FLAG,
                            isCurryBound = bitmask & CURRY_BOUND_FLAG,
                            isCurryRight = bitmask & CURRY_RIGHT_FLAG,
                            Ctor = isBindKey ? undefined : createCtorWrapper(func);

                        function wrapper() {
                            // Avoid `arguments` object use disqualifying optimizations by
                            // converting it to an array before providing it to other functions.
                            var length = arguments.length,
                                index = length,
                                args = Array(length);

                            while (index--) {
                                args[index] = arguments[index];
                            }
                            if (partials) {
                                args = composeArgs(args, partials, holders);
                            }
                            if (partialsRight) {
                                args = composeArgsRight(args, partialsRight, holdersRight);
                            }
                            if (isCurry || isCurryRight) {
                                var placeholder = wrapper.placeholder,
                                    argsHolders = replaceHolders(args, placeholder);

                                length -= argsHolders.length;
                                if (length < arity) {
                                    var newArgPos = argPos ? arrayCopy(argPos) : undefined,
                                        newArity = nativeMax(arity - length, 0),
                                        newsHolders = isCurry ? argsHolders : undefined,
                                        newHoldersRight = isCurry ? undefined : argsHolders,
                                        newPartials = isCurry ? args : undefined,
                                        newPartialsRight = isCurry ? undefined : args;

                                    bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
                                    bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

                                    if (!isCurryBound) {
                                        bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
                                    }
                                    var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
                                        result = createHybridWrapper.apply(undefined, newData);

                                    if (isLaziable(func)) {
                                        setData(result, newData);
                                    }
                                    result.placeholder = placeholder;
                                    return result;
                                }
                            }
                            var thisBinding = isBind ? thisArg : this,
                                fn = isBindKey ? thisBinding[func] : func;

                            if (argPos) {
                                args = reorder(args, argPos);
                            }
                            if (isAry && ary < args.length) {
                                args.length = ary;
                            }
                            if (this && this !== root && this instanceof wrapper) {
                                fn = Ctor || createCtorWrapper(func);
                            }
                            return fn.apply(thisBinding, args);
                        }
                        return wrapper;
                    }

                    /**
                     * Creates the padding required for `string` based on the given `length`.
                     * The `chars` string is truncated if the number of characters exceeds `length`.
                     *
                     * @private
                     * @param {string} string The string to create padding for.
                     * @param {number} [length=0] The padding length.
                     * @param {string} [chars=' '] The string used as padding.
                     * @returns {string} Returns the pad for `string`.
                     */
                    function createPadding(string, length, chars) {
                        var strLength = string.length;
                        length = +length;

                        if (strLength >= length || !nativeIsFinite(length)) {
                            return '';
                        }
                        var padLength = length - strLength;
                        chars = chars == null ? ' ' : (chars + '');
                        return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);
                    }

                    /**
                     * Creates a function that wraps `func` and invokes it with the optional `this`
                     * binding of `thisArg` and the `partials` prepended to those provided to
                     * the wrapper.
                     *
                     * @private
                     * @param {Function} func The function to partially apply arguments to.
                     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
                     * @param {*} thisArg The `this` binding of `func`.
                     * @param {Array} partials The arguments to prepend to those provided to the new function.
                     * @returns {Function} Returns the new bound function.
                     */
                    function createPartialWrapper(func, bitmask, thisArg, partials) {
                        var isBind = bitmask & BIND_FLAG,
                            Ctor = createCtorWrapper(func);

                        function wrapper() {
                            // Avoid `arguments` object use disqualifying optimizations by
                            // converting it to an array before providing it `func`.
                            var argsIndex = -1,
                                argsLength = arguments.length,
                                leftIndex = -1,
                                leftLength = partials.length,
                                args = Array(leftLength + argsLength);

                            while (++leftIndex < leftLength) {
                                args[leftIndex] = partials[leftIndex];
                            }
                            while (argsLength--) {
                                args[leftIndex++] = arguments[++argsIndex];
                            }
                            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
                            return fn.apply(isBind ? thisArg : this, args);
                        }
                        return wrapper;
                    }

                    /**
                     * Creates a `_.ceil`, `_.floor`, or `_.round` function.
                     *
                     * @private
                     * @param {string} methodName The name of the `Math` method to use when rounding.
                     * @returns {Function} Returns the new round function.
                     */
                    function createRound(methodName) {
                        var func = Math[methodName];
                        return function(number, precision) {
                            precision = precision === undefined ? 0 : (+precision || 0);
                            if (precision) {
                                precision = pow(10, precision);
                                return func(number * precision) / precision;
                            }
                            return func(number);
                        };
                    }

                    /**
                     * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.
                     *
                     * @private
                     * @param {boolean} [retHighest] Specify returning the highest qualified index.
                     * @returns {Function} Returns the new index function.
                     */
                    function createSortedIndex(retHighest) {
                        return function(array, value, iteratee, thisArg) {
                            var callback = getCallback(iteratee);
                            return (iteratee == null && callback === baseCallback) ?
                                binaryIndex(array, value, retHighest) :
                                binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
                        };
                    }

                    /**
                     * Creates a function that either curries or invokes `func` with optional
                     * `this` binding and partially applied arguments.
                     *
                     * @private
                     * @param {Function|string} func The function or method name to reference.
                     * @param {number} bitmask The bitmask of flags.
                     *  The bitmask may be composed of the following flags:
                     *     1 - `_.bind`
                     *     2 - `_.bindKey`
                     *     4 - `_.curry` or `_.curryRight` of a bound function
                     *     8 - `_.curry`
                     *    16 - `_.curryRight`
                     *    32 - `_.partial`
                     *    64 - `_.partialRight`
                     *   128 - `_.rearg`
                     *   256 - `_.ary`
                     * @param {*} [thisArg] The `this` binding of `func`.
                     * @param {Array} [partials] The arguments to be partially applied.
                     * @param {Array} [holders] The `partials` placeholder indexes.
                     * @param {Array} [argPos] The argument positions of the new function.
                     * @param {number} [ary] The arity cap of `func`.
                     * @param {number} [arity] The arity of `func`.
                     * @returns {Function} Returns the new wrapped function.
                     */
                    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
                        var isBindKey = bitmask & BIND_KEY_FLAG;
                        if (!isBindKey && typeof func != 'function') {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        var length = partials ? partials.length : 0;
                        if (!length) {
                            bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
                            partials = holders = undefined;
                        }
                        length -= (holders ? holders.length : 0);
                        if (bitmask & PARTIAL_RIGHT_FLAG) {
                            var partialsRight = partials,
                                holdersRight = holders;

                            partials = holders = undefined;
                        }
                        var data = isBindKey ? undefined : getData(func),
                            newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

                        if (data) {
                            mergeData(newData, data);
                            bitmask = newData[1];
                            arity = newData[9];
                        }
                        newData[9] = arity == null ?
                            (isBindKey ? 0 : func.length) :
                            (nativeMax(arity - length, 0) || 0);

                        if (bitmask == BIND_FLAG) {
                            var result = createBindWrapper(newData[0], newData[2]);
                        } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
                            result = createPartialWrapper.apply(undefined, newData);
                        } else {
                            result = createHybridWrapper.apply(undefined, newData);
                        }
                        var setter = data ? baseSetData : setData;
                        return setter(result, newData);
                    }

                    /**
                     * A specialized version of `baseIsEqualDeep` for arrays with support for
                     * partial deep comparisons.
                     *
                     * @private
                     * @param {Array} array The array to compare.
                     * @param {Array} other The other array to compare.
                     * @param {Function} equalFunc The function to determine equivalents of values.
                     * @param {Function} [customizer] The function to customize comparing arrays.
                     * @param {boolean} [isLoose] Specify performing partial comparisons.
                     * @param {Array} [stackA] Tracks traversed `value` objects.
                     * @param {Array} [stackB] Tracks traversed `other` objects.
                     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
                     */
                    function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
                        var index = -1,
                            arrLength = array.length,
                            othLength = other.length;

                        if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
                            return false;
                        }
                        // Ignore non-index properties.
                        while (++index < arrLength) {
                            var arrValue = array[index],
                                othValue = other[index],
                                result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;

                            if (result !== undefined) {
                                if (result) {
                                    continue;
                                }
                                return false;
                            }
                            // Recursively compare arrays (susceptible to call stack limits).
                            if (isLoose) {
                                if (!arraySome(other, function(othValue) {
                                        return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
                                    })) {
                                    return false;
                                }
                            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
                                return false;
                            }
                        }
                        return true;
                    }

                    /**
                     * A specialized version of `baseIsEqualDeep` for comparing objects of
                     * the same `toStringTag`.
                     *
                     * **Note:** This function only supports comparing values with tags of
                     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
                     *
                     * @private
                     * @param {Object} object The object to compare.
                     * @param {Object} other The other object to compare.
                     * @param {string} tag The `toStringTag` of the objects to compare.
                     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                     */
                    function equalByTag(object, other, tag) {
                        switch (tag) {
                            case boolTag:
                            case dateTag:
                                // Coerce dates and booleans to numbers, dates to milliseconds and booleans
                                // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
                                return +object == +other;

                            case errorTag:
                                return object.name == other.name && object.message == other.message;

                            case numberTag:
                                // Treat `NaN` vs. `NaN` as equal.
                                return (object != +object) ?
                                    other != +other :
                                    object == +other;

                            case regexpTag:
                            case stringTag:
                                // Coerce regexes to strings and treat strings primitives and string
                                // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
                                return object == (other + '');
                        }
                        return false;
                    }

                    /**
                     * A specialized version of `baseIsEqualDeep` for objects with support for
                     * partial deep comparisons.
                     *
                     * @private
                     * @param {Object} object The object to compare.
                     * @param {Object} other The other object to compare.
                     * @param {Function} equalFunc The function to determine equivalents of values.
                     * @param {Function} [customizer] The function to customize comparing values.
                     * @param {boolean} [isLoose] Specify performing partial comparisons.
                     * @param {Array} [stackA] Tracks traversed `value` objects.
                     * @param {Array} [stackB] Tracks traversed `other` objects.
                     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                     */
                    function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
                        var objProps = keys(object),
                            objLength = objProps.length,
                            othProps = keys(other),
                            othLength = othProps.length;

                        if (objLength != othLength && !isLoose) {
                            return false;
                        }
                        var index = objLength;
                        while (index--) {
                            var key = objProps[index];
                            if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
                                return false;
                            }
                        }
                        var skipCtor = isLoose;
                        while (++index < objLength) {
                            key = objProps[index];
                            var objValue = object[key],
                                othValue = other[key],
                                result = customizer ? customizer(isLoose ? othValue : objValue, isLoose ? objValue : othValue, key) : undefined;

                            // Recursively compare objects (susceptible to call stack limits).
                            if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
                                return false;
                            }
                            skipCtor || (skipCtor = key == 'constructor');
                        }
                        if (!skipCtor) {
                            var objCtor = object.constructor,
                                othCtor = other.constructor;

                            // Non `Object` object instances with different constructors are not equal.
                            if (objCtor != othCtor &&
                                ('constructor' in object && 'constructor' in other) &&
                                !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
                                    typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                                return false;
                            }
                        }
                        return true;
                    }

                    /**
                     * Gets the appropriate "callback" function. If the `_.callback` method is
                     * customized this function returns the custom method, otherwise it returns
                     * the `baseCallback` function. If arguments are provided the chosen function
                     * is invoked with them and its result is returned.
                     *
                     * @private
                     * @returns {Function} Returns the chosen function or its result.
                     */
                    function getCallback(func, thisArg, argCount) {
                        var result = lodash.callback || callback;
                        result = result === callback ? baseCallback : result;
                        return argCount ? result(func, thisArg, argCount) : result;
                    }

                    /**
                     * Gets metadata for `func`.
                     *
                     * @private
                     * @param {Function} func The function to query.
                     * @returns {*} Returns the metadata for `func`.
                     */
                    var getData = !metaMap ? noop : function(func) {
                        return metaMap.get(func);
                    };

                    /**
                     * Gets the name of `func`.
                     *
                     * @private
                     * @param {Function} func The function to query.
                     * @returns {string} Returns the function name.
                     */
                    function getFuncName(func) {
                        var result = func.name,
                            array = realNames[result],
                            length = array ? array.length : 0;

                        while (length--) {
                            var data = array[length],
                                otherFunc = data.func;
                            if (otherFunc == null || otherFunc == func) {
                                return data.name;
                            }
                        }
                        return result;
                    }

                    /**
                     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
                     * customized this function returns the custom method, otherwise it returns
                     * the `baseIndexOf` function. If arguments are provided the chosen function
                     * is invoked with them and its result is returned.
                     *
                     * @private
                     * @returns {Function|number} Returns the chosen function or its result.
                     */
                    function getIndexOf(collection, target, fromIndex) {
                        var result = lodash.indexOf || indexOf;
                        result = result === indexOf ? baseIndexOf : result;
                        return collection ? result(collection, target, fromIndex) : result;
                    }

                    /**
                     * Gets the "length" property value of `object`.
                     *
                     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
                     * that affects Safari on at least iOS 8.1-8.3 ARM64.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @returns {*} Returns the "length" value.
                     */
                    var getLength = baseProperty('length');

                    /**
                     * Gets the propery names, values, and compare flags of `object`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the match data of `object`.
                     */
                    function getMatchData(object) {
                        var result = pairs(object),
                            length = result.length;

                        while (length--) {
                            result[length][2] = isStrictComparable(result[length][1]);
                        }
                        return result;
                    }

                    /**
                     * Gets the native function at `key` of `object`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @param {string} key The key of the method to get.
                     * @returns {*} Returns the function if it's native, else `undefined`.
                     */
                    function getNative(object, key) {
                        var value = object == null ? undefined : object[key];
                        return isNative(value) ? value : undefined;
                    }

                    /**
                     * Gets the view, applying any `transforms` to the `start` and `end` positions.
                     *
                     * @private
                     * @param {number} start The start of the view.
                     * @param {number} end The end of the view.
                     * @param {Array} transforms The transformations to apply to the view.
                     * @returns {Object} Returns an object containing the `start` and `end`
                     *  positions of the view.
                     */
                    function getView(start, end, transforms) {
                        var index = -1,
                            length = transforms.length;

                        while (++index < length) {
                            var data = transforms[index],
                                size = data.size;

                            switch (data.type) {
                                case 'drop':
                                    start += size;
                                    break;
                                case 'dropRight':
                                    end -= size;
                                    break;
                                case 'take':
                                    end = nativeMin(end, start + size);
                                    break;
                                case 'takeRight':
                                    start = nativeMax(start, end - size);
                                    break;
                            }
                        }
                        return {
                            'start': start,
                            'end': end
                        };
                    }

                    /**
                     * Initializes an array clone.
                     *
                     * @private
                     * @param {Array} array The array to clone.
                     * @returns {Array} Returns the initialized clone.
                     */
                    function initCloneArray(array) {
                        var length = array.length,
                            result = new array.constructor(length);

                        // Add array properties assigned by `RegExp#exec`.
                        if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
                            result.index = array.index;
                            result.input = array.input;
                        }
                        return result;
                    }

                    /**
                     * Initializes an object clone.
                     *
                     * @private
                     * @param {Object} object The object to clone.
                     * @returns {Object} Returns the initialized clone.
                     */
                    function initCloneObject(object) {
                        var Ctor = object.constructor;
                        if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
                            Ctor = Object;
                        }
                        return new Ctor;
                    }

                    /**
                     * Initializes an object clone based on its `toStringTag`.
                     *
                     * **Note:** This function only supports cloning values with tags of
                     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
                     *
                     * @private
                     * @param {Object} object The object to clone.
                     * @param {string} tag The `toStringTag` of the object to clone.
                     * @param {boolean} [isDeep] Specify a deep clone.
                     * @returns {Object} Returns the initialized clone.
                     */
                    function initCloneByTag(object, tag, isDeep) {
                        var Ctor = object.constructor;
                        switch (tag) {
                            case arrayBufferTag:
                                return bufferClone(object);

                            case boolTag:
                            case dateTag:
                                return new Ctor(+object);

                            case float32Tag:
                            case float64Tag:
                            case int8Tag:
                            case int16Tag:
                            case int32Tag:
                            case uint8Tag:
                            case uint8ClampedTag:
                            case uint16Tag:
                            case uint32Tag:
                                var buffer = object.buffer;
                                return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

                            case numberTag:
                            case stringTag:
                                return new Ctor(object);

                            case regexpTag:
                                var result = new Ctor(object.source, reFlags.exec(object));
                                result.lastIndex = object.lastIndex;
                        }
                        return result;
                    }

                    /**
                     * Invokes the method at `path` on `object`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @param {Array|string} path The path of the method to invoke.
                     * @param {Array} args The arguments to invoke the method with.
                     * @returns {*} Returns the result of the invoked method.
                     */
                    function invokePath(object, path, args) {
                        if (object != null && !isKey(path, object)) {
                            path = toPath(path);
                            object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                            path = last(path);
                        }
                        var func = object == null ? object : object[path];
                        return func == null ? undefined : func.apply(object, args);
                    }

                    /**
                     * Checks if `value` is array-like.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
                     */
                    function isArrayLike(value) {
                        return value != null && isLength(getLength(value));
                    }

                    /**
                     * Checks if `value` is a valid array-like index.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
                     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
                     */
                    function isIndex(value, length) {
                        value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
                        length = length == null ? MAX_SAFE_INTEGER : length;
                        return value > -1 && value % 1 == 0 && value < length;
                    }

                    /**
                     * Checks if the provided arguments are from an iteratee call.
                     *
                     * @private
                     * @param {*} value The potential iteratee value argument.
                     * @param {*} index The potential iteratee index or key argument.
                     * @param {*} object The potential iteratee object argument.
                     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
                     */
                    function isIterateeCall(value, index, object) {
                        if (!isObject(object)) {
                            return false;
                        }
                        var type = typeof index;
                        if (type == 'number' ?
                            (isArrayLike(object) && isIndex(index, object.length)) :
                            (type == 'string' && index in object)) {
                            var other = object[index];
                            return value === value ? (value === other) : (other !== other);
                        }
                        return false;
                    }

                    /**
                     * Checks if `value` is a property name and not a property path.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @param {Object} [object] The object to query keys on.
                     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
                     */
                    function isKey(value, object) {
                        var type = typeof value;
                        if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
                            return true;
                        }
                        if (isArray(value)) {
                            return false;
                        }
                        var result = !reIsDeepProp.test(value);
                        return result || (object != null && value in toObject(object));
                    }

                    /**
                     * Checks if `func` has a lazy counterpart.
                     *
                     * @private
                     * @param {Function} func The function to check.
                     * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
                     */
                    function isLaziable(func) {
                        var funcName = getFuncName(func);
                        if (!(funcName in LazyWrapper.prototype)) {
                            return false;
                        }
                        var other = lodash[funcName];
                        if (func === other) {
                            return true;
                        }
                        var data = getData(other);
                        return !!data && func === data[0];
                    }

                    /**
                     * Checks if `value` is a valid array-like length.
                     *
                     * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
                     */
                    function isLength(value) {
                        return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
                    }

                    /**
                     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` if suitable for strict
                     *  equality comparisons, else `false`.
                     */
                    function isStrictComparable(value) {
                        return value === value && !isObject(value);
                    }

                    /**
                     * Merges the function metadata of `source` into `data`.
                     *
                     * Merging metadata reduces the number of wrappers required to invoke a function.
                     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
                     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
                     * augment function arguments, making the order in which they are executed important,
                     * preventing the merging of metadata. However, we make an exception for a safe
                     * common case where curried functions have `_.ary` and or `_.rearg` applied.
                     *
                     * @private
                     * @param {Array} data The destination metadata.
                     * @param {Array} source The source metadata.
                     * @returns {Array} Returns `data`.
                     */
                    function mergeData(data, source) {
                        var bitmask = data[1],
                            srcBitmask = source[1],
                            newBitmask = bitmask | srcBitmask,
                            isCommon = newBitmask < ARY_FLAG;

                        var isCombo =
                            (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||
                            (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||
                            (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);

                        // Exit early if metadata can't be merged.
                        if (!(isCommon || isCombo)) {
                            return data;
                        }
                        // Use source `thisArg` if available.
                        if (srcBitmask & BIND_FLAG) {
                            data[2] = source[2];
                            // Set when currying a bound function.
                            newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
                        }
                        // Compose partial arguments.
                        var value = source[3];
                        if (value) {
                            var partials = data[3];
                            data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
                            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
                        }
                        // Compose partial right arguments.
                        value = source[5];
                        if (value) {
                            partials = data[5];
                            data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
                            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
                        }
                        // Use source `argPos` if available.
                        value = source[7];
                        if (value) {
                            data[7] = arrayCopy(value);
                        }
                        // Use source `ary` if it's smaller.
                        if (srcBitmask & ARY_FLAG) {
                            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
                        }
                        // Use source `arity` if one is not provided.
                        if (data[9] == null) {
                            data[9] = source[9];
                        }
                        // Use source `func` and merge bitmasks.
                        data[0] = source[0];
                        data[1] = newBitmask;

                        return data;
                    }

                    /**
                     * Used by `_.defaultsDeep` to customize its `_.merge` use.
                     *
                     * @private
                     * @param {*} objectValue The destination object property value.
                     * @param {*} sourceValue The source object property value.
                     * @returns {*} Returns the value to assign to the destination object.
                     */
                    function mergeDefaults(objectValue, sourceValue) {
                        return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);
                    }

                    /**
                     * A specialized version of `_.pick` which picks `object` properties specified
                     * by `props`.
                     *
                     * @private
                     * @param {Object} object The source object.
                     * @param {string[]} props The property names to pick.
                     * @returns {Object} Returns the new object.
                     */
                    function pickByArray(object, props) {
                        object = toObject(object);

                        var index = -1,
                            length = props.length,
                            result = {};

                        while (++index < length) {
                            var key = props[index];
                            if (key in object) {
                                result[key] = object[key];
                            }
                        }
                        return result;
                    }

                    /**
                     * A specialized version of `_.pick` which picks `object` properties `predicate`
                     * returns truthy for.
                     *
                     * @private
                     * @param {Object} object The source object.
                     * @param {Function} predicate The function invoked per iteration.
                     * @returns {Object} Returns the new object.
                     */
                    function pickByCallback(object, predicate) {
                        var result = {};
                        baseForIn(object, function(value, key, object) {
                            if (predicate(value, key, object)) {
                                result[key] = value;
                            }
                        });
                        return result;
                    }

                    /**
                     * Reorder `array` according to the specified indexes where the element at
                     * the first index is assigned as the first element, the element at
                     * the second index is assigned as the second element, and so on.
                     *
                     * @private
                     * @param {Array} array The array to reorder.
                     * @param {Array} indexes The arranged array indexes.
                     * @returns {Array} Returns `array`.
                     */
                    function reorder(array, indexes) {
                        var arrLength = array.length,
                            length = nativeMin(indexes.length, arrLength),
                            oldArray = arrayCopy(array);

                        while (length--) {
                            var index = indexes[length];
                            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
                        }
                        return array;
                    }

                    /**
                     * Sets metadata for `func`.
                     *
                     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
                     * period of time, it will trip its breaker and transition to an identity function
                     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
                     * for more details.
                     *
                     * @private
                     * @param {Function} func The function to associate metadata with.
                     * @param {*} data The metadata.
                     * @returns {Function} Returns `func`.
                     */
                    var setData = (function() {
                        var count = 0,
                            lastCalled = 0;

                        return function(key, value) {
                            var stamp = now(),
                                remaining = HOT_SPAN - (stamp - lastCalled);

                            lastCalled = stamp;
                            if (remaining > 0) {
                                if (++count >= HOT_COUNT) {
                                    return key;
                                }
                            } else {
                                count = 0;
                            }
                            return baseSetData(key, value);
                        };
                    }());

                    /**
                     * A fallback implementation of `Object.keys` which creates an array of the
                     * own enumerable property names of `object`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of property names.
                     */
                    function shimKeys(object) {
                        var props = keysIn(object),
                            propsLength = props.length,
                            length = propsLength && object.length;

                        var allowIndexes = !!length && isLength(length) &&
                            (isArray(object) || isArguments(object));

                        var index = -1,
                            result = [];

                        while (++index < propsLength) {
                            var key = props[index];
                            if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
                                result.push(key);
                            }
                        }
                        return result;
                    }

                    /**
                     * Converts `value` to an array-like object if it's not one.
                     *
                     * @private
                     * @param {*} value The value to process.
                     * @returns {Array|Object} Returns the array-like object.
                     */
                    function toIterable(value) {
                        if (value == null) {
                            return [];
                        }
                        if (!isArrayLike(value)) {
                            return values(value);
                        }
                        return isObject(value) ? value : Object(value);
                    }

                    /**
                     * Converts `value` to an object if it's not one.
                     *
                     * @private
                     * @param {*} value The value to process.
                     * @returns {Object} Returns the object.
                     */
                    function toObject(value) {
                        return isObject(value) ? value : Object(value);
                    }

                    /**
                     * Converts `value` to property path array if it's not one.
                     *
                     * @private
                     * @param {*} value The value to process.
                     * @returns {Array} Returns the property path array.
                     */
                    function toPath(value) {
                        if (isArray(value)) {
                            return value;
                        }
                        var result = [];
                        baseToString(value).replace(rePropName, function(match, number, quote, string) {
                            result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
                        });
                        return result;
                    }

                    /**
                     * Creates a clone of `wrapper`.
                     *
                     * @private
                     * @param {Object} wrapper The wrapper to clone.
                     * @returns {Object} Returns the cloned wrapper.
                     */
                    function wrapperClone(wrapper) {
                        return wrapper instanceof LazyWrapper ?
                            wrapper.clone() :
                            new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Creates an array of elements split into groups the length of `size`.
                     * If `collection` can't be split evenly, the final chunk will be the remaining
                     * elements.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to process.
                     * @param {number} [size=1] The length of each chunk.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Array} Returns the new array containing chunks.
                     * @example
                     *
                     * _.chunk(['a', 'b', 'c', 'd'], 2);
                     * // => [['a', 'b'], ['c', 'd']]
                     *
                     * _.chunk(['a', 'b', 'c', 'd'], 3);
                     * // => [['a', 'b', 'c'], ['d']]
                     */
                    function chunk(array, size, guard) {
                        if (guard ? isIterateeCall(array, size, guard) : size == null) {
                            size = 1;
                        } else {
                            size = nativeMax(nativeFloor(size) || 1, 1);
                        }
                        var index = 0,
                            length = array ? array.length : 0,
                            resIndex = -1,
                            result = Array(nativeCeil(length / size));

                        while (index < length) {
                            result[++resIndex] = baseSlice(array, index, (index += size));
                        }
                        return result;
                    }

                    /**
                     * Creates an array with all falsey values removed. The values `false`, `null`,
                     * `0`, `""`, `undefined`, and `NaN` are falsey.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to compact.
                     * @returns {Array} Returns the new array of filtered values.
                     * @example
                     *
                     * _.compact([0, 1, false, 2, '', 3]);
                     * // => [1, 2, 3]
                     */
                    function compact(array) {
                        var index = -1,
                            length = array ? array.length : 0,
                            resIndex = -1,
                            result = [];

                        while (++index < length) {
                            var value = array[index];
                            if (value) {
                                result[++resIndex] = value;
                            }
                        }
                        return result;
                    }

                    /**
                     * Creates an array of unique `array` values not included in the other
                     * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                     * for equality comparisons.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to inspect.
                     * @param {...Array} [values] The arrays of values to exclude.
                     * @returns {Array} Returns the new array of filtered values.
                     * @example
                     *
                     * _.difference([1, 2, 3], [4, 2]);
                     * // => [1, 3]
                     */
                    var difference = restParam(function(array, values) {
                        return (isObjectLike(array) && isArrayLike(array)) ?
                            baseDifference(array, baseFlatten(values, false, true)) :
                            [];
                    });

                    /**
                     * Creates a slice of `array` with `n` elements dropped from the beginning.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to query.
                     * @param {number} [n=1] The number of elements to drop.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Array} Returns the slice of `array`.
                     * @example
                     *
                     * _.drop([1, 2, 3]);
                     * // => [2, 3]
                     *
                     * _.drop([1, 2, 3], 2);
                     * // => [3]
                     *
                     * _.drop([1, 2, 3], 5);
                     * // => []
                     *
                     * _.drop([1, 2, 3], 0);
                     * // => [1, 2, 3]
                     */
                    function drop(array, n, guard) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return [];
                        }
                        if (guard ? isIterateeCall(array, n, guard) : n == null) {
                            n = 1;
                        }
                        return baseSlice(array, n < 0 ? 0 : n);
                    }

                    /**
                     * Creates a slice of `array` with `n` elements dropped from the end.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to query.
                     * @param {number} [n=1] The number of elements to drop.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Array} Returns the slice of `array`.
                     * @example
                     *
                     * _.dropRight([1, 2, 3]);
                     * // => [1, 2]
                     *
                     * _.dropRight([1, 2, 3], 2);
                     * // => [1]
                     *
                     * _.dropRight([1, 2, 3], 5);
                     * // => []
                     *
                     * _.dropRight([1, 2, 3], 0);
                     * // => [1, 2, 3]
                     */
                    function dropRight(array, n, guard) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return [];
                        }
                        if (guard ? isIterateeCall(array, n, guard) : n == null) {
                            n = 1;
                        }
                        n = length - (+n || 0);
                        return baseSlice(array, 0, n < 0 ? 0 : n);
                    }

                    /**
                     * Creates a slice of `array` excluding elements dropped from the end.
                     * Elements are dropped until `predicate` returns falsey. The predicate is
                     * bound to `thisArg` and invoked with three arguments: (value, index, array).
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that match the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to query.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {Array} Returns the slice of `array`.
                     * @example
                     *
                     * _.dropRightWhile([1, 2, 3], function(n) {
                     *   return n > 1;
                     * });
                     * // => [1]
                     *
                     * var users = [
                     *   { 'user': 'barney',  'active': true },
                     *   { 'user': 'fred',    'active': false },
                     *   { 'user': 'pebbles', 'active': false }
                     * ];
                     *
                     * // using the `_.matches` callback shorthand
                     * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
                     * // => ['barney', 'fred']
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
                     * // => ['barney']
                     *
                     * // using the `_.property` callback shorthand
                     * _.pluck(_.dropRightWhile(users, 'active'), 'user');
                     * // => ['barney', 'fred', 'pebbles']
                     */
                    function dropRightWhile(array, predicate, thisArg) {
                        return (array && array.length) ?
                            baseWhile(array, getCallback(predicate, thisArg, 3), true, true) :
                            [];
                    }

                    /**
                     * Creates a slice of `array` excluding elements dropped from the beginning.
                     * Elements are dropped until `predicate` returns falsey. The predicate is
                     * bound to `thisArg` and invoked with three arguments: (value, index, array).
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to query.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {Array} Returns the slice of `array`.
                     * @example
                     *
                     * _.dropWhile([1, 2, 3], function(n) {
                     *   return n < 3;
                     * });
                     * // => [3]
                     *
                     * var users = [
                     *   { 'user': 'barney',  'active': false },
                     *   { 'user': 'fred',    'active': false },
                     *   { 'user': 'pebbles', 'active': true }
                     * ];
                     *
                     * // using the `_.matches` callback shorthand
                     * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
                     * // => ['fred', 'pebbles']
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.pluck(_.dropWhile(users, 'active', false), 'user');
                     * // => ['pebbles']
                     *
                     * // using the `_.property` callback shorthand
                     * _.pluck(_.dropWhile(users, 'active'), 'user');
                     * // => ['barney', 'fred', 'pebbles']
                     */
                    function dropWhile(array, predicate, thisArg) {
                        return (array && array.length) ?
                            baseWhile(array, getCallback(predicate, thisArg, 3), true) :
                            [];
                    }

                    /**
                     * Fills elements of `array` with `value` from `start` up to, but not
                     * including, `end`.
                     *
                     * **Note:** This method mutates `array`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to fill.
                     * @param {*} value The value to fill `array` with.
                     * @param {number} [start=0] The start position.
                     * @param {number} [end=array.length] The end position.
                     * @returns {Array} Returns `array`.
                     * @example
                     *
                     * var array = [1, 2, 3];
                     *
                     * _.fill(array, 'a');
                     * console.log(array);
                     * // => ['a', 'a', 'a']
                     *
                     * _.fill(Array(3), 2);
                     * // => [2, 2, 2]
                     *
                     * _.fill([4, 6, 8], '*', 1, 2);
                     * // => [4, '*', 8]
                     */
                    function fill(array, value, start, end) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return [];
                        }
                        if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
                            start = 0;
                            end = length;
                        }
                        return baseFill(array, value, start, end);
                    }

                    /**
                     * This method is like `_.find` except that it returns the index of the first
                     * element `predicate` returns truthy for instead of the element itself.
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to search.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {number} Returns the index of the found element, else `-1`.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney',  'active': false },
                     *   { 'user': 'fred',    'active': false },
                     *   { 'user': 'pebbles', 'active': true }
                     * ];
                     *
                     * _.findIndex(users, function(chr) {
                     *   return chr.user == 'barney';
                     * });
                     * // => 0
                     *
                     * // using the `_.matches` callback shorthand
                     * _.findIndex(users, { 'user': 'fred', 'active': false });
                     * // => 1
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.findIndex(users, 'active', false);
                     * // => 0
                     *
                     * // using the `_.property` callback shorthand
                     * _.findIndex(users, 'active');
                     * // => 2
                     */
                    var findIndex = createFindIndex();

                    /**
                     * This method is like `_.findIndex` except that it iterates over elements
                     * of `collection` from right to left.
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to search.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {number} Returns the index of the found element, else `-1`.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney',  'active': true },
                     *   { 'user': 'fred',    'active': false },
                     *   { 'user': 'pebbles', 'active': false }
                     * ];
                     *
                     * _.findLastIndex(users, function(chr) {
                     *   return chr.user == 'pebbles';
                     * });
                     * // => 2
                     *
                     * // using the `_.matches` callback shorthand
                     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
                     * // => 0
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.findLastIndex(users, 'active', false);
                     * // => 2
                     *
                     * // using the `_.property` callback shorthand
                     * _.findLastIndex(users, 'active');
                     * // => 0
                     */
                    var findLastIndex = createFindIndex(true);

                    /**
                     * Gets the first element of `array`.
                     *
                     * @static
                     * @memberOf _
                     * @alias head
                     * @category Array
                     * @param {Array} array The array to query.
                     * @returns {*} Returns the first element of `array`.
                     * @example
                     *
                     * _.first([1, 2, 3]);
                     * // => 1
                     *
                     * _.first([]);
                     * // => undefined
                     */
                    function first(array) {
                        return array ? array[0] : undefined;
                    }

                    /**
                     * Flattens a nested array. If `isDeep` is `true` the array is recursively
                     * flattened, otherwise it is only flattened a single level.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to flatten.
                     * @param {boolean} [isDeep] Specify a deep flatten.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Array} Returns the new flattened array.
                     * @example
                     *
                     * _.flatten([1, [2, 3, [4]]]);
                     * // => [1, 2, 3, [4]]
                     *
                     * // using `isDeep`
                     * _.flatten([1, [2, 3, [4]]], true);
                     * // => [1, 2, 3, 4]
                     */
                    function flatten(array, isDeep, guard) {
                        var length = array ? array.length : 0;
                        if (guard && isIterateeCall(array, isDeep, guard)) {
                            isDeep = false;
                        }
                        return length ? baseFlatten(array, isDeep) : [];
                    }

                    /**
                     * Recursively flattens a nested array.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to recursively flatten.
                     * @returns {Array} Returns the new flattened array.
                     * @example
                     *
                     * _.flattenDeep([1, [2, 3, [4]]]);
                     * // => [1, 2, 3, 4]
                     */
                    function flattenDeep(array) {
                        var length = array ? array.length : 0;
                        return length ? baseFlatten(array, true) : [];
                    }

                    /**
                     * Gets the index at which the first occurrence of `value` is found in `array`
                     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
                     * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`
                     * performs a faster binary search.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to search.
                     * @param {*} value The value to search for.
                     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
                     *  to perform a binary search on a sorted array.
                     * @returns {number} Returns the index of the matched value, else `-1`.
                     * @example
                     *
                     * _.indexOf([1, 2, 1, 2], 2);
                     * // => 1
                     *
                     * // using `fromIndex`
                     * _.indexOf([1, 2, 1, 2], 2, 2);
                     * // => 3
                     *
                     * // performing a binary search
                     * _.indexOf([1, 1, 2, 2], 2, true);
                     * // => 2
                     */
                    function indexOf(array, value, fromIndex) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return -1;
                        }
                        if (typeof fromIndex == 'number') {
                            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
                        } else if (fromIndex) {
                            var index = binaryIndex(array, value);
                            if (index < length &&
                                (value === value ? (value === array[index]) : (array[index] !== array[index]))) {
                                return index;
                            }
                            return -1;
                        }
                        return baseIndexOf(array, value, fromIndex || 0);
                    }

                    /**
                     * Gets all but the last element of `array`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to query.
                     * @returns {Array} Returns the slice of `array`.
                     * @example
                     *
                     * _.initial([1, 2, 3]);
                     * // => [1, 2]
                     */
                    function initial(array) {
                        return dropRight(array, 1);
                    }

                    /**
                     * Creates an array of unique values that are included in all of the provided
                     * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                     * for equality comparisons.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {...Array} [arrays] The arrays to inspect.
                     * @returns {Array} Returns the new array of shared values.
                     * @example
                     * _.intersection([1, 2], [4, 2], [2, 1]);
                     * // => [2]
                     */
                    var intersection = restParam(function(arrays) {
                        var othLength = arrays.length,
                            othIndex = othLength,
                            caches = Array(length),
                            indexOf = getIndexOf(),
                            isCommon = indexOf == baseIndexOf,
                            result = [];

                        while (othIndex--) {
                            var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
                            caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
                        }
                        var array = arrays[0],
                            index = -1,
                            length = array ? array.length : 0,
                            seen = caches[0];

                        outer:
                            while (++index < length) {
                                value = array[index];
                                if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
                                    var othIndex = othLength;
                                    while (--othIndex) {
                                        var cache = caches[othIndex];
                                        if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
                                            continue outer;
                                        }
                                    }
                                    if (seen) {
                                        seen.push(value);
                                    }
                                    result.push(value);
                                }
                            }
                        return result;
                    });

                    /**
                     * Gets the last element of `array`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to query.
                     * @returns {*} Returns the last element of `array`.
                     * @example
                     *
                     * _.last([1, 2, 3]);
                     * // => 3
                     */
                    function last(array) {
                        var length = array ? array.length : 0;
                        return length ? array[length - 1] : undefined;
                    }

                    /**
                     * This method is like `_.indexOf` except that it iterates over elements of
                     * `array` from right to left.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to search.
                     * @param {*} value The value to search for.
                     * @param {boolean|number} [fromIndex=array.length-1] The index to search from
                     *  or `true` to perform a binary search on a sorted array.
                     * @returns {number} Returns the index of the matched value, else `-1`.
                     * @example
                     *
                     * _.lastIndexOf([1, 2, 1, 2], 2);
                     * // => 3
                     *
                     * // using `fromIndex`
                     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
                     * // => 1
                     *
                     * // performing a binary search
                     * _.lastIndexOf([1, 1, 2, 2], 2, true);
                     * // => 3
                     */
                    function lastIndexOf(array, value, fromIndex) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return -1;
                        }
                        var index = length;
                        if (typeof fromIndex == 'number') {
                            index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
                        } else if (fromIndex) {
                            index = binaryIndex(array, value, true) - 1;
                            var other = array[index];
                            if (value === value ? (value === other) : (other !== other)) {
                                return index;
                            }
                            return -1;
                        }
                        if (value !== value) {
                            return indexOfNaN(array, index, true);
                        }
                        while (index--) {
                            if (array[index] === value) {
                                return index;
                            }
                        }
                        return -1;
                    }

                    /**
                     * Removes all provided values from `array` using
                     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                     * for equality comparisons.
                     *
                     * **Note:** Unlike `_.without`, this method mutates `array`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to modify.
                     * @param {...*} [values] The values to remove.
                     * @returns {Array} Returns `array`.
                     * @example
                     *
                     * var array = [1, 2, 3, 1, 2, 3];
                     *
                     * _.pull(array, 2, 3);
                     * console.log(array);
                     * // => [1, 1]
                     */
                    function pull() {
                        var args = arguments,
                            array = args[0];

                        if (!(array && array.length)) {
                            return array;
                        }
                        var index = 0,
                            indexOf = getIndexOf(),
                            length = args.length;

                        while (++index < length) {
                            var fromIndex = 0,
                                value = args[index];

                            while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
                                splice.call(array, fromIndex, 1);
                            }
                        }
                        return array;
                    }

                    /**
                     * Removes elements from `array` corresponding to the given indexes and returns
                     * an array of the removed elements. Indexes may be specified as an array of
                     * indexes or as individual arguments.
                     *
                     * **Note:** Unlike `_.at`, this method mutates `array`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to modify.
                     * @param {...(number|number[])} [indexes] The indexes of elements to remove,
                     *  specified as individual indexes or arrays of indexes.
                     * @returns {Array} Returns the new array of removed elements.
                     * @example
                     *
                     * var array = [5, 10, 15, 20];
                     * var evens = _.pullAt(array, 1, 3);
                     *
                     * console.log(array);
                     * // => [5, 15]
                     *
                     * console.log(evens);
                     * // => [10, 20]
                     */
                    var pullAt = restParam(function(array, indexes) {
                        indexes = baseFlatten(indexes);

                        var result = baseAt(array, indexes);
                        basePullAt(array, indexes.sort(baseCompareAscending));
                        return result;
                    });

                    /**
                     * Removes all elements from `array` that `predicate` returns truthy for
                     * and returns an array of the removed elements. The predicate is bound to
                     * `thisArg` and invoked with three arguments: (value, index, array).
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * **Note:** Unlike `_.filter`, this method mutates `array`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to modify.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {Array} Returns the new array of removed elements.
                     * @example
                     *
                     * var array = [1, 2, 3, 4];
                     * var evens = _.remove(array, function(n) {
                     *   return n % 2 == 0;
                     * });
                     *
                     * console.log(array);
                     * // => [1, 3]
                     *
                     * console.log(evens);
                     * // => [2, 4]
                     */
                    function remove(array, predicate, thisArg) {
                        var result = [];
                        if (!(array && array.length)) {
                            return result;
                        }
                        var index = -1,
                            indexes = [],
                            length = array.length;

                        predicate = getCallback(predicate, thisArg, 3);
                        while (++index < length) {
                            var value = array[index];
                            if (predicate(value, index, array)) {
                                result.push(value);
                                indexes.push(index);
                            }
                        }
                        basePullAt(array, indexes);
                        return result;
                    }

                    /**
                     * Gets all but the first element of `array`.
                     *
                     * @static
                     * @memberOf _
                     * @alias tail
                     * @category Array
                     * @param {Array} array The array to query.
                     * @returns {Array} Returns the slice of `array`.
                     * @example
                     *
                     * _.rest([1, 2, 3]);
                     * // => [2, 3]
                     */
                    function rest(array) {
                        return drop(array, 1);
                    }

                    /**
                     * Creates a slice of `array` from `start` up to, but not including, `end`.
                     *
                     * **Note:** This method is used instead of `Array#slice` to support node
                     * lists in IE < 9 and to ensure dense arrays are returned.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to slice.
                     * @param {number} [start=0] The start position.
                     * @param {number} [end=array.length] The end position.
                     * @returns {Array} Returns the slice of `array`.
                     */
                    function slice(array, start, end) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return [];
                        }
                        if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
                            start = 0;
                            end = length;
                        }
                        return baseSlice(array, start, end);
                    }

                    /**
                     * Uses a binary search to determine the lowest index at which `value` should
                     * be inserted into `array` in order to maintain its sort order. If an iteratee
                     * function is provided it is invoked for `value` and each element of `array`
                     * to compute their sort ranking. The iteratee is bound to `thisArg` and
                     * invoked with one argument; (value).
                     *
                     * If a property name is provided for `iteratee` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `iteratee` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The sorted array to inspect.
                     * @param {*} value The value to evaluate.
                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {number} Returns the index at which `value` should be inserted
                     *  into `array`.
                     * @example
                     *
                     * _.sortedIndex([30, 50], 40);
                     * // => 1
                     *
                     * _.sortedIndex([4, 4, 5, 5], 5);
                     * // => 2
                     *
                     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
                     *
                     * // using an iteratee function
                     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
                     *   return this.data[word];
                     * }, dict);
                     * // => 1
                     *
                     * // using the `_.property` callback shorthand
                     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
                     * // => 1
                     */
                    var sortedIndex = createSortedIndex();

                    /**
                     * This method is like `_.sortedIndex` except that it returns the highest
                     * index at which `value` should be inserted into `array` in order to
                     * maintain its sort order.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The sorted array to inspect.
                     * @param {*} value The value to evaluate.
                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {number} Returns the index at which `value` should be inserted
                     *  into `array`.
                     * @example
                     *
                     * _.sortedLastIndex([4, 4, 5, 5], 5);
                     * // => 4
                     */
                    var sortedLastIndex = createSortedIndex(true);

                    /**
                     * Creates a slice of `array` with `n` elements taken from the beginning.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to query.
                     * @param {number} [n=1] The number of elements to take.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Array} Returns the slice of `array`.
                     * @example
                     *
                     * _.take([1, 2, 3]);
                     * // => [1]
                     *
                     * _.take([1, 2, 3], 2);
                     * // => [1, 2]
                     *
                     * _.take([1, 2, 3], 5);
                     * // => [1, 2, 3]
                     *
                     * _.take([1, 2, 3], 0);
                     * // => []
                     */
                    function take(array, n, guard) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return [];
                        }
                        if (guard ? isIterateeCall(array, n, guard) : n == null) {
                            n = 1;
                        }
                        return baseSlice(array, 0, n < 0 ? 0 : n);
                    }

                    /**
                     * Creates a slice of `array` with `n` elements taken from the end.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to query.
                     * @param {number} [n=1] The number of elements to take.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Array} Returns the slice of `array`.
                     * @example
                     *
                     * _.takeRight([1, 2, 3]);
                     * // => [3]
                     *
                     * _.takeRight([1, 2, 3], 2);
                     * // => [2, 3]
                     *
                     * _.takeRight([1, 2, 3], 5);
                     * // => [1, 2, 3]
                     *
                     * _.takeRight([1, 2, 3], 0);
                     * // => []
                     */
                    function takeRight(array, n, guard) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return [];
                        }
                        if (guard ? isIterateeCall(array, n, guard) : n == null) {
                            n = 1;
                        }
                        n = length - (+n || 0);
                        return baseSlice(array, n < 0 ? 0 : n);
                    }

                    /**
                     * Creates a slice of `array` with elements taken from the end. Elements are
                     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
                     * and invoked with three arguments: (value, index, array).
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to query.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {Array} Returns the slice of `array`.
                     * @example
                     *
                     * _.takeRightWhile([1, 2, 3], function(n) {
                     *   return n > 1;
                     * });
                     * // => [2, 3]
                     *
                     * var users = [
                     *   { 'user': 'barney',  'active': true },
                     *   { 'user': 'fred',    'active': false },
                     *   { 'user': 'pebbles', 'active': false }
                     * ];
                     *
                     * // using the `_.matches` callback shorthand
                     * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
                     * // => ['pebbles']
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
                     * // => ['fred', 'pebbles']
                     *
                     * // using the `_.property` callback shorthand
                     * _.pluck(_.takeRightWhile(users, 'active'), 'user');
                     * // => []
                     */
                    function takeRightWhile(array, predicate, thisArg) {
                        return (array && array.length) ?
                            baseWhile(array, getCallback(predicate, thisArg, 3), false, true) :
                            [];
                    }

                    /**
                     * Creates a slice of `array` with elements taken from the beginning. Elements
                     * are taken until `predicate` returns falsey. The predicate is bound to
                     * `thisArg` and invoked with three arguments: (value, index, array).
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to query.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {Array} Returns the slice of `array`.
                     * @example
                     *
                     * _.takeWhile([1, 2, 3], function(n) {
                     *   return n < 3;
                     * });
                     * // => [1, 2]
                     *
                     * var users = [
                     *   { 'user': 'barney',  'active': false },
                     *   { 'user': 'fred',    'active': false},
                     *   { 'user': 'pebbles', 'active': true }
                     * ];
                     *
                     * // using the `_.matches` callback shorthand
                     * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
                     * // => ['barney']
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.pluck(_.takeWhile(users, 'active', false), 'user');
                     * // => ['barney', 'fred']
                     *
                     * // using the `_.property` callback shorthand
                     * _.pluck(_.takeWhile(users, 'active'), 'user');
                     * // => []
                     */
                    function takeWhile(array, predicate, thisArg) {
                        return (array && array.length) ?
                            baseWhile(array, getCallback(predicate, thisArg, 3)) :
                            [];
                    }

                    /**
                     * Creates an array of unique values, in order, from all of the provided arrays
                     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                     * for equality comparisons.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {...Array} [arrays] The arrays to inspect.
                     * @returns {Array} Returns the new array of combined values.
                     * @example
                     *
                     * _.union([1, 2], [4, 2], [2, 1]);
                     * // => [1, 2, 4]
                     */
                    var union = restParam(function(arrays) {
                        return baseUniq(baseFlatten(arrays, false, true));
                    });

                    /**
                     * Creates a duplicate-free version of an array, using
                     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                     * for equality comparisons, in which only the first occurence of each element
                     * is kept. Providing `true` for `isSorted` performs a faster search algorithm
                     * for sorted arrays. If an iteratee function is provided it is invoked for
                     * each element in the array to generate the criterion by which uniqueness
                     * is computed. The `iteratee` is bound to `thisArg` and invoked with three
                     * arguments: (value, index, array).
                     *
                     * If a property name is provided for `iteratee` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `iteratee` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias unique
                     * @category Array
                     * @param {Array} array The array to inspect.
                     * @param {boolean} [isSorted] Specify the array is sorted.
                     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Array} Returns the new duplicate-value-free array.
                     * @example
                     *
                     * _.uniq([2, 1, 2]);
                     * // => [2, 1]
                     *
                     * // using `isSorted`
                     * _.uniq([1, 1, 2], true);
                     * // => [1, 2]
                     *
                     * // using an iteratee function
                     * _.uniq([1, 2.5, 1.5, 2], function(n) {
                     *   return this.floor(n);
                     * }, Math);
                     * // => [1, 2.5]
                     *
                     * // using the `_.property` callback shorthand
                     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
                     * // => [{ 'x': 1 }, { 'x': 2 }]
                     */
                    function uniq(array, isSorted, iteratee, thisArg) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return [];
                        }
                        if (isSorted != null && typeof isSorted != 'boolean') {
                            thisArg = iteratee;
                            iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
                            isSorted = false;
                        }
                        var callback = getCallback();
                        if (!(iteratee == null && callback === baseCallback)) {
                            iteratee = callback(iteratee, thisArg, 3);
                        }
                        return (isSorted && getIndexOf() == baseIndexOf) ?
                            sortedUniq(array, iteratee) :
                            baseUniq(array, iteratee);
                    }

                    /**
                     * This method is like `_.zip` except that it accepts an array of grouped
                     * elements and creates an array regrouping the elements to their pre-zip
                     * configuration.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array of grouped elements to process.
                     * @returns {Array} Returns the new array of regrouped elements.
                     * @example
                     *
                     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
                     * // => [['fred', 30, true], ['barney', 40, false]]
                     *
                     * _.unzip(zipped);
                     * // => [['fred', 'barney'], [30, 40], [true, false]]
                     */
                    function unzip(array) {
                        if (!(array && array.length)) {
                            return [];
                        }
                        var index = -1,
                            length = 0;

                        array = arrayFilter(array, function(group) {
                            if (isArrayLike(group)) {
                                length = nativeMax(group.length, length);
                                return true;
                            }
                        });
                        var result = Array(length);
                        while (++index < length) {
                            result[index] = arrayMap(array, baseProperty(index));
                        }
                        return result;
                    }

                    /**
                     * This method is like `_.unzip` except that it accepts an iteratee to specify
                     * how regrouped values should be combined. The `iteratee` is bound to `thisArg`
                     * and invoked with four arguments: (accumulator, value, index, group).
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array of grouped elements to process.
                     * @param {Function} [iteratee] The function to combine regrouped values.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Array} Returns the new array of regrouped elements.
                     * @example
                     *
                     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
                     * // => [[1, 10, 100], [2, 20, 200]]
                     *
                     * _.unzipWith(zipped, _.add);
                     * // => [3, 30, 300]
                     */
                    function unzipWith(array, iteratee, thisArg) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return [];
                        }
                        var result = unzip(array);
                        if (iteratee == null) {
                            return result;
                        }
                        iteratee = bindCallback(iteratee, thisArg, 4);
                        return arrayMap(result, function(group) {
                            return arrayReduce(group, iteratee, undefined, true);
                        });
                    }

                    /**
                     * Creates an array excluding all provided values using
                     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                     * for equality comparisons.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {Array} array The array to filter.
                     * @param {...*} [values] The values to exclude.
                     * @returns {Array} Returns the new array of filtered values.
                     * @example
                     *
                     * _.without([1, 2, 1, 3], 1, 2);
                     * // => [3]
                     */
                    var without = restParam(function(array, values) {
                        return isArrayLike(array) ?
                            baseDifference(array, values) :
                            [];
                    });

                    /**
                     * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
                     * of the provided arrays.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {...Array} [arrays] The arrays to inspect.
                     * @returns {Array} Returns the new array of values.
                     * @example
                     *
                     * _.xor([1, 2], [4, 2]);
                     * // => [1, 4]
                     */
                    function xor() {
                        var index = -1,
                            length = arguments.length;

                        while (++index < length) {
                            var array = arguments[index];
                            if (isArrayLike(array)) {
                                var result = result ?
                                    arrayPush(baseDifference(result, array), baseDifference(array, result)) :
                                    array;
                            }
                        }
                        return result ? baseUniq(result) : [];
                    }

                    /**
                     * Creates an array of grouped elements, the first of which contains the first
                     * elements of the given arrays, the second of which contains the second elements
                     * of the given arrays, and so on.
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {...Array} [arrays] The arrays to process.
                     * @returns {Array} Returns the new array of grouped elements.
                     * @example
                     *
                     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
                     * // => [['fred', 30, true], ['barney', 40, false]]
                     */
                    var zip = restParam(unzip);

                    /**
                     * The inverse of `_.pairs`; this method returns an object composed from arrays
                     * of property names and values. Provide either a single two dimensional array,
                     * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names
                     * and one of corresponding values.
                     *
                     * @static
                     * @memberOf _
                     * @alias object
                     * @category Array
                     * @param {Array} props The property names.
                     * @param {Array} [values=[]] The property values.
                     * @returns {Object} Returns the new object.
                     * @example
                     *
                     * _.zipObject([['fred', 30], ['barney', 40]]);
                     * // => { 'fred': 30, 'barney': 40 }
                     *
                     * _.zipObject(['fred', 'barney'], [30, 40]);
                     * // => { 'fred': 30, 'barney': 40 }
                     */
                    function zipObject(props, values) {
                        var index = -1,
                            length = props ? props.length : 0,
                            result = {};

                        if (length && !values && !isArray(props[0])) {
                            values = [];
                        }
                        while (++index < length) {
                            var key = props[index];
                            if (values) {
                                result[key] = values[index];
                            } else if (key) {
                                result[key[0]] = key[1];
                            }
                        }
                        return result;
                    }

                    /**
                     * This method is like `_.zip` except that it accepts an iteratee to specify
                     * how grouped values should be combined. The `iteratee` is bound to `thisArg`
                     * and invoked with four arguments: (accumulator, value, index, group).
                     *
                     * @static
                     * @memberOf _
                     * @category Array
                     * @param {...Array} [arrays] The arrays to process.
                     * @param {Function} [iteratee] The function to combine grouped values.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Array} Returns the new array of grouped elements.
                     * @example
                     *
                     * _.zipWith([1, 2], [10, 20], [100, 200], _.add);
                     * // => [111, 222]
                     */
                    var zipWith = restParam(function(arrays) {
                        var length = arrays.length,
                            iteratee = length > 2 ? arrays[length - 2] : undefined,
                            thisArg = length > 1 ? arrays[length - 1] : undefined;

                        if (length > 2 && typeof iteratee == 'function') {
                            length -= 2;
                        } else {
                            iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;
                            thisArg = undefined;
                        }
                        arrays.length = length;
                        return unzipWith(arrays, iteratee, thisArg);
                    });

                    /*------------------------------------------------------------------------*/

                    /**
                     * Creates a `lodash` object that wraps `value` with explicit method
                     * chaining enabled.
                     *
                     * @static
                     * @memberOf _
                     * @category Chain
                     * @param {*} value The value to wrap.
                     * @returns {Object} Returns the new `lodash` wrapper instance.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney',  'age': 36 },
                     *   { 'user': 'fred',    'age': 40 },
                     *   { 'user': 'pebbles', 'age': 1 }
                     * ];
                     *
                     * var youngest = _.chain(users)
                     *   .sortBy('age')
                     *   .map(function(chr) {
                     *     return chr.user + ' is ' + chr.age;
                     *   })
                     *   .first()
                     *   .value();
                     * // => 'pebbles is 1'
                     */
                    function chain(value) {
                        var result = lodash(value);
                        result.__chain__ = true;
                        return result;
                    }

                    /**
                     * This method invokes `interceptor` and returns `value`. The interceptor is
                     * bound to `thisArg` and invoked with one argument; (value). The purpose of
                     * this method is to "tap into" a method chain in order to perform operations
                     * on intermediate results within the chain.
                     *
                     * @static
                     * @memberOf _
                     * @category Chain
                     * @param {*} value The value to provide to `interceptor`.
                     * @param {Function} interceptor The function to invoke.
                     * @param {*} [thisArg] The `this` binding of `interceptor`.
                     * @returns {*} Returns `value`.
                     * @example
                     *
                     * _([1, 2, 3])
                     *  .tap(function(array) {
                     *    array.pop();
                     *  })
                     *  .reverse()
                     *  .value();
                     * // => [2, 1]
                     */
                    function tap(value, interceptor, thisArg) {
                        interceptor.call(thisArg, value);
                        return value;
                    }

                    /**
                     * This method is like `_.tap` except that it returns the result of `interceptor`.
                     *
                     * @static
                     * @memberOf _
                     * @category Chain
                     * @param {*} value The value to provide to `interceptor`.
                     * @param {Function} interceptor The function to invoke.
                     * @param {*} [thisArg] The `this` binding of `interceptor`.
                     * @returns {*} Returns the result of `interceptor`.
                     * @example
                     *
                     * _('  abc  ')
                     *  .chain()
                     *  .trim()
                     *  .thru(function(value) {
                     *    return [value];
                     *  })
                     *  .value();
                     * // => ['abc']
                     */
                    function thru(value, interceptor, thisArg) {
                        return interceptor.call(thisArg, value);
                    }

                    /**
                     * Enables explicit method chaining on the wrapper object.
                     *
                     * @name chain
                     * @memberOf _
                     * @category Chain
                     * @returns {Object} Returns the new `lodash` wrapper instance.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney', 'age': 36 },
                     *   { 'user': 'fred',   'age': 40 }
                     * ];
                     *
                     * // without explicit chaining
                     * _(users).first();
                     * // => { 'user': 'barney', 'age': 36 }
                     *
                     * // with explicit chaining
                     * _(users).chain()
                     *   .first()
                     *   .pick('user')
                     *   .value();
                     * // => { 'user': 'barney' }
                     */
                    function wrapperChain() {
                        return chain(this);
                    }

                    /**
                     * Executes the chained sequence and returns the wrapped result.
                     *
                     * @name commit
                     * @memberOf _
                     * @category Chain
                     * @returns {Object} Returns the new `lodash` wrapper instance.
                     * @example
                     *
                     * var array = [1, 2];
                     * var wrapped = _(array).push(3);
                     *
                     * console.log(array);
                     * // => [1, 2]
                     *
                     * wrapped = wrapped.commit();
                     * console.log(array);
                     * // => [1, 2, 3]
                     *
                     * wrapped.last();
                     * // => 3
                     *
                     * console.log(array);
                     * // => [1, 2, 3]
                     */
                    function wrapperCommit() {
                        return new LodashWrapper(this.value(), this.__chain__);
                    }

                    /**
                     * Creates a new array joining a wrapped array with any additional arrays
                     * and/or values.
                     *
                     * @name concat
                     * @memberOf _
                     * @category Chain
                     * @param {...*} [values] The values to concatenate.
                     * @returns {Array} Returns the new concatenated array.
                     * @example
                     *
                     * var array = [1];
                     * var wrapped = _(array).concat(2, [3], [[4]]);
                     *
                     * console.log(wrapped.value());
                     * // => [1, 2, 3, [4]]
                     *
                     * console.log(array);
                     * // => [1]
                     */
                    var wrapperConcat = restParam(function(values) {
                        values = baseFlatten(values);
                        return this.thru(function(array) {
                            return arrayConcat(isArray(array) ? array : [toObject(array)], values);
                        });
                    });

                    /**
                     * Creates a clone of the chained sequence planting `value` as the wrapped value.
                     *
                     * @name plant
                     * @memberOf _
                     * @category Chain
                     * @returns {Object} Returns the new `lodash` wrapper instance.
                     * @example
                     *
                     * var array = [1, 2];
                     * var wrapped = _(array).map(function(value) {
                     *   return Math.pow(value, 2);
                     * });
                     *
                     * var other = [3, 4];
                     * var otherWrapped = wrapped.plant(other);
                     *
                     * otherWrapped.value();
                     * // => [9, 16]
                     *
                     * wrapped.value();
                     * // => [1, 4]
                     */
                    function wrapperPlant(value) {
                        var result,
                            parent = this;

                        while (parent instanceof baseLodash) {
                            var clone = wrapperClone(parent);
                            if (result) {
                                previous.__wrapped__ = clone;
                            } else {
                                result = clone;
                            }
                            var previous = clone;
                            parent = parent.__wrapped__;
                        }
                        previous.__wrapped__ = value;
                        return result;
                    }

                    /**
                     * Reverses the wrapped array so the first element becomes the last, the
                     * second element becomes the second to last, and so on.
                     *
                     * **Note:** This method mutates the wrapped array.
                     *
                     * @name reverse
                     * @memberOf _
                     * @category Chain
                     * @returns {Object} Returns the new reversed `lodash` wrapper instance.
                     * @example
                     *
                     * var array = [1, 2, 3];
                     *
                     * _(array).reverse().value()
                     * // => [3, 2, 1]
                     *
                     * console.log(array);
                     * // => [3, 2, 1]
                     */
                    function wrapperReverse() {
                        var value = this.__wrapped__;

                        var interceptor = function(value) {
                            return (wrapped && wrapped.__dir__ < 0) ? value : value.reverse();
                        };
                        if (value instanceof LazyWrapper) {
                            var wrapped = value;
                            if (this.__actions__.length) {
                                wrapped = new LazyWrapper(this);
                            }
                            wrapped = wrapped.reverse();
                            wrapped.__actions__.push({
                                'func': thru,
                                'args': [interceptor],
                                'thisArg': undefined
                            });
                            return new LodashWrapper(wrapped, this.__chain__);
                        }
                        return this.thru(interceptor);
                    }

                    /**
                     * Produces the result of coercing the unwrapped value to a string.
                     *
                     * @name toString
                     * @memberOf _
                     * @category Chain
                     * @returns {string} Returns the coerced string value.
                     * @example
                     *
                     * _([1, 2, 3]).toString();
                     * // => '1,2,3'
                     */
                    function wrapperToString() {
                        return (this.value() + '');
                    }

                    /**
                     * Executes the chained sequence to extract the unwrapped value.
                     *
                     * @name value
                     * @memberOf _
                     * @alias run, toJSON, valueOf
                     * @category Chain
                     * @returns {*} Returns the resolved unwrapped value.
                     * @example
                     *
                     * _([1, 2, 3]).value();
                     * // => [1, 2, 3]
                     */
                    function wrapperValue() {
                        return baseWrapperValue(this.__wrapped__, this.__actions__);
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Creates an array of elements corresponding to the given keys, or indexes,
                     * of `collection`. Keys may be specified as individual arguments or as arrays
                     * of keys.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {...(number|number[]|string|string[])} [props] The property names
                     *  or indexes of elements to pick, specified individually or in arrays.
                     * @returns {Array} Returns the new array of picked elements.
                     * @example
                     *
                     * _.at(['a', 'b', 'c'], [0, 2]);
                     * // => ['a', 'c']
                     *
                     * _.at(['barney', 'fred', 'pebbles'], 0, 2);
                     * // => ['barney', 'pebbles']
                     */
                    var at = restParam(function(collection, props) {
                        return baseAt(collection, baseFlatten(props));
                    });

                    /**
                     * Creates an object composed of keys generated from the results of running
                     * each element of `collection` through `iteratee`. The corresponding value
                     * of each key is the number of times the key was returned by `iteratee`.
                     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
                     * (value, index|key, collection).
                     *
                     * If a property name is provided for `iteratee` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `iteratee` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Object} Returns the composed aggregate object.
                     * @example
                     *
                     * _.countBy([4.3, 6.1, 6.4], function(n) {
                     *   return Math.floor(n);
                     * });
                     * // => { '4': 1, '6': 2 }
                     *
                     * _.countBy([4.3, 6.1, 6.4], function(n) {
                     *   return this.floor(n);
                     * }, Math);
                     * // => { '4': 1, '6': 2 }
                     *
                     * _.countBy(['one', 'two', 'three'], 'length');
                     * // => { '3': 2, '5': 1 }
                     */
                    var countBy = createAggregator(function(result, value, key) {
                        hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
                    });

                    /**
                     * Checks if `predicate` returns truthy for **all** elements of `collection`.
                     * The predicate is bound to `thisArg` and invoked with three arguments:
                     * (value, index|key, collection).
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias all
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {boolean} Returns `true` if all elements pass the predicate check,
                     *  else `false`.
                     * @example
                     *
                     * _.every([true, 1, null, 'yes'], Boolean);
                     * // => false
                     *
                     * var users = [
                     *   { 'user': 'barney', 'active': false },
                     *   { 'user': 'fred',   'active': false }
                     * ];
                     *
                     * // using the `_.matches` callback shorthand
                     * _.every(users, { 'user': 'barney', 'active': false });
                     * // => false
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.every(users, 'active', false);
                     * // => true
                     *
                     * // using the `_.property` callback shorthand
                     * _.every(users, 'active');
                     * // => false
                     */
                    function every(collection, predicate, thisArg) {
                        var func = isArray(collection) ? arrayEvery : baseEvery;
                        if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
                            predicate = undefined;
                        }
                        if (typeof predicate != 'function' || thisArg !== undefined) {
                            predicate = getCallback(predicate, thisArg, 3);
                        }
                        return func(collection, predicate);
                    }

                    /**
                     * Iterates over elements of `collection`, returning an array of all elements
                     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
                     * invoked with three arguments: (value, index|key, collection).
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias select
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {Array} Returns the new filtered array.
                     * @example
                     *
                     * _.filter([4, 5, 6], function(n) {
                     *   return n % 2 == 0;
                     * });
                     * // => [4, 6]
                     *
                     * var users = [
                     *   { 'user': 'barney', 'age': 36, 'active': true },
                     *   { 'user': 'fred',   'age': 40, 'active': false }
                     * ];
                     *
                     * // using the `_.matches` callback shorthand
                     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
                     * // => ['barney']
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.pluck(_.filter(users, 'active', false), 'user');
                     * // => ['fred']
                     *
                     * // using the `_.property` callback shorthand
                     * _.pluck(_.filter(users, 'active'), 'user');
                     * // => ['barney']
                     */
                    function filter(collection, predicate, thisArg) {
                        var func = isArray(collection) ? arrayFilter : baseFilter;
                        predicate = getCallback(predicate, thisArg, 3);
                        return func(collection, predicate);
                    }

                    /**
                     * Iterates over elements of `collection`, returning the first element
                     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
                     * invoked with three arguments: (value, index|key, collection).
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias detect
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to search.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {*} Returns the matched element, else `undefined`.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney',  'age': 36, 'active': true },
                     *   { 'user': 'fred',    'age': 40, 'active': false },
                     *   { 'user': 'pebbles', 'age': 1,  'active': true }
                     * ];
                     *
                     * _.result(_.find(users, function(chr) {
                     *   return chr.age < 40;
                     * }), 'user');
                     * // => 'barney'
                     *
                     * // using the `_.matches` callback shorthand
                     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
                     * // => 'pebbles'
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.result(_.find(users, 'active', false), 'user');
                     * // => 'fred'
                     *
                     * // using the `_.property` callback shorthand
                     * _.result(_.find(users, 'active'), 'user');
                     * // => 'barney'
                     */
                    var find = createFind(baseEach);

                    /**
                     * This method is like `_.find` except that it iterates over elements of
                     * `collection` from right to left.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to search.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {*} Returns the matched element, else `undefined`.
                     * @example
                     *
                     * _.findLast([1, 2, 3, 4], function(n) {
                     *   return n % 2 == 1;
                     * });
                     * // => 3
                     */
                    var findLast = createFind(baseEachRight, true);

                    /**
                     * Performs a deep comparison between each element in `collection` and the
                     * source object, returning the first element that has equivalent property
                     * values.
                     *
                     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
                     * numbers, `Object` objects, regexes, and strings. Objects are compared by
                     * their own, not inherited, enumerable properties. For comparing a single
                     * own or inherited property value see `_.matchesProperty`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to search.
                     * @param {Object} source The object of property values to match.
                     * @returns {*} Returns the matched element, else `undefined`.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney', 'age': 36, 'active': true },
                     *   { 'user': 'fred',   'age': 40, 'active': false }
                     * ];
                     *
                     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
                     * // => 'barney'
                     *
                     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
                     * // => 'fred'
                     */
                    function findWhere(collection, source) {
                        return find(collection, baseMatches(source));
                    }

                    /**
                     * Iterates over elements of `collection` invoking `iteratee` for each element.
                     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
                     * (value, index|key, collection). Iteratee functions may exit iteration early
                     * by explicitly returning `false`.
                     *
                     * **Note:** As with other "Collections" methods, objects with a "length" property
                     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
                     * may be used for object iteration.
                     *
                     * @static
                     * @memberOf _
                     * @alias each
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Array|Object|string} Returns `collection`.
                     * @example
                     *
                     * _([1, 2]).forEach(function(n) {
                     *   console.log(n);
                     * }).value();
                     * // => logs each value from left to right and returns the array
                     *
                     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
                     *   console.log(n, key);
                     * });
                     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
                     */
                    var forEach = createForEach(arrayEach, baseEach);

                    /**
                     * This method is like `_.forEach` except that it iterates over elements of
                     * `collection` from right to left.
                     *
                     * @static
                     * @memberOf _
                     * @alias eachRight
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Array|Object|string} Returns `collection`.
                     * @example
                     *
                     * _([1, 2]).forEachRight(function(n) {
                     *   console.log(n);
                     * }).value();
                     * // => logs each value from right to left and returns the array
                     */
                    var forEachRight = createForEach(arrayEachRight, baseEachRight);

                    /**
                     * Creates an object composed of keys generated from the results of running
                     * each element of `collection` through `iteratee`. The corresponding value
                     * of each key is an array of the elements responsible for generating the key.
                     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
                     * (value, index|key, collection).
                     *
                     * If a property name is provided for `iteratee` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `iteratee` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Object} Returns the composed aggregate object.
                     * @example
                     *
                     * _.groupBy([4.2, 6.1, 6.4], function(n) {
                     *   return Math.floor(n);
                     * });
                     * // => { '4': [4.2], '6': [6.1, 6.4] }
                     *
                     * _.groupBy([4.2, 6.1, 6.4], function(n) {
                     *   return this.floor(n);
                     * }, Math);
                     * // => { '4': [4.2], '6': [6.1, 6.4] }
                     *
                     * // using the `_.property` callback shorthand
                     * _.groupBy(['one', 'two', 'three'], 'length');
                     * // => { '3': ['one', 'two'], '5': ['three'] }
                     */
                    var groupBy = createAggregator(function(result, value, key) {
                        if (hasOwnProperty.call(result, key)) {
                            result[key].push(value);
                        } else {
                            result[key] = [value];
                        }
                    });

                    /**
                     * Checks if `value` is in `collection` using
                     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
                     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
                     * from the end of `collection`.
                     *
                     * @static
                     * @memberOf _
                     * @alias contains, include
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to search.
                     * @param {*} target The value to search for.
                     * @param {number} [fromIndex=0] The index to search from.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
                     * @returns {boolean} Returns `true` if a matching element is found, else `false`.
                     * @example
                     *
                     * _.includes([1, 2, 3], 1);
                     * // => true
                     *
                     * _.includes([1, 2, 3], 1, 2);
                     * // => false
                     *
                     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
                     * // => true
                     *
                     * _.includes('pebbles', 'eb');
                     * // => true
                     */
                    function includes(collection, target, fromIndex, guard) {
                        var length = collection ? getLength(collection) : 0;
                        if (!isLength(length)) {
                            collection = values(collection);
                            length = collection.length;
                        }
                        if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
                            fromIndex = 0;
                        } else {
                            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
                        }
                        return (typeof collection == 'string' || !isArray(collection) && isString(collection)) ?
                            (fromIndex <= length && collection.indexOf(target, fromIndex) > -1) :
                            (!!length && getIndexOf(collection, target, fromIndex) > -1);
                    }

                    /**
                     * Creates an object composed of keys generated from the results of running
                     * each element of `collection` through `iteratee`. The corresponding value
                     * of each key is the last element responsible for generating the key. The
                     * iteratee function is bound to `thisArg` and invoked with three arguments:
                     * (value, index|key, collection).
                     *
                     * If a property name is provided for `iteratee` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `iteratee` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Object} Returns the composed aggregate object.
                     * @example
                     *
                     * var keyData = [
                     *   { 'dir': 'left', 'code': 97 },
                     *   { 'dir': 'right', 'code': 100 }
                     * ];
                     *
                     * _.indexBy(keyData, 'dir');
                     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
                     *
                     * _.indexBy(keyData, function(object) {
                     *   return String.fromCharCode(object.code);
                     * });
                     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
                     *
                     * _.indexBy(keyData, function(object) {
                     *   return this.fromCharCode(object.code);
                     * }, String);
                     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
                     */
                    var indexBy = createAggregator(function(result, value, key) {
                        result[key] = value;
                    });

                    /**
                     * Invokes the method at `path` of each element in `collection`, returning
                     * an array of the results of each invoked method. Any additional arguments
                     * are provided to each invoked method. If `methodName` is a function it is
                     * invoked for, and `this` bound to, each element in `collection`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Array|Function|string} path The path of the method to invoke or
                     *  the function invoked per iteration.
                     * @param {...*} [args] The arguments to invoke the method with.
                     * @returns {Array} Returns the array of results.
                     * @example
                     *
                     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
                     * // => [[1, 5, 7], [1, 2, 3]]
                     *
                     * _.invoke([123, 456], String.prototype.split, '');
                     * // => [['1', '2', '3'], ['4', '5', '6']]
                     */
                    var invoke = restParam(function(collection, path, args) {
                        var index = -1,
                            isFunc = typeof path == 'function',
                            isProp = isKey(path),
                            result = isArrayLike(collection) ? Array(collection.length) : [];

                        baseEach(collection, function(value) {
                            var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
                            result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
                        });
                        return result;
                    });

                    /**
                     * Creates an array of values by running each element in `collection` through
                     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
                     * arguments: (value, index|key, collection).
                     *
                     * If a property name is provided for `iteratee` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `iteratee` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * Many lodash methods are guarded to work as iteratees for methods like
                     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
                     *
                     * The guarded methods are:
                     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
                     * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
                     * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
                     * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
                     * `sum`, `uniq`, and `words`
                     *
                     * @static
                     * @memberOf _
                     * @alias collect
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Array} Returns the new mapped array.
                     * @example
                     *
                     * function timesThree(n) {
                     *   return n * 3;
                     * }
                     *
                     * _.map([1, 2], timesThree);
                     * // => [3, 6]
                     *
                     * _.map({ 'a': 1, 'b': 2 }, timesThree);
                     * // => [3, 6] (iteration order is not guaranteed)
                     *
                     * var users = [
                     *   { 'user': 'barney' },
                     *   { 'user': 'fred' }
                     * ];
                     *
                     * // using the `_.property` callback shorthand
                     * _.map(users, 'user');
                     * // => ['barney', 'fred']
                     */
                    function map(collection, iteratee, thisArg) {
                        var func = isArray(collection) ? arrayMap : baseMap;
                        iteratee = getCallback(iteratee, thisArg, 3);
                        return func(collection, iteratee);
                    }

                    /**
                     * Creates an array of elements split into two groups, the first of which
                     * contains elements `predicate` returns truthy for, while the second of which
                     * contains elements `predicate` returns falsey for. The predicate is bound
                     * to `thisArg` and invoked with three arguments: (value, index|key, collection).
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {Array} Returns the array of grouped elements.
                     * @example
                     *
                     * _.partition([1, 2, 3], function(n) {
                     *   return n % 2;
                     * });
                     * // => [[1, 3], [2]]
                     *
                     * _.partition([1.2, 2.3, 3.4], function(n) {
                     *   return this.floor(n) % 2;
                     * }, Math);
                     * // => [[1.2, 3.4], [2.3]]
                     *
                     * var users = [
                     *   { 'user': 'barney',  'age': 36, 'active': false },
                     *   { 'user': 'fred',    'age': 40, 'active': true },
                     *   { 'user': 'pebbles', 'age': 1,  'active': false }
                     * ];
                     *
                     * var mapper = function(array) {
                     *   return _.pluck(array, 'user');
                     * };
                     *
                     * // using the `_.matches` callback shorthand
                     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
                     * // => [['pebbles'], ['barney', 'fred']]
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.map(_.partition(users, 'active', false), mapper);
                     * // => [['barney', 'pebbles'], ['fred']]
                     *
                     * // using the `_.property` callback shorthand
                     * _.map(_.partition(users, 'active'), mapper);
                     * // => [['fred'], ['barney', 'pebbles']]
                     */
                    var partition = createAggregator(function(result, value, key) {
                        result[key ? 0 : 1].push(value);
                    }, function() {
                        return [
                            [],
                            []
                        ];
                    });

                    /**
                     * Gets the property value of `path` from all elements in `collection`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Array|string} path The path of the property to pluck.
                     * @returns {Array} Returns the property values.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney', 'age': 36 },
                     *   { 'user': 'fred',   'age': 40 }
                     * ];
                     *
                     * _.pluck(users, 'user');
                     * // => ['barney', 'fred']
                     *
                     * var userIndex = _.indexBy(users, 'user');
                     * _.pluck(userIndex, 'age');
                     * // => [36, 40] (iteration order is not guaranteed)
                     */
                    function pluck(collection, path) {
                        return map(collection, property(path));
                    }

                    /**
                     * Reduces `collection` to a value which is the accumulated result of running
                     * each element in `collection` through `iteratee`, where each successive
                     * invocation is supplied the return value of the previous. If `accumulator`
                     * is not provided the first element of `collection` is used as the initial
                     * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:
                     * (accumulator, value, index|key, collection).
                     *
                     * Many lodash methods are guarded to work as iteratees for methods like
                     * `_.reduce`, `_.reduceRight`, and `_.transform`.
                     *
                     * The guarded methods are:
                     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,
                     * and `sortByOrder`
                     *
                     * @static
                     * @memberOf _
                     * @alias foldl, inject
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [accumulator] The initial value.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {*} Returns the accumulated value.
                     * @example
                     *
                     * _.reduce([1, 2], function(total, n) {
                     *   return total + n;
                     * });
                     * // => 3
                     *
                     * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
                     *   result[key] = n * 3;
                     *   return result;
                     * }, {});
                     * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
                     */
                    var reduce = createReduce(arrayReduce, baseEach);

                    /**
                     * This method is like `_.reduce` except that it iterates over elements of
                     * `collection` from right to left.
                     *
                     * @static
                     * @memberOf _
                     * @alias foldr
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [accumulator] The initial value.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {*} Returns the accumulated value.
                     * @example
                     *
                     * var array = [[0, 1], [2, 3], [4, 5]];
                     *
                     * _.reduceRight(array, function(flattened, other) {
                     *   return flattened.concat(other);
                     * }, []);
                     * // => [4, 5, 2, 3, 0, 1]
                     */
                    var reduceRight = createReduce(arrayReduceRight, baseEachRight);

                    /**
                     * The opposite of `_.filter`; this method returns the elements of `collection`
                     * that `predicate` does **not** return truthy for.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {Array} Returns the new filtered array.
                     * @example
                     *
                     * _.reject([1, 2, 3, 4], function(n) {
                     *   return n % 2 == 0;
                     * });
                     * // => [1, 3]
                     *
                     * var users = [
                     *   { 'user': 'barney', 'age': 36, 'active': false },
                     *   { 'user': 'fred',   'age': 40, 'active': true }
                     * ];
                     *
                     * // using the `_.matches` callback shorthand
                     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
                     * // => ['barney']
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.pluck(_.reject(users, 'active', false), 'user');
                     * // => ['fred']
                     *
                     * // using the `_.property` callback shorthand
                     * _.pluck(_.reject(users, 'active'), 'user');
                     * // => ['barney']
                     */
                    function reject(collection, predicate, thisArg) {
                        var func = isArray(collection) ? arrayFilter : baseFilter;
                        predicate = getCallback(predicate, thisArg, 3);
                        return func(collection, function(value, index, collection) {
                            return !predicate(value, index, collection);
                        });
                    }

                    /**
                     * Gets a random element or `n` random elements from a collection.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to sample.
                     * @param {number} [n] The number of elements to sample.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {*} Returns the random sample(s).
                     * @example
                     *
                     * _.sample([1, 2, 3, 4]);
                     * // => 2
                     *
                     * _.sample([1, 2, 3, 4], 2);
                     * // => [3, 1]
                     */
                    function sample(collection, n, guard) {
                        if (guard ? isIterateeCall(collection, n, guard) : n == null) {
                            collection = toIterable(collection);
                            var length = collection.length;
                            return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
                        }
                        var index = -1,
                            result = toArray(collection),
                            length = result.length,
                            lastIndex = length - 1;

                        n = nativeMin(n < 0 ? 0 : (+n || 0), length);
                        while (++index < n) {
                            var rand = baseRandom(index, lastIndex),
                                value = result[rand];

                            result[rand] = result[index];
                            result[index] = value;
                        }
                        result.length = n;
                        return result;
                    }

                    /**
                     * Creates an array of shuffled values, using a version of the
                     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to shuffle.
                     * @returns {Array} Returns the new shuffled array.
                     * @example
                     *
                     * _.shuffle([1, 2, 3, 4]);
                     * // => [4, 1, 3, 2]
                     */
                    function shuffle(collection) {
                        return sample(collection, POSITIVE_INFINITY);
                    }

                    /**
                     * Gets the size of `collection` by returning its length for array-like
                     * values or the number of own enumerable properties for objects.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to inspect.
                     * @returns {number} Returns the size of `collection`.
                     * @example
                     *
                     * _.size([1, 2, 3]);
                     * // => 3
                     *
                     * _.size({ 'a': 1, 'b': 2 });
                     * // => 2
                     *
                     * _.size('pebbles');
                     * // => 7
                     */
                    function size(collection) {
                        var length = collection ? getLength(collection) : 0;
                        return isLength(length) ? length : keys(collection).length;
                    }

                    /**
                     * Checks if `predicate` returns truthy for **any** element of `collection`.
                     * The function returns as soon as it finds a passing value and does not iterate
                     * over the entire collection. The predicate is bound to `thisArg` and invoked
                     * with three arguments: (value, index|key, collection).
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias any
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {boolean} Returns `true` if any element passes the predicate check,
                     *  else `false`.
                     * @example
                     *
                     * _.some([null, 0, 'yes', false], Boolean);
                     * // => true
                     *
                     * var users = [
                     *   { 'user': 'barney', 'active': true },
                     *   { 'user': 'fred',   'active': false }
                     * ];
                     *
                     * // using the `_.matches` callback shorthand
                     * _.some(users, { 'user': 'barney', 'active': false });
                     * // => false
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.some(users, 'active', false);
                     * // => true
                     *
                     * // using the `_.property` callback shorthand
                     * _.some(users, 'active');
                     * // => true
                     */
                    function some(collection, predicate, thisArg) {
                        var func = isArray(collection) ? arraySome : baseSome;
                        if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
                            predicate = undefined;
                        }
                        if (typeof predicate != 'function' || thisArg !== undefined) {
                            predicate = getCallback(predicate, thisArg, 3);
                        }
                        return func(collection, predicate);
                    }

                    /**
                     * Creates an array of elements, sorted in ascending order by the results of
                     * running each element in a collection through `iteratee`. This method performs
                     * a stable sort, that is, it preserves the original sort order of equal elements.
                     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
                     * (value, index|key, collection).
                     *
                     * If a property name is provided for `iteratee` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `iteratee` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Array} Returns the new sorted array.
                     * @example
                     *
                     * _.sortBy([1, 2, 3], function(n) {
                     *   return Math.sin(n);
                     * });
                     * // => [3, 1, 2]
                     *
                     * _.sortBy([1, 2, 3], function(n) {
                     *   return this.sin(n);
                     * }, Math);
                     * // => [3, 1, 2]
                     *
                     * var users = [
                     *   { 'user': 'fred' },
                     *   { 'user': 'pebbles' },
                     *   { 'user': 'barney' }
                     * ];
                     *
                     * // using the `_.property` callback shorthand
                     * _.pluck(_.sortBy(users, 'user'), 'user');
                     * // => ['barney', 'fred', 'pebbles']
                     */
                    function sortBy(collection, iteratee, thisArg) {
                        if (collection == null) {
                            return [];
                        }
                        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
                            iteratee = undefined;
                        }
                        var index = -1;
                        iteratee = getCallback(iteratee, thisArg, 3);

                        var result = baseMap(collection, function(value, key, collection) {
                            return {
                                'criteria': iteratee(value, key, collection),
                                'index': ++index,
                                'value': value
                            };
                        });
                        return baseSortBy(result, compareAscending);
                    }

                    /**
                     * This method is like `_.sortBy` except that it can sort by multiple iteratees
                     * or property names.
                     *
                     * If a property name is provided for an iteratee the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If an object is provided for an iteratee the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {...(Function|Function[]|Object|Object[]|string|string[])} iteratees
                     *  The iteratees to sort by, specified as individual values or arrays of values.
                     * @returns {Array} Returns the new sorted array.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'fred',   'age': 48 },
                     *   { 'user': 'barney', 'age': 36 },
                     *   { 'user': 'fred',   'age': 42 },
                     *   { 'user': 'barney', 'age': 34 }
                     * ];
                     *
                     * _.map(_.sortByAll(users, ['user', 'age']), _.values);
                     * // => [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]
                     *
                     * _.map(_.sortByAll(users, 'user', function(chr) {
                     *   return Math.floor(chr.age / 10);
                     * }), _.values);
                     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
                     */
                    var sortByAll = restParam(function(collection, iteratees) {
                        if (collection == null) {
                            return [];
                        }
                        var guard = iteratees[2];
                        if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
                            iteratees.length = 1;
                        }
                        return baseSortByOrder(collection, baseFlatten(iteratees), []);
                    });

                    /**
                     * This method is like `_.sortByAll` except that it allows specifying the
                     * sort orders of the iteratees to sort by. If `orders` is unspecified, all
                     * values are sorted in ascending order. Otherwise, a value is sorted in
                     * ascending order if its corresponding order is "asc", and descending if "desc".
                     *
                     * If a property name is provided for an iteratee the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If an object is provided for an iteratee the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
                     * @param {boolean[]} [orders] The sort orders of `iteratees`.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
                     * @returns {Array} Returns the new sorted array.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'fred',   'age': 48 },
                     *   { 'user': 'barney', 'age': 34 },
                     *   { 'user': 'fred',   'age': 42 },
                     *   { 'user': 'barney', 'age': 36 }
                     * ];
                     *
                     * // sort by `user` in ascending order and by `age` in descending order
                     * _.map(_.sortByOrder(users, ['user', 'age'], ['asc', 'desc']), _.values);
                     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
                     */
                    function sortByOrder(collection, iteratees, orders, guard) {
                        if (collection == null) {
                            return [];
                        }
                        if (guard && isIterateeCall(iteratees, orders, guard)) {
                            orders = undefined;
                        }
                        if (!isArray(iteratees)) {
                            iteratees = iteratees == null ? [] : [iteratees];
                        }
                        if (!isArray(orders)) {
                            orders = orders == null ? [] : [orders];
                        }
                        return baseSortByOrder(collection, iteratees, orders);
                    }

                    /**
                     * Performs a deep comparison between each element in `collection` and the
                     * source object, returning an array of all elements that have equivalent
                     * property values.
                     *
                     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
                     * numbers, `Object` objects, regexes, and strings. Objects are compared by
                     * their own, not inherited, enumerable properties. For comparing a single
                     * own or inherited property value see `_.matchesProperty`.
                     *
                     * @static
                     * @memberOf _
                     * @category Collection
                     * @param {Array|Object|string} collection The collection to search.
                     * @param {Object} source The object of property values to match.
                     * @returns {Array} Returns the new filtered array.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
                     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
                     * ];
                     *
                     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
                     * // => ['barney']
                     *
                     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
                     * // => ['fred']
                     */
                    function where(collection, source) {
                        return filter(collection, baseMatches(source));
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Gets the number of milliseconds that have elapsed since the Unix epoch
                     * (1 January 1970 00:00:00 UTC).
                     *
                     * @static
                     * @memberOf _
                     * @category Date
                     * @example
                     *
                     * _.defer(function(stamp) {
                     *   console.log(_.now() - stamp);
                     * }, _.now());
                     * // => logs the number of milliseconds it took for the deferred function to be invoked
                     */
                    var now = nativeNow || function() {
                        return new Date().getTime();
                    };

                    /*------------------------------------------------------------------------*/

                    /**
                     * The opposite of `_.before`; this method creates a function that invokes
                     * `func` once it is called `n` or more times.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {number} n The number of calls before `func` is invoked.
                     * @param {Function} func The function to restrict.
                     * @returns {Function} Returns the new restricted function.
                     * @example
                     *
                     * var saves = ['profile', 'settings'];
                     *
                     * var done = _.after(saves.length, function() {
                     *   console.log('done saving!');
                     * });
                     *
                     * _.forEach(saves, function(type) {
                     *   asyncSave({ 'type': type, 'complete': done });
                     * });
                     * // => logs 'done saving!' after the two async saves have completed
                     */
                    function after(n, func) {
                        if (typeof func != 'function') {
                            if (typeof n == 'function') {
                                var temp = n;
                                n = func;
                                func = temp;
                            } else {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                        }
                        n = nativeIsFinite(n = +n) ? n : 0;
                        return function() {
                            if (--n < 1) {
                                return func.apply(this, arguments);
                            }
                        };
                    }

                    /**
                     * Creates a function that accepts up to `n` arguments ignoring any
                     * additional arguments.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to cap arguments for.
                     * @param {number} [n=func.length] The arity cap.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
                     * // => [6, 8, 10]
                     */
                    function ary(func, n, guard) {
                        if (guard && isIterateeCall(func, n, guard)) {
                            n = undefined;
                        }
                        n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
                        return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
                    }

                    /**
                     * Creates a function that invokes `func`, with the `this` binding and arguments
                     * of the created function, while it is called less than `n` times. Subsequent
                     * calls to the created function return the result of the last `func` invocation.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {number} n The number of calls at which `func` is no longer invoked.
                     * @param {Function} func The function to restrict.
                     * @returns {Function} Returns the new restricted function.
                     * @example
                     *
                     * jQuery('#add').on('click', _.before(5, addContactToList));
                     * // => allows adding up to 4 contacts to the list
                     */
                    function before(n, func) {
                        var result;
                        if (typeof func != 'function') {
                            if (typeof n == 'function') {
                                var temp = n;
                                n = func;
                                func = temp;
                            } else {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                        }
                        return function() {
                            if (--n > 0) {
                                result = func.apply(this, arguments);
                            }
                            if (n <= 1) {
                                func = undefined;
                            }
                            return result;
                        };
                    }

                    /**
                     * Creates a function that invokes `func` with the `this` binding of `thisArg`
                     * and prepends any additional `_.bind` arguments to those provided to the
                     * bound function.
                     *
                     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
                     * may be used as a placeholder for partially applied arguments.
                     *
                     * **Note:** Unlike native `Function#bind` this method does not set the "length"
                     * property of bound functions.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to bind.
                     * @param {*} thisArg The `this` binding of `func`.
                     * @param {...*} [partials] The arguments to be partially applied.
                     * @returns {Function} Returns the new bound function.
                     * @example
                     *
                     * var greet = function(greeting, punctuation) {
                     *   return greeting + ' ' + this.user + punctuation;
                     * };
                     *
                     * var object = { 'user': 'fred' };
                     *
                     * var bound = _.bind(greet, object, 'hi');
                     * bound('!');
                     * // => 'hi fred!'
                     *
                     * // using placeholders
                     * var bound = _.bind(greet, object, _, '!');
                     * bound('hi');
                     * // => 'hi fred!'
                     */
                    var bind = restParam(function(func, thisArg, partials) {
                        var bitmask = BIND_FLAG;
                        if (partials.length) {
                            var holders = replaceHolders(partials, bind.placeholder);
                            bitmask |= PARTIAL_FLAG;
                        }
                        return createWrapper(func, bitmask, thisArg, partials, holders);
                    });

                    /**
                     * Binds methods of an object to the object itself, overwriting the existing
                     * method. Method names may be specified as individual arguments or as arrays
                     * of method names. If no method names are provided all enumerable function
                     * properties, own and inherited, of `object` are bound.
                     *
                     * **Note:** This method does not set the "length" property of bound functions.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Object} object The object to bind and assign the bound methods to.
                     * @param {...(string|string[])} [methodNames] The object method names to bind,
                     *  specified as individual method names or arrays of method names.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * var view = {
                     *   'label': 'docs',
                     *   'onClick': function() {
                     *     console.log('clicked ' + this.label);
                     *   }
                     * };
                     *
                     * _.bindAll(view);
                     * jQuery('#docs').on('click', view.onClick);
                     * // => logs 'clicked docs' when the element is clicked
                     */
                    var bindAll = restParam(function(object, methodNames) {
                        methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);

                        var index = -1,
                            length = methodNames.length;

                        while (++index < length) {
                            var key = methodNames[index];
                            object[key] = createWrapper(object[key], BIND_FLAG, object);
                        }
                        return object;
                    });

                    /**
                     * Creates a function that invokes the method at `object[key]` and prepends
                     * any additional `_.bindKey` arguments to those provided to the bound function.
                     *
                     * This method differs from `_.bind` by allowing bound functions to reference
                     * methods that may be redefined or don't yet exist.
                     * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
                     * for more details.
                     *
                     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
                     * builds, may be used as a placeholder for partially applied arguments.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Object} object The object the method belongs to.
                     * @param {string} key The key of the method.
                     * @param {...*} [partials] The arguments to be partially applied.
                     * @returns {Function} Returns the new bound function.
                     * @example
                     *
                     * var object = {
                     *   'user': 'fred',
                     *   'greet': function(greeting, punctuation) {
                     *     return greeting + ' ' + this.user + punctuation;
                     *   }
                     * };
                     *
                     * var bound = _.bindKey(object, 'greet', 'hi');
                     * bound('!');
                     * // => 'hi fred!'
                     *
                     * object.greet = function(greeting, punctuation) {
                     *   return greeting + 'ya ' + this.user + punctuation;
                     * };
                     *
                     * bound('!');
                     * // => 'hiya fred!'
                     *
                     * // using placeholders
                     * var bound = _.bindKey(object, 'greet', _, '!');
                     * bound('hi');
                     * // => 'hiya fred!'
                     */
                    var bindKey = restParam(function(object, key, partials) {
                        var bitmask = BIND_FLAG | BIND_KEY_FLAG;
                        if (partials.length) {
                            var holders = replaceHolders(partials, bindKey.placeholder);
                            bitmask |= PARTIAL_FLAG;
                        }
                        return createWrapper(key, bitmask, object, partials, holders);
                    });

                    /**
                     * Creates a function that accepts one or more arguments of `func` that when
                     * called either invokes `func` returning its result, if all `func` arguments
                     * have been provided, or returns a function that accepts one or more of the
                     * remaining `func` arguments, and so on. The arity of `func` may be specified
                     * if `func.length` is not sufficient.
                     *
                     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
                     * may be used as a placeholder for provided arguments.
                     *
                     * **Note:** This method does not set the "length" property of curried functions.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to curry.
                     * @param {number} [arity=func.length] The arity of `func`.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Function} Returns the new curried function.
                     * @example
                     *
                     * var abc = function(a, b, c) {
                     *   return [a, b, c];
                     * };
                     *
                     * var curried = _.curry(abc);
                     *
                     * curried(1)(2)(3);
                     * // => [1, 2, 3]
                     *
                     * curried(1, 2)(3);
                     * // => [1, 2, 3]
                     *
                     * curried(1, 2, 3);
                     * // => [1, 2, 3]
                     *
                     * // using placeholders
                     * curried(1)(_, 3)(2);
                     * // => [1, 2, 3]
                     */
                    var curry = createCurry(CURRY_FLAG);

                    /**
                     * This method is like `_.curry` except that arguments are applied to `func`
                     * in the manner of `_.partialRight` instead of `_.partial`.
                     *
                     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
                     * builds, may be used as a placeholder for provided arguments.
                     *
                     * **Note:** This method does not set the "length" property of curried functions.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to curry.
                     * @param {number} [arity=func.length] The arity of `func`.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Function} Returns the new curried function.
                     * @example
                     *
                     * var abc = function(a, b, c) {
                     *   return [a, b, c];
                     * };
                     *
                     * var curried = _.curryRight(abc);
                     *
                     * curried(3)(2)(1);
                     * // => [1, 2, 3]
                     *
                     * curried(2, 3)(1);
                     * // => [1, 2, 3]
                     *
                     * curried(1, 2, 3);
                     * // => [1, 2, 3]
                     *
                     * // using placeholders
                     * curried(3)(1, _)(2);
                     * // => [1, 2, 3]
                     */
                    var curryRight = createCurry(CURRY_RIGHT_FLAG);

                    /**
                     * Creates a debounced function that delays invoking `func` until after `wait`
                     * milliseconds have elapsed since the last time the debounced function was
                     * invoked. The debounced function comes with a `cancel` method to cancel
                     * delayed invocations. Provide an options object to indicate that `func`
                     * should be invoked on the leading and/or trailing edge of the `wait` timeout.
                     * Subsequent calls to the debounced function return the result of the last
                     * `func` invocation.
                     *
                     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
                     * on the trailing edge of the timeout only if the the debounced function is
                     * invoked more than once during the `wait` timeout.
                     *
                     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
                     * for details over the differences between `_.debounce` and `_.throttle`.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to debounce.
                     * @param {number} [wait=0] The number of milliseconds to delay.
                     * @param {Object} [options] The options object.
                     * @param {boolean} [options.leading=false] Specify invoking on the leading
                     *  edge of the timeout.
                     * @param {number} [options.maxWait] The maximum time `func` is allowed to be
                     *  delayed before it is invoked.
                     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
                     *  edge of the timeout.
                     * @returns {Function} Returns the new debounced function.
                     * @example
                     *
                     * // avoid costly calculations while the window size is in flux
                     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
                     *
                     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
                     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
                     *   'leading': true,
                     *   'trailing': false
                     * }));
                     *
                     * // ensure `batchLog` is invoked once after 1 second of debounced calls
                     * var source = new EventSource('/stream');
                     * jQuery(source).on('message', _.debounce(batchLog, 250, {
                     *   'maxWait': 1000
                     * }));
                     *
                     * // cancel a debounced call
                     * var todoChanges = _.debounce(batchLog, 1000);
                     * Object.observe(models.todo, todoChanges);
                     *
                     * Object.observe(models, function(changes) {
                     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
                     *     todoChanges.cancel();
                     *   }
                     * }, ['delete']);
                     *
                     * // ...at some point `models.todo` is changed
                     * models.todo.completed = true;
                     *
                     * // ...before 1 second has passed `models.todo` is deleted
                     * // which cancels the debounced `todoChanges` call
                     * delete models.todo;
                     */
                    function debounce(func, wait, options) {
                        var args,
                            maxTimeoutId,
                            result,
                            stamp,
                            thisArg,
                            timeoutId,
                            trailingCall,
                            lastCalled = 0,
                            maxWait = false,
                            trailing = true;

                        if (typeof func != 'function') {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        wait = wait < 0 ? 0 : (+wait || 0);
                        if (options === true) {
                            var leading = true;
                            trailing = false;
                        } else if (isObject(options)) {
                            leading = !!options.leading;
                            maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
                            trailing = 'trailing' in options ? !!options.trailing : trailing;
                        }

                        function cancel() {
                            if (timeoutId) {
                                clearTimeout(timeoutId);
                            }
                            if (maxTimeoutId) {
                                clearTimeout(maxTimeoutId);
                            }
                            lastCalled = 0;
                            maxTimeoutId = timeoutId = trailingCall = undefined;
                        }

                        function complete(isCalled, id) {
                            if (id) {
                                clearTimeout(id);
                            }
                            maxTimeoutId = timeoutId = trailingCall = undefined;
                            if (isCalled) {
                                lastCalled = now();
                                result = func.apply(thisArg, args);
                                if (!timeoutId && !maxTimeoutId) {
                                    args = thisArg = undefined;
                                }
                            }
                        }

                        function delayed() {
                            var remaining = wait - (now() - stamp);
                            if (remaining <= 0 || remaining > wait) {
                                complete(trailingCall, maxTimeoutId);
                            } else {
                                timeoutId = setTimeout(delayed, remaining);
                            }
                        }

                        function maxDelayed() {
                            complete(trailing, timeoutId);
                        }

                        function debounced() {
                            args = arguments;
                            stamp = now();
                            thisArg = this;
                            trailingCall = trailing && (timeoutId || !leading);

                            if (maxWait === false) {
                                var leadingCall = leading && !timeoutId;
                            } else {
                                if (!maxTimeoutId && !leading) {
                                    lastCalled = stamp;
                                }
                                var remaining = maxWait - (stamp - lastCalled),
                                    isCalled = remaining <= 0 || remaining > maxWait;

                                if (isCalled) {
                                    if (maxTimeoutId) {
                                        maxTimeoutId = clearTimeout(maxTimeoutId);
                                    }
                                    lastCalled = stamp;
                                    result = func.apply(thisArg, args);
                                } else if (!maxTimeoutId) {
                                    maxTimeoutId = setTimeout(maxDelayed, remaining);
                                }
                            }
                            if (isCalled && timeoutId) {
                                timeoutId = clearTimeout(timeoutId);
                            } else if (!timeoutId && wait !== maxWait) {
                                timeoutId = setTimeout(delayed, wait);
                            }
                            if (leadingCall) {
                                isCalled = true;
                                result = func.apply(thisArg, args);
                            }
                            if (isCalled && !timeoutId && !maxTimeoutId) {
                                args = thisArg = undefined;
                            }
                            return result;
                        }
                        debounced.cancel = cancel;
                        return debounced;
                    }

                    /**
                     * Defers invoking the `func` until the current call stack has cleared. Any
                     * additional arguments are provided to `func` when it is invoked.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to defer.
                     * @param {...*} [args] The arguments to invoke the function with.
                     * @returns {number} Returns the timer id.
                     * @example
                     *
                     * _.defer(function(text) {
                     *   console.log(text);
                     * }, 'deferred');
                     * // logs 'deferred' after one or more milliseconds
                     */
                    var defer = restParam(function(func, args) {
                        return baseDelay(func, 1, args);
                    });

                    /**
                     * Invokes `func` after `wait` milliseconds. Any additional arguments are
                     * provided to `func` when it is invoked.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to delay.
                     * @param {number} wait The number of milliseconds to delay invocation.
                     * @param {...*} [args] The arguments to invoke the function with.
                     * @returns {number} Returns the timer id.
                     * @example
                     *
                     * _.delay(function(text) {
                     *   console.log(text);
                     * }, 1000, 'later');
                     * // => logs 'later' after one second
                     */
                    var delay = restParam(function(func, wait, args) {
                        return baseDelay(func, wait, args);
                    });

                    /**
                     * Creates a function that returns the result of invoking the provided
                     * functions with the `this` binding of the created function, where each
                     * successive invocation is supplied the return value of the previous.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {...Function} [funcs] Functions to invoke.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * function square(n) {
                     *   return n * n;
                     * }
                     *
                     * var addSquare = _.flow(_.add, square);
                     * addSquare(1, 2);
                     * // => 9
                     */
                    var flow = createFlow();

                    /**
                     * This method is like `_.flow` except that it creates a function that
                     * invokes the provided functions from right to left.
                     *
                     * @static
                     * @memberOf _
                     * @alias backflow, compose
                     * @category Function
                     * @param {...Function} [funcs] Functions to invoke.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * function square(n) {
                     *   return n * n;
                     * }
                     *
                     * var addSquare = _.flowRight(square, _.add);
                     * addSquare(1, 2);
                     * // => 9
                     */
                    var flowRight = createFlow(true);

                    /**
                     * Creates a function that memoizes the result of `func`. If `resolver` is
                     * provided it determines the cache key for storing the result based on the
                     * arguments provided to the memoized function. By default, the first argument
                     * provided to the memoized function is coerced to a string and used as the
                     * cache key. The `func` is invoked with the `this` binding of the memoized
                     * function.
                     *
                     * **Note:** The cache is exposed as the `cache` property on the memoized
                     * function. Its creation may be customized by replacing the `_.memoize.Cache`
                     * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
                     * method interface of `get`, `has`, and `set`.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to have its output memoized.
                     * @param {Function} [resolver] The function to resolve the cache key.
                     * @returns {Function} Returns the new memoizing function.
                     * @example
                     *
                     * var upperCase = _.memoize(function(string) {
                     *   return string.toUpperCase();
                     * });
                     *
                     * upperCase('fred');
                     * // => 'FRED'
                     *
                     * // modifying the result cache
                     * upperCase.cache.set('fred', 'BARNEY');
                     * upperCase('fred');
                     * // => 'BARNEY'
                     *
                     * // replacing `_.memoize.Cache`
                     * var object = { 'user': 'fred' };
                     * var other = { 'user': 'barney' };
                     * var identity = _.memoize(_.identity);
                     *
                     * identity(object);
                     * // => { 'user': 'fred' }
                     * identity(other);
                     * // => { 'user': 'fred' }
                     *
                     * _.memoize.Cache = WeakMap;
                     * var identity = _.memoize(_.identity);
                     *
                     * identity(object);
                     * // => { 'user': 'fred' }
                     * identity(other);
                     * // => { 'user': 'barney' }
                     */
                    function memoize(func, resolver) {
                        if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        var memoized = function() {
                            var args = arguments,
                                key = resolver ? resolver.apply(this, args) : args[0],
                                cache = memoized.cache;

                            if (cache.has(key)) {
                                return cache.get(key);
                            }
                            var result = func.apply(this, args);
                            memoized.cache = cache.set(key, result);
                            return result;
                        };
                        memoized.cache = new memoize.Cache;
                        return memoized;
                    }

                    /**
                     * Creates a function that runs each argument through a corresponding
                     * transform function.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to wrap.
                     * @param {...(Function|Function[])} [transforms] The functions to transform
                     * arguments, specified as individual functions or arrays of functions.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * function doubled(n) {
                     *   return n * 2;
                     * }
                     *
                     * function square(n) {
                     *   return n * n;
                     * }
                     *
                     * var modded = _.modArgs(function(x, y) {
                     *   return [x, y];
                     * }, square, doubled);
                     *
                     * modded(1, 2);
                     * // => [1, 4]
                     *
                     * modded(5, 10);
                     * // => [25, 20]
                     */
                    var modArgs = restParam(function(func, transforms) {
                        transforms = baseFlatten(transforms);
                        if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        var length = transforms.length;
                        return restParam(function(args) {
                            var index = nativeMin(args.length, length);
                            while (index--) {
                                args[index] = transforms[index](args[index]);
                            }
                            return func.apply(this, args);
                        });
                    });

                    /**
                     * Creates a function that negates the result of the predicate `func`. The
                     * `func` predicate is invoked with the `this` binding and arguments of the
                     * created function.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} predicate The predicate to negate.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * function isEven(n) {
                     *   return n % 2 == 0;
                     * }
                     *
                     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
                     * // => [1, 3, 5]
                     */
                    function negate(predicate) {
                        if (typeof predicate != 'function') {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        return function() {
                            return !predicate.apply(this, arguments);
                        };
                    }

                    /**
                     * Creates a function that is restricted to invoking `func` once. Repeat calls
                     * to the function return the value of the first call. The `func` is invoked
                     * with the `this` binding and arguments of the created function.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to restrict.
                     * @returns {Function} Returns the new restricted function.
                     * @example
                     *
                     * var initialize = _.once(createApplication);
                     * initialize();
                     * initialize();
                     * // `initialize` invokes `createApplication` once
                     */
                    function once(func) {
                        return before(2, func);
                    }

                    /**
                     * Creates a function that invokes `func` with `partial` arguments prepended
                     * to those provided to the new function. This method is like `_.bind` except
                     * it does **not** alter the `this` binding.
                     *
                     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
                     * builds, may be used as a placeholder for partially applied arguments.
                     *
                     * **Note:** This method does not set the "length" property of partially
                     * applied functions.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to partially apply arguments to.
                     * @param {...*} [partials] The arguments to be partially applied.
                     * @returns {Function} Returns the new partially applied function.
                     * @example
                     *
                     * var greet = function(greeting, name) {
                     *   return greeting + ' ' + name;
                     * };
                     *
                     * var sayHelloTo = _.partial(greet, 'hello');
                     * sayHelloTo('fred');
                     * // => 'hello fred'
                     *
                     * // using placeholders
                     * var greetFred = _.partial(greet, _, 'fred');
                     * greetFred('hi');
                     * // => 'hi fred'
                     */
                    var partial = createPartial(PARTIAL_FLAG);

                    /**
                     * This method is like `_.partial` except that partially applied arguments
                     * are appended to those provided to the new function.
                     *
                     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
                     * builds, may be used as a placeholder for partially applied arguments.
                     *
                     * **Note:** This method does not set the "length" property of partially
                     * applied functions.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to partially apply arguments to.
                     * @param {...*} [partials] The arguments to be partially applied.
                     * @returns {Function} Returns the new partially applied function.
                     * @example
                     *
                     * var greet = function(greeting, name) {
                     *   return greeting + ' ' + name;
                     * };
                     *
                     * var greetFred = _.partialRight(greet, 'fred');
                     * greetFred('hi');
                     * // => 'hi fred'
                     *
                     * // using placeholders
                     * var sayHelloTo = _.partialRight(greet, 'hello', _);
                     * sayHelloTo('fred');
                     * // => 'hello fred'
                     */
                    var partialRight = createPartial(PARTIAL_RIGHT_FLAG);

                    /**
                     * Creates a function that invokes `func` with arguments arranged according
                     * to the specified indexes where the argument value at the first index is
                     * provided as the first argument, the argument value at the second index is
                     * provided as the second argument, and so on.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to rearrange arguments for.
                     * @param {...(number|number[])} indexes The arranged argument indexes,
                     *  specified as individual indexes or arrays of indexes.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var rearged = _.rearg(function(a, b, c) {
                     *   return [a, b, c];
                     * }, 2, 0, 1);
                     *
                     * rearged('b', 'c', 'a')
                     * // => ['a', 'b', 'c']
                     *
                     * var map = _.rearg(_.map, [1, 0]);
                     * map(function(n) {
                     *   return n * 3;
                     * }, [1, 2, 3]);
                     * // => [3, 6, 9]
                     */
                    var rearg = restParam(function(func, indexes) {
                        return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));
                    });

                    /**
                     * Creates a function that invokes `func` with the `this` binding of the
                     * created function and arguments from `start` and beyond provided as an array.
                     *
                     * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to apply a rest parameter to.
                     * @param {number} [start=func.length-1] The start position of the rest parameter.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var say = _.restParam(function(what, names) {
                     *   return what + ' ' + _.initial(names).join(', ') +
                     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
                     * });
                     *
                     * say('hello', 'fred', 'barney', 'pebbles');
                     * // => 'hello fred, barney, & pebbles'
                     */
                    function restParam(func, start) {
                        if (typeof func != 'function') {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
                        return function() {
                            var args = arguments,
                                index = -1,
                                length = nativeMax(args.length - start, 0),
                                rest = Array(length);

                            while (++index < length) {
                                rest[index] = args[start + index];
                            }
                            switch (start) {
                                case 0:
                                    return func.call(this, rest);
                                case 1:
                                    return func.call(this, args[0], rest);
                                case 2:
                                    return func.call(this, args[0], args[1], rest);
                            }
                            var otherArgs = Array(start + 1);
                            index = -1;
                            while (++index < start) {
                                otherArgs[index] = args[index];
                            }
                            otherArgs[start] = rest;
                            return func.apply(this, otherArgs);
                        };
                    }

                    /**
                     * Creates a function that invokes `func` with the `this` binding of the created
                     * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).
                     *
                     * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator).
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to spread arguments over.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var say = _.spread(function(who, what) {
                     *   return who + ' says ' + what;
                     * });
                     *
                     * say(['fred', 'hello']);
                     * // => 'fred says hello'
                     *
                     * // with a Promise
                     * var numbers = Promise.all([
                     *   Promise.resolve(40),
                     *   Promise.resolve(36)
                     * ]);
                     *
                     * numbers.then(_.spread(function(x, y) {
                     *   return x + y;
                     * }));
                     * // => a Promise of 76
                     */
                    function spread(func) {
                        if (typeof func != 'function') {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        return function(array) {
                            return func.apply(this, array);
                        };
                    }

                    /**
                     * Creates a throttled function that only invokes `func` at most once per
                     * every `wait` milliseconds. The throttled function comes with a `cancel`
                     * method to cancel delayed invocations. Provide an options object to indicate
                     * that `func` should be invoked on the leading and/or trailing edge of the
                     * `wait` timeout. Subsequent calls to the throttled function return the
                     * result of the last `func` call.
                     *
                     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
                     * on the trailing edge of the timeout only if the the throttled function is
                     * invoked more than once during the `wait` timeout.
                     *
                     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
                     * for details over the differences between `_.throttle` and `_.debounce`.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {Function} func The function to throttle.
                     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
                     * @param {Object} [options] The options object.
                     * @param {boolean} [options.leading=true] Specify invoking on the leading
                     *  edge of the timeout.
                     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
                     *  edge of the timeout.
                     * @returns {Function} Returns the new throttled function.
                     * @example
                     *
                     * // avoid excessively updating the position while scrolling
                     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
                     *
                     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
                     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
                     *   'trailing': false
                     * }));
                     *
                     * // cancel a trailing throttled call
                     * jQuery(window).on('popstate', throttled.cancel);
                     */
                    function throttle(func, wait, options) {
                        var leading = true,
                            trailing = true;

                        if (typeof func != 'function') {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        if (options === false) {
                            leading = false;
                        } else if (isObject(options)) {
                            leading = 'leading' in options ? !!options.leading : leading;
                            trailing = 'trailing' in options ? !!options.trailing : trailing;
                        }
                        return debounce(func, wait, {
                            'leading': leading,
                            'maxWait': +wait,
                            'trailing': trailing
                        });
                    }

                    /**
                     * Creates a function that provides `value` to the wrapper function as its
                     * first argument. Any additional arguments provided to the function are
                     * appended to those provided to the wrapper function. The wrapper is invoked
                     * with the `this` binding of the created function.
                     *
                     * @static
                     * @memberOf _
                     * @category Function
                     * @param {*} value The value to wrap.
                     * @param {Function} wrapper The wrapper function.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var p = _.wrap(_.escape, function(func, text) {
                     *   return '<p>' + func(text) + '</p>';
                     * });
                     *
                     * p('fred, barney, & pebbles');
                     * // => '<p>fred, barney, &amp; pebbles</p>'
                     */
                    function wrap(value, wrapper) {
                        wrapper = wrapper == null ? identity : wrapper;
                        return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
                     * otherwise they are assigned by reference. If `customizer` is provided it is
                     * invoked to produce the cloned values. If `customizer` returns `undefined`
                     * cloning is handled by the method instead. The `customizer` is bound to
                     * `thisArg` and invoked with two argument; (value [, index|key, object]).
                     *
                     * **Note:** This method is loosely based on the
                     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
                     * The enumerable properties of `arguments` objects and objects created by
                     * constructors other than `Object` are cloned to plain `Object` objects. An
                     * empty object is returned for uncloneable values such as functions, DOM nodes,
                     * Maps, Sets, and WeakMaps.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to clone.
                     * @param {boolean} [isDeep] Specify a deep clone.
                     * @param {Function} [customizer] The function to customize cloning values.
                     * @param {*} [thisArg] The `this` binding of `customizer`.
                     * @returns {*} Returns the cloned value.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney' },
                     *   { 'user': 'fred' }
                     * ];
                     *
                     * var shallow = _.clone(users);
                     * shallow[0] === users[0];
                     * // => true
                     *
                     * var deep = _.clone(users, true);
                     * deep[0] === users[0];
                     * // => false
                     *
                     * // using a customizer callback
                     * var el = _.clone(document.body, function(value) {
                     *   if (_.isElement(value)) {
                     *     return value.cloneNode(false);
                     *   }
                     * });
                     *
                     * el === document.body
                     * // => false
                     * el.nodeName
                     * // => BODY
                     * el.childNodes.length;
                     * // => 0
                     */
                    function clone(value, isDeep, customizer, thisArg) {
                        if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
                            isDeep = false;
                        } else if (typeof isDeep == 'function') {
                            thisArg = customizer;
                            customizer = isDeep;
                            isDeep = false;
                        }
                        return typeof customizer == 'function' ?
                            baseClone(value, isDeep, bindCallback(customizer, thisArg, 1)) :
                            baseClone(value, isDeep);
                    }

                    /**
                     * Creates a deep clone of `value`. If `customizer` is provided it is invoked
                     * to produce the cloned values. If `customizer` returns `undefined` cloning
                     * is handled by the method instead. The `customizer` is bound to `thisArg`
                     * and invoked with two argument; (value [, index|key, object]).
                     *
                     * **Note:** This method is loosely based on the
                     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
                     * The enumerable properties of `arguments` objects and objects created by
                     * constructors other than `Object` are cloned to plain `Object` objects. An
                     * empty object is returned for uncloneable values such as functions, DOM nodes,
                     * Maps, Sets, and WeakMaps.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to deep clone.
                     * @param {Function} [customizer] The function to customize cloning values.
                     * @param {*} [thisArg] The `this` binding of `customizer`.
                     * @returns {*} Returns the deep cloned value.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney' },
                     *   { 'user': 'fred' }
                     * ];
                     *
                     * var deep = _.cloneDeep(users);
                     * deep[0] === users[0];
                     * // => false
                     *
                     * // using a customizer callback
                     * var el = _.cloneDeep(document.body, function(value) {
                     *   if (_.isElement(value)) {
                     *     return value.cloneNode(true);
                     *   }
                     * });
                     *
                     * el === document.body
                     * // => false
                     * el.nodeName
                     * // => BODY
                     * el.childNodes.length;
                     * // => 20
                     */
                    function cloneDeep(value, customizer, thisArg) {
                        return typeof customizer == 'function' ?
                            baseClone(value, true, bindCallback(customizer, thisArg, 1)) :
                            baseClone(value, true);
                    }

                    /**
                     * Checks if `value` is greater than `other`.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to compare.
                     * @param {*} other The other value to compare.
                     * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.
                     * @example
                     *
                     * _.gt(3, 1);
                     * // => true
                     *
                     * _.gt(3, 3);
                     * // => false
                     *
                     * _.gt(1, 3);
                     * // => false
                     */
                    function gt(value, other) {
                        return value > other;
                    }

                    /**
                     * Checks if `value` is greater than or equal to `other`.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to compare.
                     * @param {*} other The other value to compare.
                     * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.
                     * @example
                     *
                     * _.gte(3, 1);
                     * // => true
                     *
                     * _.gte(3, 3);
                     * // => true
                     *
                     * _.gte(1, 3);
                     * // => false
                     */
                    function gte(value, other) {
                        return value >= other;
                    }

                    /**
                     * Checks if `value` is classified as an `arguments` object.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                     * @example
                     *
                     * _.isArguments(function() { return arguments; }());
                     * // => true
                     *
                     * _.isArguments([1, 2, 3]);
                     * // => false
                     */
                    function isArguments(value) {
                        return isObjectLike(value) && isArrayLike(value) &&
                            hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
                    }

                    /**
                     * Checks if `value` is classified as an `Array` object.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                     * @example
                     *
                     * _.isArray([1, 2, 3]);
                     * // => true
                     *
                     * _.isArray(function() { return arguments; }());
                     * // => false
                     */
                    var isArray = nativeIsArray || function(value) {
                        return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
                    };

                    /**
                     * Checks if `value` is classified as a boolean primitive or object.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                     * @example
                     *
                     * _.isBoolean(false);
                     * // => true
                     *
                     * _.isBoolean(null);
                     * // => false
                     */
                    function isBoolean(value) {
                        return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
                    }

                    /**
                     * Checks if `value` is classified as a `Date` object.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                     * @example
                     *
                     * _.isDate(new Date);
                     * // => true
                     *
                     * _.isDate('Mon April 23 2012');
                     * // => false
                     */
                    function isDate(value) {
                        return isObjectLike(value) && objToString.call(value) == dateTag;
                    }

                    /**
                     * Checks if `value` is a DOM element.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
                     * @example
                     *
                     * _.isElement(document.body);
                     * // => true
                     *
                     * _.isElement('<body>');
                     * // => false
                     */
                    function isElement(value) {
                        return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
                    }

                    /**
                     * Checks if `value` is empty. A value is considered empty unless it is an
                     * `arguments` object, array, string, or jQuery-like collection with a length
                     * greater than `0` or an object with own enumerable properties.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {Array|Object|string} value The value to inspect.
                     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
                     * @example
                     *
                     * _.isEmpty(null);
                     * // => true
                     *
                     * _.isEmpty(true);
                     * // => true
                     *
                     * _.isEmpty(1);
                     * // => true
                     *
                     * _.isEmpty([1, 2, 3]);
                     * // => false
                     *
                     * _.isEmpty({ 'a': 1 });
                     * // => false
                     */
                    function isEmpty(value) {
                        if (value == null) {
                            return true;
                        }
                        if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||
                                (isObjectLike(value) && isFunction(value.splice)))) {
                            return !value.length;
                        }
                        return !keys(value).length;
                    }

                    /**
                     * Performs a deep comparison between two values to determine if they are
                     * equivalent. If `customizer` is provided it is invoked to compare values.
                     * If `customizer` returns `undefined` comparisons are handled by the method
                     * instead. The `customizer` is bound to `thisArg` and invoked with three
                     * arguments: (value, other [, index|key]).
                     *
                     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
                     * numbers, `Object` objects, regexes, and strings. Objects are compared by
                     * their own, not inherited, enumerable properties. Functions and DOM nodes
                     * are **not** supported. Provide a customizer function to extend support
                     * for comparing other values.
                     *
                     * @static
                     * @memberOf _
                     * @alias eq
                     * @category Lang
                     * @param {*} value The value to compare.
                     * @param {*} other The other value to compare.
                     * @param {Function} [customizer] The function to customize value comparisons.
                     * @param {*} [thisArg] The `this` binding of `customizer`.
                     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                     * @example
                     *
                     * var object = { 'user': 'fred' };
                     * var other = { 'user': 'fred' };
                     *
                     * object == other;
                     * // => false
                     *
                     * _.isEqual(object, other);
                     * // => true
                     *
                     * // using a customizer callback
                     * var array = ['hello', 'goodbye'];
                     * var other = ['hi', 'goodbye'];
                     *
                     * _.isEqual(array, other, function(value, other) {
                     *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
                     *     return true;
                     *   }
                     * });
                     * // => true
                     */
                    function isEqual(value, other, customizer, thisArg) {
                        customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
                        var result = customizer ? customizer(value, other) : undefined;
                        return result === undefined ? baseIsEqual(value, other, customizer) : !!result;
                    }

                    /**
                     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
                     * `SyntaxError`, `TypeError`, or `URIError` object.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
                     * @example
                     *
                     * _.isError(new Error);
                     * // => true
                     *
                     * _.isError(Error);
                     * // => false
                     */
                    function isError(value) {
                        return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
                    }

                    /**
                     * Checks if `value` is a finite primitive number.
                     *
                     * **Note:** This method is based on [`Number.isFinite`](http://ecma-international.org/ecma-262/6.0/#sec-number.isfinite).
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
                     * @example
                     *
                     * _.isFinite(10);
                     * // => true
                     *
                     * _.isFinite('10');
                     * // => false
                     *
                     * _.isFinite(true);
                     * // => false
                     *
                     * _.isFinite(Object(10));
                     * // => false
                     *
                     * _.isFinite(Infinity);
                     * // => false
                     */
                    function isFinite(value) {
                        return typeof value == 'number' && nativeIsFinite(value);
                    }

                    /**
                     * Checks if `value` is classified as a `Function` object.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                     * @example
                     *
                     * _.isFunction(_);
                     * // => true
                     *
                     * _.isFunction(/abc/);
                     * // => false
                     */
                    function isFunction(value) {
                        // The use of `Object#toString` avoids issues with the `typeof` operator
                        // in older versions of Chrome and Safari which return 'function' for regexes
                        // and Safari 8 equivalents which return 'object' for typed array constructors.
                        return isObject(value) && objToString.call(value) == funcTag;
                    }

                    /**
                     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
                     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
                     * @example
                     *
                     * _.isObject({});
                     * // => true
                     *
                     * _.isObject([1, 2, 3]);
                     * // => true
                     *
                     * _.isObject(1);
                     * // => false
                     */
                    function isObject(value) {
                        // Avoid a V8 JIT bug in Chrome 19-20.
                        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
                        var type = typeof value;
                        return !!value && (type == 'object' || type == 'function');
                    }

                    /**
                     * Performs a deep comparison between `object` and `source` to determine if
                     * `object` contains equivalent property values. If `customizer` is provided
                     * it is invoked to compare values. If `customizer` returns `undefined`
                     * comparisons are handled by the method instead. The `customizer` is bound
                     * to `thisArg` and invoked with three arguments: (value, other, index|key).
                     *
                     * **Note:** This method supports comparing properties of arrays, booleans,
                     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
                     * and DOM nodes are **not** supported. Provide a customizer function to extend
                     * support for comparing other values.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {Object} object The object to inspect.
                     * @param {Object} source The object of property values to match.
                     * @param {Function} [customizer] The function to customize value comparisons.
                     * @param {*} [thisArg] The `this` binding of `customizer`.
                     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
                     * @example
                     *
                     * var object = { 'user': 'fred', 'age': 40 };
                     *
                     * _.isMatch(object, { 'age': 40 });
                     * // => true
                     *
                     * _.isMatch(object, { 'age': 36 });
                     * // => false
                     *
                     * // using a customizer callback
                     * var object = { 'greeting': 'hello' };
                     * var source = { 'greeting': 'hi' };
                     *
                     * _.isMatch(object, source, function(value, other) {
                     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
                     * });
                     * // => true
                     */
                    function isMatch(object, source, customizer, thisArg) {
                        customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
                        return baseIsMatch(object, getMatchData(source), customizer);
                    }

                    /**
                     * Checks if `value` is `NaN`.
                     *
                     * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
                     * which returns `true` for `undefined` and other non-numeric values.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
                     * @example
                     *
                     * _.isNaN(NaN);
                     * // => true
                     *
                     * _.isNaN(new Number(NaN));
                     * // => true
                     *
                     * isNaN(undefined);
                     * // => true
                     *
                     * _.isNaN(undefined);
                     * // => false
                     */
                    function isNaN(value) {
                        // An `NaN` primitive is the only value that is not equal to itself.
                        // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
                        return isNumber(value) && value != +value;
                    }

                    /**
                     * Checks if `value` is a native function.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
                     * @example
                     *
                     * _.isNative(Array.prototype.push);
                     * // => true
                     *
                     * _.isNative(_);
                     * // => false
                     */
                    function isNative(value) {
                        if (value == null) {
                            return false;
                        }
                        if (isFunction(value)) {
                            return reIsNative.test(fnToString.call(value));
                        }
                        return isObjectLike(value) && reIsHostCtor.test(value);
                    }

                    /**
                     * Checks if `value` is `null`.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
                     * @example
                     *
                     * _.isNull(null);
                     * // => true
                     *
                     * _.isNull(void 0);
                     * // => false
                     */
                    function isNull(value) {
                        return value === null;
                    }

                    /**
                     * Checks if `value` is classified as a `Number` primitive or object.
                     *
                     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
                     * as numbers, use the `_.isFinite` method.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                     * @example
                     *
                     * _.isNumber(8.4);
                     * // => true
                     *
                     * _.isNumber(NaN);
                     * // => true
                     *
                     * _.isNumber('8.4');
                     * // => false
                     */
                    function isNumber(value) {
                        return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
                    }

                    /**
                     * Checks if `value` is a plain object, that is, an object created by the
                     * `Object` constructor or one with a `[[Prototype]]` of `null`.
                     *
                     * **Note:** This method assumes objects created by the `Object` constructor
                     * have no inherited enumerable properties.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
                     * @example
                     *
                     * function Foo() {
                     *   this.a = 1;
                     * }
                     *
                     * _.isPlainObject(new Foo);
                     * // => false
                     *
                     * _.isPlainObject([1, 2, 3]);
                     * // => false
                     *
                     * _.isPlainObject({ 'x': 0, 'y': 0 });
                     * // => true
                     *
                     * _.isPlainObject(Object.create(null));
                     * // => true
                     */
                    function isPlainObject(value) {
                        var Ctor;

                        // Exit early for non `Object` objects.
                        if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) ||
                            (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
                            return false;
                        }
                        // IE < 9 iterates inherited properties before own properties. If the first
                        // iterated property is an object's own property then there are no inherited
                        // enumerable properties.
                        var result;
                        // In most environments an object's own properties are iterated before
                        // its inherited properties. If the last iterated property is an object's
                        // own property then there are no inherited enumerable properties.
                        baseForIn(value, function(subValue, key) {
                            result = key;
                        });
                        return result === undefined || hasOwnProperty.call(value, result);
                    }

                    /**
                     * Checks if `value` is classified as a `RegExp` object.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                     * @example
                     *
                     * _.isRegExp(/abc/);
                     * // => true
                     *
                     * _.isRegExp('/abc/');
                     * // => false
                     */
                    function isRegExp(value) {
                        return isObject(value) && objToString.call(value) == regexpTag;
                    }

                    /**
                     * Checks if `value` is classified as a `String` primitive or object.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                     * @example
                     *
                     * _.isString('abc');
                     * // => true
                     *
                     * _.isString(1);
                     * // => false
                     */
                    function isString(value) {
                        return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
                    }

                    /**
                     * Checks if `value` is classified as a typed array.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
                     * @example
                     *
                     * _.isTypedArray(new Uint8Array);
                     * // => true
                     *
                     * _.isTypedArray([]);
                     * // => false
                     */
                    function isTypedArray(value) {
                        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
                    }

                    /**
                     * Checks if `value` is `undefined`.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
                     * @example
                     *
                     * _.isUndefined(void 0);
                     * // => true
                     *
                     * _.isUndefined(null);
                     * // => false
                     */
                    function isUndefined(value) {
                        return value === undefined;
                    }

                    /**
                     * Checks if `value` is less than `other`.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to compare.
                     * @param {*} other The other value to compare.
                     * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.
                     * @example
                     *
                     * _.lt(1, 3);
                     * // => true
                     *
                     * _.lt(3, 3);
                     * // => false
                     *
                     * _.lt(3, 1);
                     * // => false
                     */
                    function lt(value, other) {
                        return value < other;
                    }

                    /**
                     * Checks if `value` is less than or equal to `other`.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to compare.
                     * @param {*} other The other value to compare.
                     * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.
                     * @example
                     *
                     * _.lte(1, 3);
                     * // => true
                     *
                     * _.lte(3, 3);
                     * // => true
                     *
                     * _.lte(3, 1);
                     * // => false
                     */
                    function lte(value, other) {
                        return value <= other;
                    }

                    /**
                     * Converts `value` to an array.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to convert.
                     * @returns {Array} Returns the converted array.
                     * @example
                     *
                     * (function() {
                     *   return _.toArray(arguments).slice(1);
                     * }(1, 2, 3));
                     * // => [2, 3]
                     */
                    function toArray(value) {
                        var length = value ? getLength(value) : 0;
                        if (!isLength(length)) {
                            return values(value);
                        }
                        if (!length) {
                            return [];
                        }
                        return arrayCopy(value);
                    }

                    /**
                     * Converts `value` to a plain object flattening inherited enumerable
                     * properties of `value` to own properties of the plain object.
                     *
                     * @static
                     * @memberOf _
                     * @category Lang
                     * @param {*} value The value to convert.
                     * @returns {Object} Returns the converted plain object.
                     * @example
                     *
                     * function Foo() {
                     *   this.b = 2;
                     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.assign({ 'a': 1 }, new Foo);
                     * // => { 'a': 1, 'b': 2 }
                     *
                     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
                     * // => { 'a': 1, 'b': 2, 'c': 3 }
                     */
                    function toPlainObject(value) {
                        return baseCopy(value, keysIn(value));
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Recursively merges own enumerable properties of the source object(s), that
                     * don't resolve to `undefined` into the destination object. Subsequent sources
                     * overwrite property assignments of previous sources. If `customizer` is
                     * provided it is invoked to produce the merged values of the destination and
                     * source properties. If `customizer` returns `undefined` merging is handled
                     * by the method instead. The `customizer` is bound to `thisArg` and invoked
                     * with five arguments: (objectValue, sourceValue, key, object, source).
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The destination object.
                     * @param {...Object} [sources] The source objects.
                     * @param {Function} [customizer] The function to customize assigned values.
                     * @param {*} [thisArg] The `this` binding of `customizer`.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * var users = {
                     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
                     * };
                     *
                     * var ages = {
                     *   'data': [{ 'age': 36 }, { 'age': 40 }]
                     * };
                     *
                     * _.merge(users, ages);
                     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
                     *
                     * // using a customizer callback
                     * var object = {
                     *   'fruits': ['apple'],
                     *   'vegetables': ['beet']
                     * };
                     *
                     * var other = {
                     *   'fruits': ['banana'],
                     *   'vegetables': ['carrot']
                     * };
                     *
                     * _.merge(object, other, function(a, b) {
                     *   if (_.isArray(a)) {
                     *     return a.concat(b);
                     *   }
                     * });
                     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
                     */
                    var merge = createAssigner(baseMerge);

                    /**
                     * Assigns own enumerable properties of source object(s) to the destination
                     * object. Subsequent sources overwrite property assignments of previous sources.
                     * If `customizer` is provided it is invoked to produce the assigned values.
                     * The `customizer` is bound to `thisArg` and invoked with five arguments:
                     * (objectValue, sourceValue, key, object, source).
                     *
                     * **Note:** This method mutates `object` and is based on
                     * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).
                     *
                     * @static
                     * @memberOf _
                     * @alias extend
                     * @category Object
                     * @param {Object} object The destination object.
                     * @param {...Object} [sources] The source objects.
                     * @param {Function} [customizer] The function to customize assigned values.
                     * @param {*} [thisArg] The `this` binding of `customizer`.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
                     * // => { 'user': 'fred', 'age': 40 }
                     *
                     * // using a customizer callback
                     * var defaults = _.partialRight(_.assign, function(value, other) {
                     *   return _.isUndefined(value) ? other : value;
                     * });
                     *
                     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
                     * // => { 'user': 'barney', 'age': 36 }
                     */
                    var assign = createAssigner(function(object, source, customizer) {
                        return customizer ?
                            assignWith(object, source, customizer) :
                            baseAssign(object, source);
                    });

                    /**
                     * Creates an object that inherits from the given `prototype` object. If a
                     * `properties` object is provided its own enumerable properties are assigned
                     * to the created object.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} prototype The object to inherit from.
                     * @param {Object} [properties] The properties to assign to the object.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Object} Returns the new object.
                     * @example
                     *
                     * function Shape() {
                     *   this.x = 0;
                     *   this.y = 0;
                     * }
                     *
                     * function Circle() {
                     *   Shape.call(this);
                     * }
                     *
                     * Circle.prototype = _.create(Shape.prototype, {
                     *   'constructor': Circle
                     * });
                     *
                     * var circle = new Circle;
                     * circle instanceof Circle;
                     * // => true
                     *
                     * circle instanceof Shape;
                     * // => true
                     */
                    function create(prototype, properties, guard) {
                        var result = baseCreate(prototype);
                        if (guard && isIterateeCall(prototype, properties, guard)) {
                            properties = undefined;
                        }
                        return properties ? baseAssign(result, properties) : result;
                    }

                    /**
                     * Assigns own enumerable properties of source object(s) to the destination
                     * object for all destination properties that resolve to `undefined`. Once a
                     * property is set, additional values of the same property are ignored.
                     *
                     * **Note:** This method mutates `object`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The destination object.
                     * @param {...Object} [sources] The source objects.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
                     * // => { 'user': 'barney', 'age': 36 }
                     */
                    var defaults = createDefaults(assign, assignDefaults);

                    /**
                     * This method is like `_.defaults` except that it recursively assigns
                     * default properties.
                     *
                     * **Note:** This method mutates `object`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The destination object.
                     * @param {...Object} [sources] The source objects.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });
                     * // => { 'user': { 'name': 'barney', 'age': 36 } }
                     *
                     */
                    var defaultsDeep = createDefaults(merge, mergeDefaults);

                    /**
                     * This method is like `_.find` except that it returns the key of the first
                     * element `predicate` returns truthy for instead of the element itself.
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to search.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
                     * @example
                     *
                     * var users = {
                     *   'barney':  { 'age': 36, 'active': true },
                     *   'fred':    { 'age': 40, 'active': false },
                     *   'pebbles': { 'age': 1,  'active': true }
                     * };
                     *
                     * _.findKey(users, function(chr) {
                     *   return chr.age < 40;
                     * });
                     * // => 'barney' (iteration order is not guaranteed)
                     *
                     * // using the `_.matches` callback shorthand
                     * _.findKey(users, { 'age': 1, 'active': true });
                     * // => 'pebbles'
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.findKey(users, 'active', false);
                     * // => 'fred'
                     *
                     * // using the `_.property` callback shorthand
                     * _.findKey(users, 'active');
                     * // => 'barney'
                     */
                    var findKey = createFindKey(baseForOwn);

                    /**
                     * This method is like `_.findKey` except that it iterates over elements of
                     * a collection in the opposite order.
                     *
                     * If a property name is provided for `predicate` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `predicate` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to search.
                     * @param {Function|Object|string} [predicate=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
                     * @example
                     *
                     * var users = {
                     *   'barney':  { 'age': 36, 'active': true },
                     *   'fred':    { 'age': 40, 'active': false },
                     *   'pebbles': { 'age': 1,  'active': true }
                     * };
                     *
                     * _.findLastKey(users, function(chr) {
                     *   return chr.age < 40;
                     * });
                     * // => returns `pebbles` assuming `_.findKey` returns `barney`
                     *
                     * // using the `_.matches` callback shorthand
                     * _.findLastKey(users, { 'age': 36, 'active': true });
                     * // => 'barney'
                     *
                     * // using the `_.matchesProperty` callback shorthand
                     * _.findLastKey(users, 'active', false);
                     * // => 'fred'
                     *
                     * // using the `_.property` callback shorthand
                     * _.findLastKey(users, 'active');
                     * // => 'pebbles'
                     */
                    var findLastKey = createFindKey(baseForOwnRight);

                    /**
                     * Iterates over own and inherited enumerable properties of an object invoking
                     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
                     * with three arguments: (value, key, object). Iteratee functions may exit
                     * iteration early by explicitly returning `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * function Foo() {
                     *   this.a = 1;
                     *   this.b = 2;
                     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.forIn(new Foo, function(value, key) {
                     *   console.log(key);
                     * });
                     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
                     */
                    var forIn = createForIn(baseFor);

                    /**
                     * This method is like `_.forIn` except that it iterates over properties of
                     * `object` in the opposite order.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * function Foo() {
                     *   this.a = 1;
                     *   this.b = 2;
                     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.forInRight(new Foo, function(value, key) {
                     *   console.log(key);
                     * });
                     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
                     */
                    var forInRight = createForIn(baseForRight);

                    /**
                     * Iterates over own enumerable properties of an object invoking `iteratee`
                     * for each property. The `iteratee` is bound to `thisArg` and invoked with
                     * three arguments: (value, key, object). Iteratee functions may exit iteration
                     * early by explicitly returning `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * function Foo() {
                     *   this.a = 1;
                     *   this.b = 2;
                     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.forOwn(new Foo, function(value, key) {
                     *   console.log(key);
                     * });
                     * // => logs 'a' and 'b' (iteration order is not guaranteed)
                     */
                    var forOwn = createForOwn(baseForOwn);

                    /**
                     * This method is like `_.forOwn` except that it iterates over properties of
                     * `object` in the opposite order.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * function Foo() {
                     *   this.a = 1;
                     *   this.b = 2;
                     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.forOwnRight(new Foo, function(value, key) {
                     *   console.log(key);
                     * });
                     * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'
                     */
                    var forOwnRight = createForOwn(baseForOwnRight);

                    /**
                     * Creates an array of function property names from all enumerable properties,
                     * own and inherited, of `object`.
                     *
                     * @static
                     * @memberOf _
                     * @alias methods
                     * @category Object
                     * @param {Object} object The object to inspect.
                     * @returns {Array} Returns the new array of property names.
                     * @example
                     *
                     * _.functions(_);
                     * // => ['after', 'ary', 'assign', ...]
                     */
                    function functions(object) {
                        return baseFunctions(object, keysIn(object));
                    }

                    /**
                     * Gets the property value at `path` of `object`. If the resolved value is
                     * `undefined` the `defaultValue` is used in its place.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to query.
                     * @param {Array|string} path The path of the property to get.
                     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
                     * @returns {*} Returns the resolved value.
                     * @example
                     *
                     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
                     *
                     * _.get(object, 'a[0].b.c');
                     * // => 3
                     *
                     * _.get(object, ['a', '0', 'b', 'c']);
                     * // => 3
                     *
                     * _.get(object, 'a.b.c', 'default');
                     * // => 'default'
                     */
                    function get(object, path, defaultValue) {
                        var result = object == null ? undefined : baseGet(object, toPath(path), path + '');
                        return result === undefined ? defaultValue : result;
                    }

                    /**
                     * Checks if `path` is a direct property.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to query.
                     * @param {Array|string} path The path to check.
                     * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.
                     * @example
                     *
                     * var object = { 'a': { 'b': { 'c': 3 } } };
                     *
                     * _.has(object, 'a');
                     * // => true
                     *
                     * _.has(object, 'a.b.c');
                     * // => true
                     *
                     * _.has(object, ['a', 'b', 'c']);
                     * // => true
                     */
                    function has(object, path) {
                        if (object == null) {
                            return false;
                        }
                        var result = hasOwnProperty.call(object, path);
                        if (!result && !isKey(path)) {
                            path = toPath(path);
                            object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                            if (object == null) {
                                return false;
                            }
                            path = last(path);
                            result = hasOwnProperty.call(object, path);
                        }
                        return result || (isLength(object.length) && isIndex(path, object.length) &&
                            (isArray(object) || isArguments(object)));
                    }

                    /**
                     * Creates an object composed of the inverted keys and values of `object`.
                     * If `object` contains duplicate values, subsequent values overwrite property
                     * assignments of previous values unless `multiValue` is `true`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to invert.
                     * @param {boolean} [multiValue] Allow multiple values per key.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Object} Returns the new inverted object.
                     * @example
                     *
                     * var object = { 'a': 1, 'b': 2, 'c': 1 };
                     *
                     * _.invert(object);
                     * // => { '1': 'c', '2': 'b' }
                     *
                     * // with `multiValue`
                     * _.invert(object, true);
                     * // => { '1': ['a', 'c'], '2': ['b'] }
                     */
                    function invert(object, multiValue, guard) {
                        if (guard && isIterateeCall(object, multiValue, guard)) {
                            multiValue = undefined;
                        }
                        var index = -1,
                            props = keys(object),
                            length = props.length,
                            result = {};

                        while (++index < length) {
                            var key = props[index],
                                value = object[key];

                            if (multiValue) {
                                if (hasOwnProperty.call(result, value)) {
                                    result[value].push(key);
                                } else {
                                    result[value] = [key];
                                }
                            } else {
                                result[value] = key;
                            }
                        }
                        return result;
                    }

                    /**
                     * Creates an array of the own enumerable property names of `object`.
                     *
                     * **Note:** Non-object values are coerced to objects. See the
                     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
                     * for more details.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of property names.
                     * @example
                     *
                     * function Foo() {
                     *   this.a = 1;
                     *   this.b = 2;
                     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.keys(new Foo);
                     * // => ['a', 'b'] (iteration order is not guaranteed)
                     *
                     * _.keys('hi');
                     * // => ['0', '1']
                     */
                    var keys = !nativeKeys ? shimKeys : function(object) {
                        var Ctor = object == null ? undefined : object.constructor;
                        if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
                            (typeof object != 'function' && isArrayLike(object))) {
                            return shimKeys(object);
                        }
                        return isObject(object) ? nativeKeys(object) : [];
                    };

                    /**
                     * Creates an array of the own and inherited enumerable property names of `object`.
                     *
                     * **Note:** Non-object values are coerced to objects.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of property names.
                     * @example
                     *
                     * function Foo() {
                     *   this.a = 1;
                     *   this.b = 2;
                     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.keysIn(new Foo);
                     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
                     */
                    function keysIn(object) {
                        if (object == null) {
                            return [];
                        }
                        if (!isObject(object)) {
                            object = Object(object);
                        }
                        var length = object.length;
                        length = (length && isLength(length) &&
                            (isArray(object) || isArguments(object)) && length) || 0;

                        var Ctor = object.constructor,
                            index = -1,
                            isProto = typeof Ctor == 'function' && Ctor.prototype === object,
                            result = Array(length),
                            skipIndexes = length > 0;

                        while (++index < length) {
                            result[index] = (index + '');
                        }
                        for (var key in object) {
                            if (!(skipIndexes && isIndex(key, length)) &&
                                !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                                result.push(key);
                            }
                        }
                        return result;
                    }

                    /**
                     * The opposite of `_.mapValues`; this method creates an object with the
                     * same values as `object` and keys generated by running each own enumerable
                     * property of `object` through `iteratee`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to iterate over.
                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Object} Returns the new mapped object.
                     * @example
                     *
                     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
                     *   return key + value;
                     * });
                     * // => { 'a1': 1, 'b2': 2 }
                     */
                    var mapKeys = createObjectMapper(true);

                    /**
                     * Creates an object with the same keys as `object` and values generated by
                     * running each own enumerable property of `object` through `iteratee`. The
                     * iteratee function is bound to `thisArg` and invoked with three arguments:
                     * (value, key, object).
                     *
                     * If a property name is provided for `iteratee` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `iteratee` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to iterate over.
                     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
                     *  per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Object} Returns the new mapped object.
                     * @example
                     *
                     * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
                     *   return n * 3;
                     * });
                     * // => { 'a': 3, 'b': 6 }
                     *
                     * var users = {
                     *   'fred':    { 'user': 'fred',    'age': 40 },
                     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
                     * };
                     *
                     * // using the `_.property` callback shorthand
                     * _.mapValues(users, 'age');
                     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
                     */
                    var mapValues = createObjectMapper();

                    /**
                     * The opposite of `_.pick`; this method creates an object composed of the
                     * own and inherited enumerable properties of `object` that are not omitted.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The source object.
                     * @param {Function|...(string|string[])} [predicate] The function invoked per
                     *  iteration or property names to omit, specified as individual property
                     *  names or arrays of property names.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {Object} Returns the new object.
                     * @example
                     *
                     * var object = { 'user': 'fred', 'age': 40 };
                     *
                     * _.omit(object, 'age');
                     * // => { 'user': 'fred' }
                     *
                     * _.omit(object, _.isNumber);
                     * // => { 'user': 'fred' }
                     */
                    var omit = restParam(function(object, props) {
                        if (object == null) {
                            return {};
                        }
                        if (typeof props[0] != 'function') {
                            var props = arrayMap(baseFlatten(props), String);
                            return pickByArray(object, baseDifference(keysIn(object), props));
                        }
                        var predicate = bindCallback(props[0], props[1], 3);
                        return pickByCallback(object, function(value, key, object) {
                            return !predicate(value, key, object);
                        });
                    });

                    /**
                     * Creates a two dimensional array of the key-value pairs for `object`,
                     * e.g. `[[key1, value1], [key2, value2]]`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the new array of key-value pairs.
                     * @example
                     *
                     * _.pairs({ 'barney': 36, 'fred': 40 });
                     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
                     */
                    function pairs(object) {
                        object = toObject(object);

                        var index = -1,
                            props = keys(object),
                            length = props.length,
                            result = Array(length);

                        while (++index < length) {
                            var key = props[index];
                            result[index] = [key, object[key]];
                        }
                        return result;
                    }

                    /**
                     * Creates an object composed of the picked `object` properties. Property
                     * names may be specified as individual arguments or as arrays of property
                     * names. If `predicate` is provided it is invoked for each property of `object`
                     * picking the properties `predicate` returns truthy for. The predicate is
                     * bound to `thisArg` and invoked with three arguments: (value, key, object).
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The source object.
                     * @param {Function|...(string|string[])} [predicate] The function invoked per
                     *  iteration or property names to pick, specified as individual property
                     *  names or arrays of property names.
                     * @param {*} [thisArg] The `this` binding of `predicate`.
                     * @returns {Object} Returns the new object.
                     * @example
                     *
                     * var object = { 'user': 'fred', 'age': 40 };
                     *
                     * _.pick(object, 'user');
                     * // => { 'user': 'fred' }
                     *
                     * _.pick(object, _.isString);
                     * // => { 'user': 'fred' }
                     */
                    var pick = restParam(function(object, props) {
                        if (object == null) {
                            return {};
                        }
                        return typeof props[0] == 'function' ?
                            pickByCallback(object, bindCallback(props[0], props[1], 3)) :
                            pickByArray(object, baseFlatten(props));
                    });

                    /**
                     * This method is like `_.get` except that if the resolved value is a function
                     * it is invoked with the `this` binding of its parent object and its result
                     * is returned.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to query.
                     * @param {Array|string} path The path of the property to resolve.
                     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
                     * @returns {*} Returns the resolved value.
                     * @example
                     *
                     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
                     *
                     * _.result(object, 'a[0].b.c1');
                     * // => 3
                     *
                     * _.result(object, 'a[0].b.c2');
                     * // => 4
                     *
                     * _.result(object, 'a.b.c', 'default');
                     * // => 'default'
                     *
                     * _.result(object, 'a.b.c', _.constant('default'));
                     * // => 'default'
                     */
                    function result(object, path, defaultValue) {
                        var result = object == null ? undefined : object[path];
                        if (result === undefined) {
                            if (object != null && !isKey(path, object)) {
                                path = toPath(path);
                                object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                                result = object == null ? undefined : object[last(path)];
                            }
                            result = result === undefined ? defaultValue : result;
                        }
                        return isFunction(result) ? result.call(object) : result;
                    }

                    /**
                     * Sets the property value of `path` on `object`. If a portion of `path`
                     * does not exist it is created.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to augment.
                     * @param {Array|string} path The path of the property to set.
                     * @param {*} value The value to set.
                     * @returns {Object} Returns `object`.
                     * @example
                     *
                     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
                     *
                     * _.set(object, 'a[0].b.c', 4);
                     * console.log(object.a[0].b.c);
                     * // => 4
                     *
                     * _.set(object, 'x[0].y.z', 5);
                     * console.log(object.x[0].y.z);
                     * // => 5
                     */
                    function set(object, path, value) {
                        if (object == null) {
                            return object;
                        }
                        var pathKey = (path + '');
                        path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);

                        var index = -1,
                            length = path.length,
                            lastIndex = length - 1,
                            nested = object;

                        while (nested != null && ++index < length) {
                            var key = path[index];
                            if (isObject(nested)) {
                                if (index == lastIndex) {
                                    nested[key] = value;
                                } else if (nested[key] == null) {
                                    nested[key] = isIndex(path[index + 1]) ? [] : {};
                                }
                            }
                            nested = nested[key];
                        }
                        return object;
                    }

                    /**
                     * An alternative to `_.reduce`; this method transforms `object` to a new
                     * `accumulator` object which is the result of running each of its own enumerable
                     * properties through `iteratee`, with each invocation potentially mutating
                     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
                     * with four arguments: (accumulator, value, key, object). Iteratee functions
                     * may exit iteration early by explicitly returning `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Array|Object} object The object to iterate over.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [accumulator] The custom accumulator value.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {*} Returns the accumulated value.
                     * @example
                     *
                     * _.transform([2, 3, 4], function(result, n) {
                     *   result.push(n *= n);
                     *   return n % 2 == 0;
                     * });
                     * // => [4, 9]
                     *
                     * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
                     *   result[key] = n * 3;
                     * });
                     * // => { 'a': 3, 'b': 6 }
                     */
                    function transform(object, iteratee, accumulator, thisArg) {
                        var isArr = isArray(object) || isTypedArray(object);
                        iteratee = getCallback(iteratee, thisArg, 4);

                        if (accumulator == null) {
                            if (isArr || isObject(object)) {
                                var Ctor = object.constructor;
                                if (isArr) {
                                    accumulator = isArray(object) ? new Ctor : [];
                                } else {
                                    accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
                                }
                            } else {
                                accumulator = {};
                            }
                        }
                        (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
                            return iteratee(accumulator, value, index, object);
                        });
                        return accumulator;
                    }

                    /**
                     * Creates an array of the own enumerable property values of `object`.
                     *
                     * **Note:** Non-object values are coerced to objects.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of property values.
                     * @example
                     *
                     * function Foo() {
                     *   this.a = 1;
                     *   this.b = 2;
                     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.values(new Foo);
                     * // => [1, 2] (iteration order is not guaranteed)
                     *
                     * _.values('hi');
                     * // => ['h', 'i']
                     */
                    function values(object) {
                        return baseValues(object, keys(object));
                    }

                    /**
                     * Creates an array of the own and inherited enumerable property values
                     * of `object`.
                     *
                     * **Note:** Non-object values are coerced to objects.
                     *
                     * @static
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of property values.
                     * @example
                     *
                     * function Foo() {
                     *   this.a = 1;
                     *   this.b = 2;
                     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.valuesIn(new Foo);
                     * // => [1, 2, 3] (iteration order is not guaranteed)
                     */
                    function valuesIn(object) {
                        return baseValues(object, keysIn(object));
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Checks if `n` is between `start` and up to but not including, `end`. If
                     * `end` is not specified it is set to `start` with `start` then set to `0`.
                     *
                     * @static
                     * @memberOf _
                     * @category Number
                     * @param {number} n The number to check.
                     * @param {number} [start=0] The start of the range.
                     * @param {number} end The end of the range.
                     * @returns {boolean} Returns `true` if `n` is in the range, else `false`.
                     * @example
                     *
                     * _.inRange(3, 2, 4);
                     * // => true
                     *
                     * _.inRange(4, 8);
                     * // => true
                     *
                     * _.inRange(4, 2);
                     * // => false
                     *
                     * _.inRange(2, 2);
                     * // => false
                     *
                     * _.inRange(1.2, 2);
                     * // => true
                     *
                     * _.inRange(5.2, 4);
                     * // => false
                     */
                    function inRange(value, start, end) {
                        start = +start || 0;
                        if (end === undefined) {
                            end = start;
                            start = 0;
                        } else {
                            end = +end || 0;
                        }
                        return value >= nativeMin(start, end) && value < nativeMax(start, end);
                    }

                    /**
                     * Produces a random number between `min` and `max` (inclusive). If only one
                     * argument is provided a number between `0` and the given number is returned.
                     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
                     * number is returned instead of an integer.
                     *
                     * @static
                     * @memberOf _
                     * @category Number
                     * @param {number} [min=0] The minimum possible value.
                     * @param {number} [max=1] The maximum possible value.
                     * @param {boolean} [floating] Specify returning a floating-point number.
                     * @returns {number} Returns the random number.
                     * @example
                     *
                     * _.random(0, 5);
                     * // => an integer between 0 and 5
                     *
                     * _.random(5);
                     * // => also an integer between 0 and 5
                     *
                     * _.random(5, true);
                     * // => a floating-point number between 0 and 5
                     *
                     * _.random(1.2, 5.2);
                     * // => a floating-point number between 1.2 and 5.2
                     */
                    function random(min, max, floating) {
                        if (floating && isIterateeCall(min, max, floating)) {
                            max = floating = undefined;
                        }
                        var noMin = min == null,
                            noMax = max == null;

                        if (floating == null) {
                            if (noMax && typeof min == 'boolean') {
                                floating = min;
                                min = 1;
                            } else if (typeof max == 'boolean') {
                                floating = max;
                                noMax = true;
                            }
                        }
                        if (noMin && noMax) {
                            max = 1;
                            noMax = false;
                        }
                        min = +min || 0;
                        if (noMax) {
                            max = min;
                            min = 0;
                        } else {
                            max = +max || 0;
                        }
                        if (floating || min % 1 || max % 1) {
                            var rand = nativeRandom();
                            return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
                        }
                        return baseRandom(min, max);
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to convert.
                     * @returns {string} Returns the camel cased string.
                     * @example
                     *
                     * _.camelCase('Foo Bar');
                     * // => 'fooBar'
                     *
                     * _.camelCase('--foo-bar');
                     * // => 'fooBar'
                     *
                     * _.camelCase('__foo_bar__');
                     * // => 'fooBar'
                     */
                    var camelCase = createCompounder(function(result, word, index) {
                        word = word.toLowerCase();
                        return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
                    });

                    /**
                     * Capitalizes the first character of `string`.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to capitalize.
                     * @returns {string} Returns the capitalized string.
                     * @example
                     *
                     * _.capitalize('fred');
                     * // => 'Fred'
                     */
                    function capitalize(string) {
                        string = baseToString(string);
                        return string && (string.charAt(0).toUpperCase() + string.slice(1));
                    }

                    /**
                     * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
                     * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to deburr.
                     * @returns {string} Returns the deburred string.
                     * @example
                     *
                     * _.deburr('dj vu');
                     * // => 'deja vu'
                     */
                    function deburr(string) {
                        string = baseToString(string);
                        return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
                    }

                    /**
                     * Checks if `string` ends with the given target string.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to search.
                     * @param {string} [target] The string to search for.
                     * @param {number} [position=string.length] The position to search from.
                     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
                     * @example
                     *
                     * _.endsWith('abc', 'c');
                     * // => true
                     *
                     * _.endsWith('abc', 'b');
                     * // => false
                     *
                     * _.endsWith('abc', 'b', 2);
                     * // => true
                     */
                    function endsWith(string, target, position) {
                        string = baseToString(string);
                        target = (target + '');

                        var length = string.length;
                        position = position === undefined ?
                            length :
                            nativeMin(position < 0 ? 0 : (+position || 0), length);

                        position -= target.length;
                        return position >= 0 && string.indexOf(target, position) == position;
                    }

                    /**
                     * Converts the characters "&", "<", ">", '"', "'", and "\`", in `string` to
                     * their corresponding HTML entities.
                     *
                     * **Note:** No other characters are escaped. To escape additional characters
                     * use a third-party library like [_he_](https://mths.be/he).
                     *
                     * Though the ">" character is escaped for symmetry, characters like
                     * ">" and "/" don't need escaping in HTML and have no special meaning
                     * unless they're part of a tag or unquoted attribute value.
                     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
                     * (under "semi-related fun fact") for more details.
                     *
                     * Backticks are escaped because in Internet Explorer < 9, they can break out
                     * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),
                     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
                     * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
                     * for more details.
                     *
                     * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
                     * to reduce XSS vectors.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to escape.
                     * @returns {string} Returns the escaped string.
                     * @example
                     *
                     * _.escape('fred, barney, & pebbles');
                     * // => 'fred, barney, &amp; pebbles'
                     */
                    function escape(string) {
                        // Reset `lastIndex` because in IE < 9 `String#replace` does not.
                        string = baseToString(string);
                        return (string && reHasUnescapedHtml.test(string)) ?
                            string.replace(reUnescapedHtml, escapeHtmlChar) :
                            string;
                    }

                    /**
                     * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
                     * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to escape.
                     * @returns {string} Returns the escaped string.
                     * @example
                     *
                     * _.escapeRegExp('[lodash](https://lodash.com/)');
                     * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
                     */
                    function escapeRegExp(string) {
                        string = baseToString(string);
                        return (string && reHasRegExpChars.test(string)) ?
                            string.replace(reRegExpChars, escapeRegExpChar) :
                            (string || '(?:)');
                    }

                    /**
                     * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to convert.
                     * @returns {string} Returns the kebab cased string.
                     * @example
                     *
                     * _.kebabCase('Foo Bar');
                     * // => 'foo-bar'
                     *
                     * _.kebabCase('fooBar');
                     * // => 'foo-bar'
                     *
                     * _.kebabCase('__foo_bar__');
                     * // => 'foo-bar'
                     */
                    var kebabCase = createCompounder(function(result, word, index) {
                        return result + (index ? '-' : '') + word.toLowerCase();
                    });

                    /**
                     * Pads `string` on the left and right sides if it's shorter than `length`.
                     * Padding characters are truncated if they can't be evenly divided by `length`.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to pad.
                     * @param {number} [length=0] The padding length.
                     * @param {string} [chars=' '] The string used as padding.
                     * @returns {string} Returns the padded string.
                     * @example
                     *
                     * _.pad('abc', 8);
                     * // => '  abc   '
                     *
                     * _.pad('abc', 8, '_-');
                     * // => '_-abc_-_'
                     *
                     * _.pad('abc', 3);
                     * // => 'abc'
                     */
                    function pad(string, length, chars) {
                        string = baseToString(string);
                        length = +length;

                        var strLength = string.length;
                        if (strLength >= length || !nativeIsFinite(length)) {
                            return string;
                        }
                        var mid = (length - strLength) / 2,
                            leftLength = nativeFloor(mid),
                            rightLength = nativeCeil(mid);

                        chars = createPadding('', rightLength, chars);
                        return chars.slice(0, leftLength) + string + chars;
                    }

                    /**
                     * Pads `string` on the left side if it's shorter than `length`. Padding
                     * characters are truncated if they exceed `length`.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to pad.
                     * @param {number} [length=0] The padding length.
                     * @param {string} [chars=' '] The string used as padding.
                     * @returns {string} Returns the padded string.
                     * @example
                     *
                     * _.padLeft('abc', 6);
                     * // => '   abc'
                     *
                     * _.padLeft('abc', 6, '_-');
                     * // => '_-_abc'
                     *
                     * _.padLeft('abc', 3);
                     * // => 'abc'
                     */
                    var padLeft = createPadDir();

                    /**
                     * Pads `string` on the right side if it's shorter than `length`. Padding
                     * characters are truncated if they exceed `length`.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to pad.
                     * @param {number} [length=0] The padding length.
                     * @param {string} [chars=' '] The string used as padding.
                     * @returns {string} Returns the padded string.
                     * @example
                     *
                     * _.padRight('abc', 6);
                     * // => 'abc   '
                     *
                     * _.padRight('abc', 6, '_-');
                     * // => 'abc_-_'
                     *
                     * _.padRight('abc', 3);
                     * // => 'abc'
                     */
                    var padRight = createPadDir(true);

                    /**
                     * Converts `string` to an integer of the specified radix. If `radix` is
                     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
                     * in which case a `radix` of `16` is used.
                     *
                     * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)
                     * of `parseInt`.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} string The string to convert.
                     * @param {number} [radix] The radix to interpret `value` by.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {number} Returns the converted integer.
                     * @example
                     *
                     * _.parseInt('08');
                     * // => 8
                     *
                     * _.map(['6', '08', '10'], _.parseInt);
                     * // => [6, 8, 10]
                     */
                    function parseInt(string, radix, guard) {
                        // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
                        // Chrome fails to trim leading <BOM> whitespace characters.
                        // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
                        if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
                            radix = 0;
                        } else if (radix) {
                            radix = +radix;
                        }
                        string = trim(string);
                        return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
                    }

                    /**
                     * Repeats the given string `n` times.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to repeat.
                     * @param {number} [n=0] The number of times to repeat the string.
                     * @returns {string} Returns the repeated string.
                     * @example
                     *
                     * _.repeat('*', 3);
                     * // => '***'
                     *
                     * _.repeat('abc', 2);
                     * // => 'abcabc'
                     *
                     * _.repeat('abc', 0);
                     * // => ''
                     */
                    function repeat(string, n) {
                        var result = '';
                        string = baseToString(string);
                        n = +n;
                        if (n < 1 || !string || !nativeIsFinite(n)) {
                            return result;
                        }
                        // Leverage the exponentiation by squaring algorithm for a faster repeat.
                        // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
                        do {
                            if (n % 2) {
                                result += string;
                            }
                            n = nativeFloor(n / 2);
                            string += string;
                        } while (n);

                        return result;
                    }

                    /**
                     * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to convert.
                     * @returns {string} Returns the snake cased string.
                     * @example
                     *
                     * _.snakeCase('Foo Bar');
                     * // => 'foo_bar'
                     *
                     * _.snakeCase('fooBar');
                     * // => 'foo_bar'
                     *
                     * _.snakeCase('--foo-bar');
                     * // => 'foo_bar'
                     */
                    var snakeCase = createCompounder(function(result, word, index) {
                        return result + (index ? '_' : '') + word.toLowerCase();
                    });

                    /**
                     * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to convert.
                     * @returns {string} Returns the start cased string.
                     * @example
                     *
                     * _.startCase('--foo-bar');
                     * // => 'Foo Bar'
                     *
                     * _.startCase('fooBar');
                     * // => 'Foo Bar'
                     *
                     * _.startCase('__foo_bar__');
                     * // => 'Foo Bar'
                     */
                    var startCase = createCompounder(function(result, word, index) {
                        return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
                    });

                    /**
                     * Checks if `string` starts with the given target string.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to search.
                     * @param {string} [target] The string to search for.
                     * @param {number} [position=0] The position to search from.
                     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
                     * @example
                     *
                     * _.startsWith('abc', 'a');
                     * // => true
                     *
                     * _.startsWith('abc', 'b');
                     * // => false
                     *
                     * _.startsWith('abc', 'b', 1);
                     * // => true
                     */
                    function startsWith(string, target, position) {
                        string = baseToString(string);
                        position = position == null ?
                            0 :
                            nativeMin(position < 0 ? 0 : (+position || 0), string.length);

                        return string.lastIndexOf(target, position) == position;
                    }

                    /**
                     * Creates a compiled template function that can interpolate data properties
                     * in "interpolate" delimiters, HTML-escape interpolated data properties in
                     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
                     * properties may be accessed as free variables in the template. If a setting
                     * object is provided it takes precedence over `_.templateSettings` values.
                     *
                     * **Note:** In the development build `_.template` utilizes
                     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
                     * for easier debugging.
                     *
                     * For more information on precompiling templates see
                     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
                     *
                     * For more information on Chrome extension sandboxes see
                     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The template string.
                     * @param {Object} [options] The options object.
                     * @param {RegExp} [options.escape] The HTML "escape" delimiter.
                     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
                     * @param {Object} [options.imports] An object to import into the template as free variables.
                     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
                     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
                     * @param {string} [options.variable] The data object variable name.
                     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
                     * @returns {Function} Returns the compiled template function.
                     * @example
                     *
                     * // using the "interpolate" delimiter to create a compiled template
                     * var compiled = _.template('hello <%= user %>!');
                     * compiled({ 'user': 'fred' });
                     * // => 'hello fred!'
                     *
                     * // using the HTML "escape" delimiter to escape data property values
                     * var compiled = _.template('<b><%- value %></b>');
                     * compiled({ 'value': '<script>' });
                     * // => '<b>&lt;script&gt;</b>'
                     *
                     * // using the "evaluate" delimiter to execute JavaScript and generate HTML
                     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
                     * compiled({ 'users': ['fred', 'barney'] });
                     * // => '<li>fred</li><li>barney</li>'
                     *
                     * // using the internal `print` function in "evaluate" delimiters
                     * var compiled = _.template('<% print("hello " + user); %>!');
                     * compiled({ 'user': 'barney' });
                     * // => 'hello barney!'
                     *
                     * // using the ES delimiter as an alternative to the default "interpolate" delimiter
                     * var compiled = _.template('hello ${ user }!');
                     * compiled({ 'user': 'pebbles' });
                     * // => 'hello pebbles!'
                     *
                     * // using custom template delimiters
                     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
                     * var compiled = _.template('hello {{ user }}!');
                     * compiled({ 'user': 'mustache' });
                     * // => 'hello mustache!'
                     *
                     * // using backslashes to treat delimiters as plain text
                     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
                     * compiled({ 'value': 'ignored' });
                     * // => '<%- value %>'
                     *
                     * // using the `imports` option to import `jQuery` as `jq`
                     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
                     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
                     * compiled({ 'users': ['fred', 'barney'] });
                     * // => '<li>fred</li><li>barney</li>'
                     *
                     * // using the `sourceURL` option to specify a custom sourceURL for the template
                     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
                     * compiled(data);
                     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
                     *
                     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
                     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
                     * compiled.source;
                     * // => function(data) {
                     * //   var __t, __p = '';
                     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
                     * //   return __p;
                     * // }
                     *
                     * // using the `source` property to inline compiled templates for meaningful
                     * // line numbers in error messages and a stack trace
                     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
                     *   var JST = {\
                     *     "main": ' + _.template(mainText).source + '\
                     *   };\
                     * ');
                     */
                    function template(string, options, otherOptions) {
                        // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
                        // and Laura Doktorova's doT.js (https://github.com/olado/doT).
                        var settings = lodash.templateSettings;

                        if (otherOptions && isIterateeCall(string, options, otherOptions)) {
                            options = otherOptions = undefined;
                        }
                        string = baseToString(string);
                        options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

                        var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
                            importsKeys = keys(imports),
                            importsValues = baseValues(imports, importsKeys);

                        var isEscaping,
                            isEvaluating,
                            index = 0,
                            interpolate = options.interpolate || reNoMatch,
                            source = "__p += '";

                        // Compile the regexp to match each delimiter.
                        var reDelimiters = RegExp(
                            (options.escape || reNoMatch).source + '|' +
                            interpolate.source + '|' +
                            (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
                            (options.evaluate || reNoMatch).source + '|$', 'g');

                        // Use a sourceURL for easier debugging.
                        var sourceURL = '//# sourceURL=' +
                            ('sourceURL' in options ?
                                options.sourceURL :
                                ('lodash.templateSources[' + (++templateCounter) + ']')
                            ) + '\n';

                        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                            interpolateValue || (interpolateValue = esTemplateValue);

                            // Escape characters that can't be included in string literals.
                            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

                            // Replace delimiters with snippets.
                            if (escapeValue) {
                                isEscaping = true;
                                source += "' +\n__e(" + escapeValue + ") +\n'";
                            }
                            if (evaluateValue) {
                                isEvaluating = true;
                                source += "';\n" + evaluateValue + ";\n__p += '";
                            }
                            if (interpolateValue) {
                                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                            }
                            index = offset + match.length;

                            // The JS engine embedded in Adobe products requires returning the `match`
                            // string in order to produce the correct `offset` value.
                            return match;
                        });

                        source += "';\n";

                        // If `variable` is not specified wrap a with-statement around the generated
                        // code to add the data object to the top of the scope chain.
                        var variable = options.variable;
                        if (!variable) {
                            source = 'with (obj) {\n' + source + '\n}\n';
                        }
                        // Cleanup code by stripping empty strings.
                        source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
                            .replace(reEmptyStringMiddle, '$1')
                            .replace(reEmptyStringTrailing, '$1;');

                        // Frame code as the function body.
                        source = 'function(' + (variable || 'obj') + ') {\n' +
                            (variable ?
                                '' :
                                'obj || (obj = {});\n'
                            ) +
                            "var __t, __p = ''" +
                            (isEscaping ?
                                ', __e = _.escape' :
                                ''
                            ) +
                            (isEvaluating ?
                                ', __j = Array.prototype.join;\n' +
                                "function print() { __p += __j.call(arguments, '') }\n" :
                                ';\n'
                            ) +
                            source +
                            'return __p\n}';

                        var result = attempt(function() {
                            return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
                        });

                        // Provide the compiled function's source by its `toString` method or
                        // the `source` property as a convenience for inlining compiled templates.
                        result.source = source;
                        if (isError(result)) {
                            throw result;
                        }
                        return result;
                    }

                    /**
                     * Removes leading and trailing whitespace or specified characters from `string`.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to trim.
                     * @param {string} [chars=whitespace] The characters to trim.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {string} Returns the trimmed string.
                     * @example
                     *
                     * _.trim('  abc  ');
                     * // => 'abc'
                     *
                     * _.trim('-_-abc-_-', '_-');
                     * // => 'abc'
                     *
                     * _.map(['  foo  ', '  bar  '], _.trim);
                     * // => ['foo', 'bar']
                     */
                    function trim(string, chars, guard) {
                        var value = string;
                        string = baseToString(string);
                        if (!string) {
                            return string;
                        }
                        if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
                            return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
                        }
                        chars = (chars + '');
                        return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
                    }

                    /**
                     * Removes leading whitespace or specified characters from `string`.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to trim.
                     * @param {string} [chars=whitespace] The characters to trim.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {string} Returns the trimmed string.
                     * @example
                     *
                     * _.trimLeft('  abc  ');
                     * // => 'abc  '
                     *
                     * _.trimLeft('-_-abc-_-', '_-');
                     * // => 'abc-_-'
                     */
                    function trimLeft(string, chars, guard) {
                        var value = string;
                        string = baseToString(string);
                        if (!string) {
                            return string;
                        }
                        if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
                            return string.slice(trimmedLeftIndex(string));
                        }
                        return string.slice(charsLeftIndex(string, (chars + '')));
                    }

                    /**
                     * Removes trailing whitespace or specified characters from `string`.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to trim.
                     * @param {string} [chars=whitespace] The characters to trim.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {string} Returns the trimmed string.
                     * @example
                     *
                     * _.trimRight('  abc  ');
                     * // => '  abc'
                     *
                     * _.trimRight('-_-abc-_-', '_-');
                     * // => '-_-abc'
                     */
                    function trimRight(string, chars, guard) {
                        var value = string;
                        string = baseToString(string);
                        if (!string) {
                            return string;
                        }
                        if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
                            return string.slice(0, trimmedRightIndex(string) + 1);
                        }
                        return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
                    }

                    /**
                     * Truncates `string` if it's longer than the given maximum string length.
                     * The last characters of the truncated string are replaced with the omission
                     * string which defaults to "...".
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to truncate.
                     * @param {Object|number} [options] The options object or maximum string length.
                     * @param {number} [options.length=30] The maximum string length.
                     * @param {string} [options.omission='...'] The string to indicate text is omitted.
                     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {string} Returns the truncated string.
                     * @example
                     *
                     * _.trunc('hi-diddly-ho there, neighborino');
                     * // => 'hi-diddly-ho there, neighbo...'
                     *
                     * _.trunc('hi-diddly-ho there, neighborino', 24);
                     * // => 'hi-diddly-ho there, n...'
                     *
                     * _.trunc('hi-diddly-ho there, neighborino', {
                     *   'length': 24,
                     *   'separator': ' '
                     * });
                     * // => 'hi-diddly-ho there,...'
                     *
                     * _.trunc('hi-diddly-ho there, neighborino', {
                     *   'length': 24,
                     *   'separator': /,? +/
                     * });
                     * // => 'hi-diddly-ho there...'
                     *
                     * _.trunc('hi-diddly-ho there, neighborino', {
                     *   'omission': ' [...]'
                     * });
                     * // => 'hi-diddly-ho there, neig [...]'
                     */
                    function trunc(string, options, guard) {
                        if (guard && isIterateeCall(string, options, guard)) {
                            options = undefined;
                        }
                        var length = DEFAULT_TRUNC_LENGTH,
                            omission = DEFAULT_TRUNC_OMISSION;

                        if (options != null) {
                            if (isObject(options)) {
                                var separator = 'separator' in options ? options.separator : separator;
                                length = 'length' in options ? (+options.length || 0) : length;
                                omission = 'omission' in options ? baseToString(options.omission) : omission;
                            } else {
                                length = +options || 0;
                            }
                        }
                        string = baseToString(string);
                        if (length >= string.length) {
                            return string;
                        }
                        var end = length - omission.length;
                        if (end < 1) {
                            return omission;
                        }
                        var result = string.slice(0, end);
                        if (separator == null) {
                            return result + omission;
                        }
                        if (isRegExp(separator)) {
                            if (string.slice(end).search(separator)) {
                                var match,
                                    newEnd,
                                    substring = string.slice(0, end);

                                if (!separator.global) {
                                    separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
                                }
                                separator.lastIndex = 0;
                                while ((match = separator.exec(substring))) {
                                    newEnd = match.index;
                                }
                                result = result.slice(0, newEnd == null ? end : newEnd);
                            }
                        } else if (string.indexOf(separator, end) != end) {
                            var index = result.lastIndexOf(separator);
                            if (index > -1) {
                                result = result.slice(0, index);
                            }
                        }
                        return result + omission;
                    }

                    /**
                     * The inverse of `_.escape`; this method converts the HTML entities
                     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
                     * corresponding characters.
                     *
                     * **Note:** No other HTML entities are unescaped. To unescape additional HTML
                     * entities use a third-party library like [_he_](https://mths.be/he).
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to unescape.
                     * @returns {string} Returns the unescaped string.
                     * @example
                     *
                     * _.unescape('fred, barney, &amp; pebbles');
                     * // => 'fred, barney, & pebbles'
                     */
                    function unescape(string) {
                        string = baseToString(string);
                        return (string && reHasEscapedHtml.test(string)) ?
                            string.replace(reEscapedHtml, unescapeHtmlChar) :
                            string;
                    }

                    /**
                     * Splits `string` into an array of its words.
                     *
                     * @static
                     * @memberOf _
                     * @category String
                     * @param {string} [string=''] The string to inspect.
                     * @param {RegExp|string} [pattern] The pattern to match words.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Array} Returns the words of `string`.
                     * @example
                     *
                     * _.words('fred, barney, & pebbles');
                     * // => ['fred', 'barney', 'pebbles']
                     *
                     * _.words('fred, barney, & pebbles', /[^, ]+/g);
                     * // => ['fred', 'barney', '&', 'pebbles']
                     */
                    function words(string, pattern, guard) {
                        if (guard && isIterateeCall(string, pattern, guard)) {
                            pattern = undefined;
                        }
                        string = baseToString(string);
                        return string.match(pattern || reWords) || [];
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Attempts to invoke `func`, returning either the result or the caught error
                     * object. Any additional arguments are provided to `func` when it is invoked.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {Function} func The function to attempt.
                     * @returns {*} Returns the `func` result or error object.
                     * @example
                     *
                     * // avoid throwing errors for invalid selectors
                     * var elements = _.attempt(function(selector) {
                     *   return document.querySelectorAll(selector);
                     * }, '>_>');
                     *
                     * if (_.isError(elements)) {
                     *   elements = [];
                     * }
                     */
                    var attempt = restParam(function(func, args) {
                        try {
                            return func.apply(undefined, args);
                        } catch (e) {
                            return isError(e) ? e : new Error(e);
                        }
                    });

                    /**
                     * Creates a function that invokes `func` with the `this` binding of `thisArg`
                     * and arguments of the created function. If `func` is a property name the
                     * created callback returns the property value for a given element. If `func`
                     * is an object the created callback returns `true` for elements that contain
                     * the equivalent object properties, otherwise it returns `false`.
                     *
                     * @static
                     * @memberOf _
                     * @alias iteratee
                     * @category Utility
                     * @param {*} [func=_.identity] The value to convert to a callback.
                     * @param {*} [thisArg] The `this` binding of `func`.
                     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
                     * @returns {Function} Returns the callback.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney', 'age': 36 },
                     *   { 'user': 'fred',   'age': 40 }
                     * ];
                     *
                     * // wrap to create custom callback shorthands
                     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
                     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
                     *   if (!match) {
                     *     return callback(func, thisArg);
                     *   }
                     *   return function(object) {
                     *     return match[2] == 'gt'
                     *       ? object[match[1]] > match[3]
                     *       : object[match[1]] < match[3];
                     *   };
                     * });
                     *
                     * _.filter(users, 'age__gt36');
                     * // => [{ 'user': 'fred', 'age': 40 }]
                     */
                    function callback(func, thisArg, guard) {
                        if (guard && isIterateeCall(func, thisArg, guard)) {
                            thisArg = undefined;
                        }
                        return isObjectLike(func) ?
                            matches(func) :
                            baseCallback(func, thisArg);
                    }

                    /**
                     * Creates a function that returns `value`.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {*} value The value to return from the new function.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var object = { 'user': 'fred' };
                     * var getter = _.constant(object);
                     *
                     * getter() === object;
                     * // => true
                     */
                    function constant(value) {
                        return function() {
                            return value;
                        };
                    }

                    /**
                     * This method returns the first argument provided to it.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {*} value Any value.
                     * @returns {*} Returns `value`.
                     * @example
                     *
                     * var object = { 'user': 'fred' };
                     *
                     * _.identity(object) === object;
                     * // => true
                     */
                    function identity(value) {
                        return value;
                    }

                    /**
                     * Creates a function that performs a deep comparison between a given object
                     * and `source`, returning `true` if the given object has equivalent property
                     * values, else `false`.
                     *
                     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
                     * numbers, `Object` objects, regexes, and strings. Objects are compared by
                     * their own, not inherited, enumerable properties. For comparing a single
                     * own or inherited property value see `_.matchesProperty`.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {Object} source The object of property values to match.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney', 'age': 36, 'active': true },
                     *   { 'user': 'fred',   'age': 40, 'active': false }
                     * ];
                     *
                     * _.filter(users, _.matches({ 'age': 40, 'active': false }));
                     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
                     */
                    function matches(source) {
                        return baseMatches(baseClone(source, true));
                    }

                    /**
                     * Creates a function that compares the property value of `path` on a given
                     * object to `value`.
                     *
                     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
                     * numbers, `Object` objects, regexes, and strings. Objects are compared by
                     * their own, not inherited, enumerable properties.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {Array|string} path The path of the property to get.
                     * @param {*} srcValue The value to match.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var users = [
                     *   { 'user': 'barney' },
                     *   { 'user': 'fred' }
                     * ];
                     *
                     * _.find(users, _.matchesProperty('user', 'fred'));
                     * // => { 'user': 'fred' }
                     */
                    function matchesProperty(path, srcValue) {
                        return baseMatchesProperty(path, baseClone(srcValue, true));
                    }

                    /**
                     * Creates a function that invokes the method at `path` on a given object.
                     * Any additional arguments are provided to the invoked method.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {Array|string} path The path of the method to invoke.
                     * @param {...*} [args] The arguments to invoke the method with.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var objects = [
                     *   { 'a': { 'b': { 'c': _.constant(2) } } },
                     *   { 'a': { 'b': { 'c': _.constant(1) } } }
                     * ];
                     *
                     * _.map(objects, _.method('a.b.c'));
                     * // => [2, 1]
                     *
                     * _.invoke(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');
                     * // => [1, 2]
                     */
                    var method = restParam(function(path, args) {
                        return function(object) {
                            return invokePath(object, path, args);
                        };
                    });

                    /**
                     * The opposite of `_.method`; this method creates a function that invokes
                     * the method at a given path on `object`. Any additional arguments are
                     * provided to the invoked method.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {Object} object The object to query.
                     * @param {...*} [args] The arguments to invoke the method with.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var array = _.times(3, _.constant),
                     *     object = { 'a': array, 'b': array, 'c': array };
                     *
                     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
                     * // => [2, 0]
                     *
                     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
                     * // => [2, 0]
                     */
                    var methodOf = restParam(function(object, args) {
                        return function(path) {
                            return invokePath(object, path, args);
                        };
                    });

                    /**
                     * Adds all own enumerable function properties of a source object to the
                     * destination object. If `object` is a function then methods are added to
                     * its prototype as well.
                     *
                     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
                     * avoid conflicts caused by modifying the original.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {Function|Object} [object=lodash] The destination object.
                     * @param {Object} source The object of functions to add.
                     * @param {Object} [options] The options object.
                     * @param {boolean} [options.chain=true] Specify whether the functions added
                     *  are chainable.
                     * @returns {Function|Object} Returns `object`.
                     * @example
                     *
                     * function vowels(string) {
                     *   return _.filter(string, function(v) {
                     *     return /[aeiou]/i.test(v);
                     *   });
                     * }
                     *
                     * _.mixin({ 'vowels': vowels });
                     * _.vowels('fred');
                     * // => ['e']
                     *
                     * _('fred').vowels().value();
                     * // => ['e']
                     *
                     * _.mixin({ 'vowels': vowels }, { 'chain': false });
                     * _('fred').vowels();
                     * // => ['e']
                     */
                    function mixin(object, source, options) {
                        if (options == null) {
                            var isObj = isObject(source),
                                props = isObj ? keys(source) : undefined,
                                methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;

                            if (!(methodNames ? methodNames.length : isObj)) {
                                methodNames = false;
                                options = source;
                                source = object;
                                object = this;
                            }
                        }
                        if (!methodNames) {
                            methodNames = baseFunctions(source, keys(source));
                        }
                        var chain = true,
                            index = -1,
                            isFunc = isFunction(object),
                            length = methodNames.length;

                        if (options === false) {
                            chain = false;
                        } else if (isObject(options) && 'chain' in options) {
                            chain = options.chain;
                        }
                        while (++index < length) {
                            var methodName = methodNames[index],
                                func = source[methodName];

                            object[methodName] = func;
                            if (isFunc) {
                                object.prototype[methodName] = (function(func) {
                                    return function() {
                                        var chainAll = this.__chain__;
                                        if (chain || chainAll) {
                                            var result = object(this.__wrapped__),
                                                actions = result.__actions__ = arrayCopy(this.__actions__);

                                            actions.push({
                                                'func': func,
                                                'args': arguments,
                                                'thisArg': object
                                            });
                                            result.__chain__ = chainAll;
                                            return result;
                                        }
                                        return func.apply(object, arrayPush([this.value()], arguments));
                                    };
                                }(func));
                            }
                        }
                        return object;
                    }

                    /**
                     * Reverts the `_` variable to its previous value and returns a reference to
                     * the `lodash` function.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @returns {Function} Returns the `lodash` function.
                     * @example
                     *
                     * var lodash = _.noConflict();
                     */
                    function noConflict() {
                        root._ = oldDash;
                        return this;
                    }

                    /**
                     * A no-operation function that returns `undefined` regardless of the
                     * arguments it receives.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @example
                     *
                     * var object = { 'user': 'fred' };
                     *
                     * _.noop(object) === undefined;
                     * // => true
                     */
                    function noop() {
                        // No operation performed.
                    }

                    /**
                     * Creates a function that returns the property value at `path` on a
                     * given object.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {Array|string} path The path of the property to get.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var objects = [
                     *   { 'a': { 'b': { 'c': 2 } } },
                     *   { 'a': { 'b': { 'c': 1 } } }
                     * ];
                     *
                     * _.map(objects, _.property('a.b.c'));
                     * // => [2, 1]
                     *
                     * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
                     * // => [1, 2]
                     */
                    function property(path) {
                        return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
                    }

                    /**
                     * The opposite of `_.property`; this method creates a function that returns
                     * the property value at a given path on `object`.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {Object} object The object to query.
                     * @returns {Function} Returns the new function.
                     * @example
                     *
                     * var array = [0, 1, 2],
                     *     object = { 'a': array, 'b': array, 'c': array };
                     *
                     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
                     * // => [2, 0]
                     *
                     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
                     * // => [2, 0]
                     */
                    function propertyOf(object) {
                        return function(path) {
                            return baseGet(object, toPath(path), path + '');
                        };
                    }

                    /**
                     * Creates an array of numbers (positive and/or negative) progressing from
                     * `start` up to, but not including, `end`. If `end` is not specified it is
                     * set to `start` with `start` then set to `0`. If `end` is less than `start`
                     * a zero-length range is created unless a negative `step` is specified.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {number} [start=0] The start of the range.
                     * @param {number} end The end of the range.
                     * @param {number} [step=1] The value to increment or decrement by.
                     * @returns {Array} Returns the new array of numbers.
                     * @example
                     *
                     * _.range(4);
                     * // => [0, 1, 2, 3]
                     *
                     * _.range(1, 5);
                     * // => [1, 2, 3, 4]
                     *
                     * _.range(0, 20, 5);
                     * // => [0, 5, 10, 15]
                     *
                     * _.range(0, -4, -1);
                     * // => [0, -1, -2, -3]
                     *
                     * _.range(1, 4, 0);
                     * // => [1, 1, 1]
                     *
                     * _.range(0);
                     * // => []
                     */
                    function range(start, end, step) {
                        if (step && isIterateeCall(start, end, step)) {
                            end = step = undefined;
                        }
                        start = +start || 0;
                        step = step == null ? 1 : (+step || 0);

                        if (end == null) {
                            end = start;
                            start = 0;
                        } else {
                            end = +end || 0;
                        }
                        // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
                        // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
                        var index = -1,
                            length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
                            result = Array(length);

                        while (++index < length) {
                            result[index] = start;
                            start += step;
                        }
                        return result;
                    }

                    /**
                     * Invokes the iteratee function `n` times, returning an array of the results
                     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
                     * one argument; (index).
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {number} n The number of times to invoke `iteratee`.
                     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {Array} Returns the array of results.
                     * @example
                     *
                     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
                     * // => [3, 6, 4]
                     *
                     * _.times(3, function(n) {
                     *   mage.castSpell(n);
                     * });
                     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2`
                     *
                     * _.times(3, function(n) {
                     *   this.cast(n);
                     * }, mage);
                     * // => also invokes `mage.castSpell(n)` three times
                     */
                    function times(n, iteratee, thisArg) {
                        n = nativeFloor(n);

                        // Exit early to avoid a JSC JIT bug in Safari 8
                        // where `Array(0)` is treated as `Array(1)`.
                        if (n < 1 || !nativeIsFinite(n)) {
                            return [];
                        }
                        var index = -1,
                            result = Array(nativeMin(n, MAX_ARRAY_LENGTH));

                        iteratee = bindCallback(iteratee, thisArg, 1);
                        while (++index < n) {
                            if (index < MAX_ARRAY_LENGTH) {
                                result[index] = iteratee(index);
                            } else {
                                iteratee(index);
                            }
                        }
                        return result;
                    }

                    /**
                     * Generates a unique ID. If `prefix` is provided the ID is appended to it.
                     *
                     * @static
                     * @memberOf _
                     * @category Utility
                     * @param {string} [prefix] The value to prefix the ID with.
                     * @returns {string} Returns the unique ID.
                     * @example
                     *
                     * _.uniqueId('contact_');
                     * // => 'contact_104'
                     *
                     * _.uniqueId();
                     * // => '105'
                     */
                    function uniqueId(prefix) {
                        var id = ++idCounter;
                        return baseToString(prefix) + id;
                    }

                    /*------------------------------------------------------------------------*/

                    /**
                     * Adds two numbers.
                     *
                     * @static
                     * @memberOf _
                     * @category Math
                     * @param {number} augend The first number to add.
                     * @param {number} addend The second number to add.
                     * @returns {number} Returns the sum.
                     * @example
                     *
                     * _.add(6, 4);
                     * // => 10
                     */
                    function add(augend, addend) {
                        return (+augend || 0) + (+addend || 0);
                    }

                    /**
                     * Calculates `n` rounded up to `precision`.
                     *
                     * @static
                     * @memberOf _
                     * @category Math
                     * @param {number} n The number to round up.
                     * @param {number} [precision=0] The precision to round up to.
                     * @returns {number} Returns the rounded up number.
                     * @example
                     *
                     * _.ceil(4.006);
                     * // => 5
                     *
                     * _.ceil(6.004, 2);
                     * // => 6.01
                     *
                     * _.ceil(6040, -2);
                     * // => 6100
                     */
                    var ceil = createRound('ceil');

                    /**
                     * Calculates `n` rounded down to `precision`.
                     *
                     * @static
                     * @memberOf _
                     * @category Math
                     * @param {number} n The number to round down.
                     * @param {number} [precision=0] The precision to round down to.
                     * @returns {number} Returns the rounded down number.
                     * @example
                     *
                     * _.floor(4.006);
                     * // => 4
                     *
                     * _.floor(0.046, 2);
                     * // => 0.04
                     *
                     * _.floor(4060, -2);
                     * // => 4000
                     */
                    var floor = createRound('floor');

                    /**
                     * Gets the maximum value of `collection`. If `collection` is empty or falsey
                     * `-Infinity` is returned. If an iteratee function is provided it is invoked
                     * for each value in `collection` to generate the criterion by which the value
                     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
                     * arguments: (value, index, collection).
                     *
                     * If a property name is provided for `iteratee` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `iteratee` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Math
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {*} Returns the maximum value.
                     * @example
                     *
                     * _.max([4, 2, 8, 6]);
                     * // => 8
                     *
                     * _.max([]);
                     * // => -Infinity
                     *
                     * var users = [
                     *   { 'user': 'barney', 'age': 36 },
                     *   { 'user': 'fred',   'age': 40 }
                     * ];
                     *
                     * _.max(users, function(chr) {
                     *   return chr.age;
                     * });
                     * // => { 'user': 'fred', 'age': 40 }
                     *
                     * // using the `_.property` callback shorthand
                     * _.max(users, 'age');
                     * // => { 'user': 'fred', 'age': 40 }
                     */
                    var max = createExtremum(gt, NEGATIVE_INFINITY);

                    /**
                     * Gets the minimum value of `collection`. If `collection` is empty or falsey
                     * `Infinity` is returned. If an iteratee function is provided it is invoked
                     * for each value in `collection` to generate the criterion by which the value
                     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
                     * arguments: (value, index, collection).
                     *
                     * If a property name is provided for `iteratee` the created `_.property`
                     * style callback returns the property value of the given element.
                     *
                     * If a value is also provided for `thisArg` the created `_.matchesProperty`
                     * style callback returns `true` for elements that have a matching property
                     * value, else `false`.
                     *
                     * If an object is provided for `iteratee` the created `_.matches` style
                     * callback returns `true` for elements that have the properties of the given
                     * object, else `false`.
                     *
                     * @static
                     * @memberOf _
                     * @category Math
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {*} Returns the minimum value.
                     * @example
                     *
                     * _.min([4, 2, 8, 6]);
                     * // => 2
                     *
                     * _.min([]);
                     * // => Infinity
                     *
                     * var users = [
                     *   { 'user': 'barney', 'age': 36 },
                     *   { 'user': 'fred',   'age': 40 }
                     * ];
                     *
                     * _.min(users, function(chr) {
                     *   return chr.age;
                     * });
                     * // => { 'user': 'barney', 'age': 36 }
                     *
                     * // using the `_.property` callback shorthand
                     * _.min(users, 'age');
                     * // => { 'user': 'barney', 'age': 36 }
                     */
                    var min = createExtremum(lt, POSITIVE_INFINITY);

                    /**
                     * Calculates `n` rounded to `precision`.
                     *
                     * @static
                     * @memberOf _
                     * @category Math
                     * @param {number} n The number to round.
                     * @param {number} [precision=0] The precision to round to.
                     * @returns {number} Returns the rounded number.
                     * @example
                     *
                     * _.round(4.006);
                     * // => 4
                     *
                     * _.round(4.006, 2);
                     * // => 4.01
                     *
                     * _.round(4060, -2);
                     * // => 4100
                     */
                    var round = createRound('round');

                    /**
                     * Gets the sum of the values in `collection`.
                     *
                     * @static
                     * @memberOf _
                     * @category Math
                     * @param {Array|Object|string} collection The collection to iterate over.
                     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
                     * @param {*} [thisArg] The `this` binding of `iteratee`.
                     * @returns {number} Returns the sum.
                     * @example
                     *
                     * _.sum([4, 6]);
                     * // => 10
                     *
                     * _.sum({ 'a': 4, 'b': 6 });
                     * // => 10
                     *
                     * var objects = [
                     *   { 'n': 4 },
                     *   { 'n': 6 }
                     * ];
                     *
                     * _.sum(objects, function(object) {
                     *   return object.n;
                     * });
                     * // => 10
                     *
                     * // using the `_.property` callback shorthand
                     * _.sum(objects, 'n');
                     * // => 10
                     */
                    function sum(collection, iteratee, thisArg) {
                        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
                            iteratee = undefined;
                        }
                        iteratee = getCallback(iteratee, thisArg, 3);
                        return iteratee.length == 1 ?
                            arraySum(isArray(collection) ? collection : toIterable(collection), iteratee) :
                            baseSum(collection, iteratee);
                    }

                    /*------------------------------------------------------------------------*/

                    // Ensure wrappers are instances of `baseLodash`.
                    lodash.prototype = baseLodash.prototype;

                    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
                    LodashWrapper.prototype.constructor = LodashWrapper;

                    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
                    LazyWrapper.prototype.constructor = LazyWrapper;

                    // Add functions to the `Map` cache.
                    MapCache.prototype['delete'] = mapDelete;
                    MapCache.prototype.get = mapGet;
                    MapCache.prototype.has = mapHas;
                    MapCache.prototype.set = mapSet;

                    // Add functions to the `Set` cache.
                    SetCache.prototype.push = cachePush;

                    // Assign cache to `_.memoize`.
                    memoize.Cache = MapCache;

                    // Add functions that return wrapped values when chaining.
                    lodash.after = after;
                    lodash.ary = ary;
                    lodash.assign = assign;
                    lodash.at = at;
                    lodash.before = before;
                    lodash.bind = bind;
                    lodash.bindAll = bindAll;
                    lodash.bindKey = bindKey;
                    lodash.callback = callback;
                    lodash.chain = chain;
                    lodash.chunk = chunk;
                    lodash.compact = compact;
                    lodash.constant = constant;
                    lodash.countBy = countBy;
                    lodash.create = create;
                    lodash.curry = curry;
                    lodash.curryRight = curryRight;
                    lodash.debounce = debounce;
                    lodash.defaults = defaults;
                    lodash.defaultsDeep = defaultsDeep;
                    lodash.defer = defer;
                    lodash.delay = delay;
                    lodash.difference = difference;
                    lodash.drop = drop;
                    lodash.dropRight = dropRight;
                    lodash.dropRightWhile = dropRightWhile;
                    lodash.dropWhile = dropWhile;
                    lodash.fill = fill;
                    lodash.filter = filter;
                    lodash.flatten = flatten;
                    lodash.flattenDeep = flattenDeep;
                    lodash.flow = flow;
                    lodash.flowRight = flowRight;
                    lodash.forEach = forEach;
                    lodash.forEachRight = forEachRight;
                    lodash.forIn = forIn;
                    lodash.forInRight = forInRight;
                    lodash.forOwn = forOwn;
                    lodash.forOwnRight = forOwnRight;
                    lodash.functions = functions;
                    lodash.groupBy = groupBy;
                    lodash.indexBy = indexBy;
                    lodash.initial = initial;
                    lodash.intersection = intersection;
                    lodash.invert = invert;
                    lodash.invoke = invoke;
                    lodash.keys = keys;
                    lodash.keysIn = keysIn;
                    lodash.map = map;
                    lodash.mapKeys = mapKeys;
                    lodash.mapValues = mapValues;
                    lodash.matches = matches;
                    lodash.matchesProperty = matchesProperty;
                    lodash.memoize = memoize;
                    lodash.merge = merge;
                    lodash.method = method;
                    lodash.methodOf = methodOf;
                    lodash.mixin = mixin;
                    lodash.modArgs = modArgs;
                    lodash.negate = negate;
                    lodash.omit = omit;
                    lodash.once = once;
                    lodash.pairs = pairs;
                    lodash.partial = partial;
                    lodash.partialRight = partialRight;
                    lodash.partition = partition;
                    lodash.pick = pick;
                    lodash.pluck = pluck;
                    lodash.property = property;
                    lodash.propertyOf = propertyOf;
                    lodash.pull = pull;
                    lodash.pullAt = pullAt;
                    lodash.range = range;
                    lodash.rearg = rearg;
                    lodash.reject = reject;
                    lodash.remove = remove;
                    lodash.rest = rest;
                    lodash.restParam = restParam;
                    lodash.set = set;
                    lodash.shuffle = shuffle;
                    lodash.slice = slice;
                    lodash.sortBy = sortBy;
                    lodash.sortByAll = sortByAll;
                    lodash.sortByOrder = sortByOrder;
                    lodash.spread = spread;
                    lodash.take = take;
                    lodash.takeRight = takeRight;
                    lodash.takeRightWhile = takeRightWhile;
                    lodash.takeWhile = takeWhile;
                    lodash.tap = tap;
                    lodash.throttle = throttle;
                    lodash.thru = thru;
                    lodash.times = times;
                    lodash.toArray = toArray;
                    lodash.toPlainObject = toPlainObject;
                    lodash.transform = transform;
                    lodash.union = union;
                    lodash.uniq = uniq;
                    lodash.unzip = unzip;
                    lodash.unzipWith = unzipWith;
                    lodash.values = values;
                    lodash.valuesIn = valuesIn;
                    lodash.where = where;
                    lodash.without = without;
                    lodash.wrap = wrap;
                    lodash.xor = xor;
                    lodash.zip = zip;
                    lodash.zipObject = zipObject;
                    lodash.zipWith = zipWith;

                    // Add aliases.
                    lodash.backflow = flowRight;
                    lodash.collect = map;
                    lodash.compose = flowRight;
                    lodash.each = forEach;
                    lodash.eachRight = forEachRight;
                    lodash.extend = assign;
                    lodash.iteratee = callback;
                    lodash.methods = functions;
                    lodash.object = zipObject;
                    lodash.select = filter;
                    lodash.tail = rest;
                    lodash.unique = uniq;

                    // Add functions to `lodash.prototype`.
                    mixin(lodash, lodash);

                    /*------------------------------------------------------------------------*/

                    // Add functions that return unwrapped values when chaining.
                    lodash.add = add;
                    lodash.attempt = attempt;
                    lodash.camelCase = camelCase;
                    lodash.capitalize = capitalize;
                    lodash.ceil = ceil;
                    lodash.clone = clone;
                    lodash.cloneDeep = cloneDeep;
                    lodash.deburr = deburr;
                    lodash.endsWith = endsWith;
                    lodash.escape = escape;
                    lodash.escapeRegExp = escapeRegExp;
                    lodash.every = every;
                    lodash.find = find;
                    lodash.findIndex = findIndex;
                    lodash.findKey = findKey;
                    lodash.findLast = findLast;
                    lodash.findLastIndex = findLastIndex;
                    lodash.findLastKey = findLastKey;
                    lodash.findWhere = findWhere;
                    lodash.first = first;
                    lodash.floor = floor;
                    lodash.get = get;
                    lodash.gt = gt;
                    lodash.gte = gte;
                    lodash.has = has;
                    lodash.identity = identity;
                    lodash.includes = includes;
                    lodash.indexOf = indexOf;
                    lodash.inRange = inRange;
                    lodash.isArguments = isArguments;
                    lodash.isArray = isArray;
                    lodash.isBoolean = isBoolean;
                    lodash.isDate = isDate;
                    lodash.isElement = isElement;
                    lodash.isEmpty = isEmpty;
                    lodash.isEqual = isEqual;
                    lodash.isError = isError;
                    lodash.isFinite = isFinite;
                    lodash.isFunction = isFunction;
                    lodash.isMatch = isMatch;
                    lodash.isNaN = isNaN;
                    lodash.isNative = isNative;
                    lodash.isNull = isNull;
                    lodash.isNumber = isNumber;
                    lodash.isObject = isObject;
                    lodash.isPlainObject = isPlainObject;
                    lodash.isRegExp = isRegExp;
                    lodash.isString = isString;
                    lodash.isTypedArray = isTypedArray;
                    lodash.isUndefined = isUndefined;
                    lodash.kebabCase = kebabCase;
                    lodash.last = last;
                    lodash.lastIndexOf = lastIndexOf;
                    lodash.lt = lt;
                    lodash.lte = lte;
                    lodash.max = max;
                    lodash.min = min;
                    lodash.noConflict = noConflict;
                    lodash.noop = noop;
                    lodash.now = now;
                    lodash.pad = pad;
                    lodash.padLeft = padLeft;
                    lodash.padRight = padRight;
                    lodash.parseInt = parseInt;
                    lodash.random = random;
                    lodash.reduce = reduce;
                    lodash.reduceRight = reduceRight;
                    lodash.repeat = repeat;
                    lodash.result = result;
                    lodash.round = round;
                    lodash.runInContext = runInContext;
                    lodash.size = size;
                    lodash.snakeCase = snakeCase;
                    lodash.some = some;
                    lodash.sortedIndex = sortedIndex;
                    lodash.sortedLastIndex = sortedLastIndex;
                    lodash.startCase = startCase;
                    lodash.startsWith = startsWith;
                    lodash.sum = sum;
                    lodash.template = template;
                    lodash.trim = trim;
                    lodash.trimLeft = trimLeft;
                    lodash.trimRight = trimRight;
                    lodash.trunc = trunc;
                    lodash.unescape = unescape;
                    lodash.uniqueId = uniqueId;
                    lodash.words = words;

                    // Add aliases.
                    lodash.all = every;
                    lodash.any = some;
                    lodash.contains = includes;
                    lodash.eq = isEqual;
                    lodash.detect = find;
                    lodash.foldl = reduce;
                    lodash.foldr = reduceRight;
                    lodash.head = first;
                    lodash.include = includes;
                    lodash.inject = reduce;

                    mixin(lodash, (function() {
                        var source = {};
                        baseForOwn(lodash, function(func, methodName) {
                            if (!lodash.prototype[methodName]) {
                                source[methodName] = func;
                            }
                        });
                        return source;
                    }()), false);

                    /*------------------------------------------------------------------------*/

                    // Add functions capable of returning wrapped and unwrapped values when chaining.
                    lodash.sample = sample;

                    lodash.prototype.sample = function(n) {
                        if (!this.__chain__ && n == null) {
                            return sample(this.value());
                        }
                        return this.thru(function(value) {
                            return sample(value, n);
                        });
                    };

                    /*------------------------------------------------------------------------*/

                    /**
                     * The semantic version number.
                     *
                     * @static
                     * @memberOf _
                     * @type string
                     */
                    lodash.VERSION = VERSION;

                    // Assign default placeholders.
                    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
                        lodash[methodName].placeholder = lodash;
                    });

                    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
                    arrayEach(['drop', 'take'], function(methodName, index) {
                        LazyWrapper.prototype[methodName] = function(n) {
                            var filtered = this.__filtered__;
                            if (filtered && !index) {
                                return new LazyWrapper(this);
                            }
                            n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);

                            var result = this.clone();
                            if (filtered) {
                                result.__takeCount__ = nativeMin(result.__takeCount__, n);
                            } else {
                                result.__views__.push({
                                    'size': n,
                                    'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
                                });
                            }
                            return result;
                        };

                        LazyWrapper.prototype[methodName + 'Right'] = function(n) {
                            return this.reverse()[methodName](n).reverse();
                        };
                    });

                    // Add `LazyWrapper` methods that accept an `iteratee` value.
                    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
                        var type = index + 1,
                            isFilter = type != LAZY_MAP_FLAG;

                        LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
                            var result = this.clone();
                            result.__iteratees__.push({
                                'iteratee': getCallback(iteratee, thisArg, 1),
                                'type': type
                            });
                            result.__filtered__ = result.__filtered__ || isFilter;
                            return result;
                        };
                    });

                    // Add `LazyWrapper` methods for `_.first` and `_.last`.
                    arrayEach(['first', 'last'], function(methodName, index) {
                        var takeName = 'take' + (index ? 'Right' : '');

                        LazyWrapper.prototype[methodName] = function() {
                            return this[takeName](1).value()[0];
                        };
                    });

                    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
                    arrayEach(['initial', 'rest'], function(methodName, index) {
                        var dropName = 'drop' + (index ? '' : 'Right');

                        LazyWrapper.prototype[methodName] = function() {
                            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
                        };
                    });

                    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
                    arrayEach(['pluck', 'where'], function(methodName, index) {
                        var operationName = index ? 'filter' : 'map',
                            createCallback = index ? baseMatches : property;

                        LazyWrapper.prototype[methodName] = function(value) {
                            return this[operationName](createCallback(value));
                        };
                    });

                    LazyWrapper.prototype.compact = function() {
                        return this.filter(identity);
                    };

                    LazyWrapper.prototype.reject = function(predicate, thisArg) {
                        predicate = getCallback(predicate, thisArg, 1);
                        return this.filter(function(value) {
                            return !predicate(value);
                        });
                    };

                    LazyWrapper.prototype.slice = function(start, end) {
                        start = start == null ? 0 : (+start || 0);

                        var result = this;
                        if (result.__filtered__ && (start > 0 || end < 0)) {
                            return new LazyWrapper(result);
                        }
                        if (start < 0) {
                            result = result.takeRight(-start);
                        } else if (start) {
                            result = result.drop(start);
                        }
                        if (end !== undefined) {
                            end = (+end || 0);
                            result = end < 0 ? result.dropRight(-end) : result.take(end - start);
                        }
                        return result;
                    };

                    LazyWrapper.prototype.takeRightWhile = function(predicate, thisArg) {
                        return this.reverse().takeWhile(predicate, thisArg).reverse();
                    };

                    LazyWrapper.prototype.toArray = function() {
                        return this.take(POSITIVE_INFINITY);
                    };

                    // Add `LazyWrapper` methods to `lodash.prototype`.
                    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                        var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
                            retUnwrapped = /^(?:first|last)$/.test(methodName),
                            lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];

                        if (!lodashFunc) {
                            return;
                        }
                        lodash.prototype[methodName] = function() {
                            var args = retUnwrapped ? [1] : arguments,
                                chainAll = this.__chain__,
                                value = this.__wrapped__,
                                isHybrid = !!this.__actions__.length,
                                isLazy = value instanceof LazyWrapper,
                                iteratee = args[0],
                                useLazy = isLazy || isArray(value);

                            if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
                                // Avoid lazy use if the iteratee has a "length" value other than `1`.
                                isLazy = useLazy = false;
                            }
                            var interceptor = function(value) {
                                return (retUnwrapped && chainAll) ?
                                    lodashFunc(value, 1)[0] :
                                    lodashFunc.apply(undefined, arrayPush([value], args));
                            };

                            var action = {
                                    'func': thru,
                                    'args': [interceptor],
                                    'thisArg': undefined
                                },
                                onlyLazy = isLazy && !isHybrid;

                            if (retUnwrapped && !chainAll) {
                                if (onlyLazy) {
                                    value = value.clone();
                                    value.__actions__.push(action);
                                    return func.call(value);
                                }
                                return lodashFunc.call(undefined, this.value())[0];
                            }
                            if (!retUnwrapped && useLazy) {
                                value = onlyLazy ? value : new LazyWrapper(this);
                                var result = func.apply(value, args);
                                result.__actions__.push(action);
                                return new LodashWrapper(result, chainAll);
                            }
                            return this.thru(interceptor);
                        };
                    });

                    // Add `Array` and `String` methods to `lodash.prototype`.
                    arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {
                        var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
                            chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
                            retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);

                        lodash.prototype[methodName] = function() {
                            var args = arguments;
                            if (retUnwrapped && !this.__chain__) {
                                return func.apply(this.value(), args);
                            }
                            return this[chainName](function(value) {
                                return func.apply(value, args);
                            });
                        };
                    });

                    // Map minified function names to their real names.
                    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                        var lodashFunc = lodash[methodName];
                        if (lodashFunc) {
                            var key = lodashFunc.name,
                                names = realNames[key] || (realNames[key] = []);

                            names.push({
                                'name': methodName,
                                'func': lodashFunc
                            });
                        }
                    });

                    realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{
                        'name': 'wrapper',
                        'func': undefined
                    }];

                    // Add functions to the lazy wrapper.
                    LazyWrapper.prototype.clone = lazyClone;
                    LazyWrapper.prototype.reverse = lazyReverse;
                    LazyWrapper.prototype.value = lazyValue;

                    // Add chaining functions to the `lodash` wrapper.
                    lodash.prototype.chain = wrapperChain;
                    lodash.prototype.commit = wrapperCommit;
                    lodash.prototype.concat = wrapperConcat;
                    lodash.prototype.plant = wrapperPlant;
                    lodash.prototype.reverse = wrapperReverse;
                    lodash.prototype.toString = wrapperToString;
                    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

                    // Add function aliases to the `lodash` wrapper.
                    lodash.prototype.collect = lodash.prototype.map;
                    lodash.prototype.head = lodash.prototype.first;
                    lodash.prototype.select = lodash.prototype.filter;
                    lodash.prototype.tail = lodash.prototype.rest;

                    return lodash;
                }

                /*--------------------------------------------------------------------------*/

                // Export lodash.
                var _ = runInContext();

                // Some AMD build optimizers like r.js check for condition patterns like the following:
                if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
                    // Expose lodash to the global object when an AMD loader is present to avoid
                    // errors in cases where lodash is loaded by a script tag and not intended
                    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
                    // more details.
                    root._ = _;

                    // Define as an anonymous module so, through path mapping, it can be
                    // referenced as the "underscore" module.
                    define(function() {
                        return _;
                    });
                }
                // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
                else if (freeExports && freeModule) {
                    // Export for Node.js or RingoJS.
                    if (moduleExports) {
                        (freeModule.exports = _)._ = _;
                    }
                    // Export for Rhino with CommonJS support.
                    else {
                        freeExports._ = _;
                    }
                } else {
                    // Export for a browser or Rhino.
                    root._ = _;
                }
            }.call(this));

        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

    }, {}]
}, {}, [1])